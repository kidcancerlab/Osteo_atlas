
```{r}
plot_my_stuff <- function(object, what) {
    DimPlot(object,
            group.by = what,
            ncol = 1,
            label = T,
            repel = T,
            shuffle = T,
            cols = c(plot_cols, sample(rainbow(1000)))) +
        coord_fixed() +
        NoLegend()
}
```
# Cell type annotaton function data compilation
```{r}
#loading the normal lungblood ref downloaded
human_lung <- qs::qread("input/downloads/normal_lung.qs")

human_lung$free_annotation <-
    str_replace_all(human_lung$free_annotation, c("/" = "_",
                                                  "\\+" = "_plus"))

human_lung$free_annotation <-
    stringr::str_replace_all(human_lung$free_annotation,
                              c("Alveolar Epithelial Type 1" = "Alveolar Epithelial",  #nolint
                                "Alveolar Epithelial Type 2" = "Alveolar Epithelial",  #nolint
                                "Basophil_Mast 1" = "Basophil_Mast",
                                "Basophil_Mast 2" = "Basophil_Mast",
                                "Bronchial Vessel 1" = "Bronchial Vessel",
                                "Bronchial Vessel 2" = "Bronchial Vessel",
                                "IGSF21_plus Dendritic" = "Dendritic cells",
                                "Myeloid Dendritic Type 1" = "Myeloid Dendritic",   #nolint
                                "Myeloid Dendritic Type 2" = "Myeloid Dendritic",   #nolint
                                "Natural Killer" = "NK cells",
                                "Natural Killer T" = "NKT",
                                "NK cells T" = "NKT",
                                "CD4_plus Memory/Effector T" = "CD4+ T cells",
                                "CD4_plus Naive T" = "CD4+ T cells",
                                "CD8_plus Memory_Effector T" = "CD8+ T cells",
                                "CD8_plus Naive T" = "CD8+ T cells",
                                "Proliferating NK_T" = "NKT",
                                "TREM2_plus Dendritic" = "Dendritic cells",
                                "Proliferating Macrophage" = "Macrophage",
                                "Nonclassical Monocyte" = "Monocytes",
                                "Classical Monocyte" = "Monocytes"))

#camilles paper mouse lung
mouse_lung <- qs::qread("input/downloads/mouse_lung.qs")

mouse_lung$CellType <-
            str_replace_all(mouse_lung$CellType, c("/" = "_",
                                                   "\\+" = "_plus",
                                                   "-" = "_"))


mouse_lung$CellType <-
    stringr::str_replace_all(mouse_lung$CellType,
                            c("Col14a1_plus fibroblast" = "Fibroblasts",
                              "Col13a1_plus fibroblast" = "Fibroblasts",
                              "AT1" = "AT",
                              "AT2 1" = "AT",
                              "AT2 2" = "AT",
                              "B cell 1" = "B cells",
                              "B cell 2" = "B cells",
                              "Cap_a" = "Cap",
                              "CD4 T cell 1" = "CD4",
                              "CD4 T cell 2" = "CD4",
                              "CD8 T cell 1" = "CD8",
                              "CD8 T cell 2" = "CD8",
                              "DC1" = "Dendritic cells",
                              "DC2" = "Dendritic cells",
                              "gd T cell" = "Tgd",
                              "Neut 1" = "Neutrophils",
                              "Neut 2" = "Neutrophils",
                              "NK cell" = "NK cells",
                              "Pericyte 1" = "Pericytes",
                              "Pericyte 2" = "Pericytes",
                              "Mast Ba2" = "Mast_Basophils",
                              "Mono" = "Monocytes"))

#function with mouse and human lung
annotate <- function(sobject,
                     species = "",
                     ref,
                     labels,
                     aggr_ref = FALSE,
                     label_type = "label.main",
                     ...) {
    if (species == "human") {
        hpca <- celldex::HumanPrimaryCellAtlasData()
        huim <- celldex::MonacoImmuneData()
        hpca$label.main <-
            stringr::str_replace_all(hpca$label.main,
                                     c("T_cells" = "T cells",
                                       "B_cell" = "B cells",
                                       "NK_cell" = "NK cells",
                                       "Monocyte" = "Monocytes",
                                       "DC" = "Dendritic cells"))
        ref <- list(hpca,
                    huim)
        labels <- list(hpca[[label_type]],
                      huim[[label_type]])
    } else if (species == "mouse") {
        mord <- celldex::MouseRNAseqData()
        moim <- celldex::ImmGenData()
        moim$label.main <-
            stringr::str_replace_all(moim$label.main,
                                    c("B cells, pro" = "B cells",
                                      "DC" = "Dendritic cells"))
        ref <- list(mord,
                    moim)
        labels <- list(mord[[label_type]],
                       moim[[label_type]])
    } else if (species == "human_lung") {
        hpca <- celldex::HumanPrimaryCellAtlasData()
        hpca$label.main <-
            stringr::str_replace_all(hpca$label.main,
                                     c("T_cells" = "T cells",
                                       "B_cell" = "B cells",
                                       "NK_cell" = "NK cells",
                                       "Monocyte" = "Monocytes",
                                       "DC" = "Dendritic cells"))
        huim <- celldex::MonacoImmuneData()
        ref3 <- GetAssayData(human_lung)
        ref <- list(hpca,
                    huim,
                    ref3)
        labels <- list(hpca[[label_type]],
                       huim[[label_type]],
                       human_lung$free_annotation)
    } else if (species == "mouse_lung") {
        mord <- celldex::MouseRNAseqData()
        moim <- celldex::ImmGenData()
        ref3 <- GetAssayData(mouse_lung)
        moim$label.main <-
            stringr::str_replace_all(moim$label.main,
                                    c("B cells, pro" = "B cells",
                                      "DC" = "Dendritic cells"))
        ref <- list(mord,
                    moim,
                    ref3)
        labels <- list(mord[[label_type]],
                       moim[[label_type]],
                       mouse_lung$CellType)
    }
    annotation <-
        SingleR::SingleR(test = Seurat::as.SingleCellExperiment(sobject),
                         ref = ref,
                         labels = labels,
                         aggr.ref = aggr_ref,
                         ...)
    sobject$annotations <- annotation$labels
    sobject$cell_scores <-
        apply(X = annotation$scores,
              MARGIN = 1,
              function(x) max(x, na.rm = TRUE))
    return(sobject)
}
```

# RUN DEGs 
```{r}
run_degs <- function(sobject,
                     group_by = "",
                     prefix = "") {
    if (group_by == "seurat_clusters") {
        sobject$pseudobulk_col <- stringr::str_c(sobject$sample_name,
                                 "-",
                                 sobject$seurat_clusters)
    } else if (group_by == "annotations") {
        sobject$annotations <-
            stringr::str_replace_all(sobject$annotations, " ", "")
        sobject$pseudobulk_col <- stringr::str_c(sobject$sample_name,
                                 "-",
                                 sobject$annotations)
    }
    pseudobulk <- Seurat::AggregateExpression(object = sobject,
                                      group.by = "pseudobulk_col",
                                      slot = "counts")[[1]]
    deseq_coldata <- data.frame(pseudobulk_group = colnames(pseudobulk))
    rownames(deseq_coldata) <- deseq_coldata$pseudobulk_group
    deseq_coldata <- tidyr::separate(data = deseq_coldata,
                          col = "pseudobulk_group",
                          into = c("sample_name", "group"),
                          sep = "-")
    deseq_coldata$type <- "single-read"
    deseq_coldata <- deseq_coldata[, -1]
    if (group_by == "seurat_clusters") {
        deseq_group <- levels(factor(sobject$seurat_clusters))
        names(deseq_group) <- paste0(prefix, "_Cluster_", deseq_group) #nolint
    } else if (group_by == "annotations") {
        deseq_group <- levels(factor(sobject$annotations))
        names(deseq_group) <- paste0(prefix, "_Celltype_", deseq_group) #nolint
    }
    degs_output <- list()
    for (group in names(deseq_group)) {
        interested_group <- deseq_group[group]
        other_group <- deseq_coldata
        other_group$group[other_group$group == interested_group] <- "target"  #nolint
        other_group$group[other_group$group != "target"] <- "other"         #nolint
        degs_output[[group]] <-
            DESeq2::DESeqDataSetFromMatrix(countData = pseudobulk,
                                           colData = other_group,
                                           design = ~ group) %>%
            DESeq2::DESeq() %>%
            DESeq2::results() %>%
            as.data.frame() %>%
            dplyr::arrange(desc(log2FoldChange)) %>%
            tibble::rownames_to_column("gene") %>%
            na.omit()
    }
    return(degs_output)
}
```

# RUN GSEA
```{r}
#' Run Gene Set Enrichment Analysis (GSEA)
#'
#' This function performs Gene Set Enrichment Analysis (GSEA) using the fgsea package.
#' It takes a list of differential expression results and performs GSEA for each result.
#'
#' @param degs_result A list of differential expression results.
#' @param category The category of gene sets to use for enrichment analysis.
#' @param subcategory The subcategory of gene sets to use for enrichment analysis.
#' @param species The species for which gene sets are available.
#'
#' @return A list of GSEA results for each differential expression result.
#'
#'
#' @examples
#' degs_result <- list(result1 = data.frame(gene = c("gene1", "gene2", "gene3"),
#'                                          log2FoldChange = c(1.5, -2.0, 0.8)),
#'                     result2 = data.frame(gene = c("gene4", "gene5", "gene6"),
#'                                          log2FoldChange = c(0.9, -1.2, 2.3)))
#' run_gsea(degs_result, category = "C2", subcategory = "CP:Canonical pathways", species = "Homo sapiens")

run_gsea <- function(degs_result,
                     category = "",
                     subcategory = "",
                     species = "") {
    gsea_ref <- msigdbr::msigdbr(species = species,
                                 category = category,
                                 subcategory = subcategory) %>%
        split(x = .$gene_symbol, f = .$gs_name)

    gsea_output <- list()
    for (item in names(degs_result)) {
        gsea_input <- as.vector(degs_result[[item]]$log2FoldChange)
        names(gsea_input) <- degs_result[[item]]$gene

        output <- fgsea::fgseaMultilevel(gsea_ref,
                                         gsea_input,
                                         minSize = 10,
                                         maxSize = 500,
                                         nPermSimple = 10000)
        gsea_output[[item]] <- output %>%
            dplyr::arrange(desc(NES)) %>%
            filter(padj < 0.05) %>%
            na.omit()
    }
    return(gsea_output)
}

```


# GSEA Plots function for twoway dotplot and barplot
```{r}

#two way dotplot
two_way_dotplot <- function(data, x_col = "z_score") {
    lab4plot <-
        tibble(y = c(-2.5, 2.5),
               x = c(0.2, 0.2),
               label = c("Downregulated", "Upregulated"))

    plot_name <-
        ggplot() +
        geom_point(data = data,
                 aes(x = -1 * order,
                     y = get(x_col),
                     color = -log10(padj),
                     size = size),
                 stat = "identity",
                 alpha = 0.8) +
        coord_flip() +
        # geom_hline(yintercept = 0,
        #             color = "black",
        #             linewidth = 0.5) +
        geom_text(data = data,                #text for pathways names
                    aes(x = -1 * order,
                        y = get(x_col) + (y_pos *5),
                        hjust = justify_y,
                        label = pathway),
                        size = 2,
                        fontface = "bold") +
        geom_text(data = lab4plot,    #text for upregulated/downregulated
                  aes(x = x,
                      y = y,
                      label = label),
                  fontface = "bold",
                  size = 2.5) +
        scale_fill_manual(values = plot_cols,
                          name = paste0(x_col, " > 0")) +
        theme(strip.background = element_rect(color = "white",
                                              fill = "white"),
              #legend.position = "none",
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              axis.line.x = element_line(color = "black"),
              axis.line.y = element_blank(),
              axis.title.x = element_text(size = 7),
              axis.ticks.y = element_blank(),
              plot.title = element_text(size = 7, face = "bold"),    #title of the plot
              axis.text.y = element_blank(),
              axis.text.x = element_text(size = 7),
              legend.title = element_text(size = 7,
                                          face = "bold")) +
        labs(title = data$sample[1],
             y = "NES",
             x = "") +
        theme(plot.title = element_text(hjust = 0.5)) +
        ylim(-6, 6) +
        scale_color_gradient(low = "pink", high = "darkred")

    return(plot_name)
}


two_way_plot <- function(data, x_col = "z_score") {
    lab4plot <-
        tibble(y = c(-3, 3),
               x = c(0.2, 0.2),
               label = c("Downregulated", "Upregulated"))

    plot_name <-
        ggplot() +
        geom_bar(data = data,
                 aes(x = -1 * order,
                     y = get(x_col),
                     fill = get(x_col) > 0),
                 stat = "identity",
                 alpha = 0.8) +
        coord_flip() +
        geom_hline(yintercept = 0,
                    color = "black",
                    linewidth = 0.5) +
        geom_text(data = data,                #text for pathways names
                    aes(x = -1 * order,
                        y = y_pos,
                        hjust = justify_y,
                        label = pathway),
                        size = 2,
                        fontface = "bold") +
        geom_text(data = lab4plot,    #text for upregulated/downregulated
                  aes(x = x,
                      y = y,
                      label = label),
                  fontface = "bold",
                  size = 2.5) +
        scale_fill_manual(values = plot_cols,
                          name = paste0(x_col, " > 0")) +
        theme(strip.background = element_rect(color = "white",
                                              fill = "white"),
              #legend.position = "none",
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              axis.line.x = element_line(color = "black"),
              axis.line.y = element_blank(),
              axis.title.x = element_text(size = 7),
              axis.ticks.y = element_blank(),
              plot.title = element_text(size = 7, face = "bold"),    #title of the plot
              axis.text.y = element_blank(),
              axis.text.x = element_text(size = 7),
              legend.title = element_text(size = 7,
                                          face = "bold")) +
        labs(title = data$sample[1],
             y = "NES",
             x = "") +
        theme(plot.title = element_text(hjust = 0.5)) +
        ylim(-6, 6) 

    return(plot_name)
}
```


# Recursive clustering function
```{r}

#source("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/10xRNAatac/test1/recurl.R")

recurluster <- function(sobj,
                        level = 1,
                        max_level = 3,
                        min_cells = 0,
                        data_type = "RNA",
                        do_plots = TRUE,
                        parallel = FALSE,
                        verbose = TRUE) {
    if (verbose) {
        message("Clustering level ", level)
    }

    # can't do plots while parallelizing
    if (parallel && do_plots) {
        do_plots <- FALSE
        warning("Cannot plot while operating in parallel")
    }

    # number of PCs needs to be less than number of cells
    pc_num <- min(50, length(Seurat::Cells(sobj)) - 1)

    # Recluster at course resolution
    if (data_type == "RNA") {
        temp_sobj <- sobj %>%
            Seurat::FindVariableFeatures(verbose = FALSE) %>%
            Seurat::RunPCA(verbose = FALSE,
                           npcs = pc_num,
                           approx = FALSE) %>%
            Seurat::FindNeighbors(dims = 1:min(10, pc_num),
                                  verbose = FALSE) %>%
            Seurat::RunUMAP(dims = 1:min(10, pc_num),
                            n.neighbors = min(30, pc_num / 2),
                            verbose = FALSE)
        # opt_res <-
        #     optimize_silhouette(temp_sobj,
        #                         test_res = seq(0.05, 0.3, by = 0.05),
        #                         summary_plot = FALSE) %>%
        #     dplyr::arrange(sil_vals * -1) %>%
        #     dplyr::pull(res_vals) %>%
        #     head(n = 1)

        temp_sobj <- RunHarmony(temp_sobj,
                                group.by.vars = "sample_name")

        temp_sobj <- temp_sobj %>%
            process_seurat(reduction = "harmony",
                           resolution = 0.1)
            # if (verbose) {
            #     message("Optimal resolution: ", opt_res)
            # }
    } else if (data_type == "ATAC") {
        temp_sobj <- sobj %>%
            Signac::RunTFIDF(verbose = FALSE) %>%
            Signac::FindTopFeatures(min.cutoff = "q25", verbose = FALSE) %>%
            Signac::RunSVD(verbose = FALSE) %>%
            Seurat::RunUMAP(reduction = "lsi",
                            dims = 2:min(30, pc_num),
                            verbose = FALSE) %>%
            Seurat::FindNeighbors(dims = 1:min(10, pc_num),
                                  reduction = "lsi",
                                  verbose = FALSE) %>%
            Seurat::FindClusters(algorithm = 3, resolution = res, verbose = FALSE)
    }

    # Add new clusters to the Seurat object, at approprate level
    if (level == 1) {
        temp_sobj[[paste0("clust_", level)]] <-
            paste0("clust_", temp_sobj$seurat_clusters)
    } else {
        temp_sobj[[paste0("clust_", level)]] <-
            paste0(temp_sobj[[paste0("clust_", level - 1)]][, 1],
                   ".",
                   temp_sobj$seurat_clusters)
    }

    # Plot the clusters at this level
    if (do_plots) {
        Seurat::Idents(temp_sobj) <- temp_sobj[[paste0("clust_", level)]]
        print(Seurat::DimPlot(temp_sobj, pt.size = 1) +
            ggplot2::ggtitle(paste0("Level ", level))) +
            ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
    }

    # If more than one cluster isolate and recurluster each cluster
    # Also stop if we've reached the max level
    if (temp_sobj$seurat_clusters %>%
            as.character() %>%
            as.numeric() %>%
            max() > 0 &&
        level < max_level) {

        if (!parallel) {
            sobj_list <-
                lapply(unique(temp_sobj$seurat_clusters),
                       function(x) re_recurluster(sobject = temp_sobj,
                                                  cluster_num = x,
                                                  level = level,
                                                  min_cells = min_cells,
                                                  data_type = data_type,
                                                  do_plots = do_plots,
                                                  parallel = parallel,
                                                  verbose = verbose))
        } else {
            num_cores <- parallel::detectCores()
            sobj_list <-
                parallel::mclapply(unique(temp_sobj$seurat_clusters),
                                   function(x) re_recurluster(sobject = temp_sobj,
                                                              cluster_num = x,
                                                              level = level,
                                                              min_cells = min_cells,
                                                              data_type = data_type,
                                                              do_plots = do_plots,
                                                              parallel = parallel,
                                                              verbose = verbose),
                                   mc.cores = num_cores)
        }
        # Merge the subclusters into a single Seurat object
        temp_sobj <- merge(sobj_list[[1]],
                           sobj_list[2:length(sobj_list)])
    }

    # Fill in NAs in the clustser columns with parent cluster plus "_0"
    for (clust_col in grep("clust_",
                           names(temp_sobj@meta.data),
                           value = TRUE) %>%
            grep("clust_1", ., value = TRUE, invert = TRUE)) {
        clust_num <- stringr::str_remove(clust_col, "clust_") %>%
            as.numeric()

        temp_sobj[[clust_col]] <-
            temp_sobj@meta.data %>%
            as.data.frame() %>%
            dplyr::mutate({{ clust_col }} := dplyr::if_else(is.na(get(clust_col)),
                                              paste0(get(paste0("clust_",
                                                                clust_num - 1)),
                                                     "0"),
                                              get(clust_col))) %>%
            dplyr::pull(get(clust_col))
    }
    return(temp_sobj)
}

re_recurluster <- function(sobject,
                           cluster_num,
                           level,
                           min_cells,
                           data_type,
                           do_plots,
                           parallel,
                           verbose) {
    if (length(which(sobject$seurat_clusters == cluster_num)) > min_cells) {
        if (verbose) {
            message("Processing cluster ",
                    cluster_num,
                    " at level ",
                    level)
        }
        sobj_out <-
            recurluster(subset(sobject,
                                subset = seurat_clusters == cluster_num),
                        level = level + 1,
                        min_cells = min_cells,
                        data_type = data_type,
                        do_plots = do_plots,
                        parallel = parallel)
    } else {
        sobj_out <-
            subset(sobject,
                   subset = seurat_clusters == cluster_num)
    }
    return(sobj_out)
}

recurluster_fill_nas <- function(sobject) {
    for (clust_col in grep("clust_",
                        names(sobject@meta.data),
                        value = TRUE) %>%
        grep("clust_1", ., value = TRUE, invert = TRUE)) {
        clust_num <- stringr::str_remove(clust_col, "clust_") %>%
            as.numeric()

        sobject[[clust_col]] <-
            sobject@meta.data %>%
            as.data.frame() %>%
            dplyr::mutate({{ clust_col }} := dplyr::if_else(is.na(get(clust_col)),
                                                paste0(get(paste0("clust_",
                                                                clust_num - 1)),
                                                        "0"),
                                                get(clust_col))) %>%
            dplyr::pull(get(clust_col))
    }
}

```
