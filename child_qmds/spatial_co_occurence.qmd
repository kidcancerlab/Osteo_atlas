## Cell Type Co-Occurrence

### Cell Type Correlation

The most simple way to address what cells are near each other is by using a simple correlation. For each sample I'll create a heatmap of correlations between cell types.

#### Ann_Level2

```{r}
spatial_list <- qs::qread("output/spatial_objects/spatial_list_level2_annotations.qs")
cell_types_2 <- unique(patient_mets$Ann_Level2)
pdf("output/figures/spatial/cooccurrence/level_2_heatmap.pdf")
for (ob in names(spatial_list)) {
    ann_matrix <- spatial_list[[ob]]@meta.data[ , cell_types_2]
    pheatmap::pheatmap(
        cor(ann_matrix),
        scale = "none",
        low = "blue",
        high = "red",
        mid = "white",
        midpoint = 0
    )
}
dev.off()

```

#### Ann_Level3
```{r cell-type-correlation}
spatial_list <- qs::qread("output/spatial_objects/spatial_list_level3_annotations.qs")
cell_types_3 <- unique(patient_mets$Ann_Level3)
pdf("output/figures/spatial/cooccurrence/level_3_heatmap.pdf")
for (ob in names(spatial_list)) {
    ann_matrix <- spatial_list[[ob]]@meta.data[ , cell_types_3]
    pheatmap::pheatmap(
        cor(ann_matrix),
        scale = "none",
        low = "blue",
        high = "red",
        mid = "white",
        midpoint = 0
    )
}
dev.off()
```

```{r}
#wanna look at correlation with tumor cells
for (ob in names(spatial_list)) {
    png(paste0("output/figures/spatial/cooccurrence/tumor_correlation_", ob, ".png"))

    p <- spatial_list[[ob]]@meta.data[ , c(cell_types, "Tumor_Cumulative")] %>%
        select(-c(Tumor_Proliferative,
                  Tumor_Metabolic,
                  Tumor_ImmuneRegulatory,
                  Tumor_Inflammatory,
                  Tumor_Ground)) %>%
        cor() %>%
        as.data.frame() %>%
        rownames_to_column("celltype1") %>%
        mutate(celltype1 = as.factor(celltype1) %>%
                    fct_reorder(Tumor_Cumulative)) %>%
        filter(celltype1 != "Tumor_Cumulative") %>%
        ggplot(aes(x = "", y = celltype1)) +
        geom_tile(aes(fill = Tumor_Cumulative)) +
        scale_fill_gradient2(low = "blue",
                         high = "red",
                         mid = "white",
                         midpoint = 0)
    print(p)
    dev.off()
    Sys.sleep(0.1)
}

cell_types <- unique(patient_mets$Ann_Level2)
### Create one single annotation matrix with scores from all objects, minus Tumor_Cumulative
ann_mat_list <- lapply(spatial_list, function(x) {
    x@meta.data[ , c(cell_types)]
})

#make one big matrix with deconvolution scores (for correlation purposes)
full_ann_matrix <- bind_rows(ann_mat_list)
png("output/figures/spatial/cooccurrence/all_sample_correlation.png", width = 900, height = 900)
pheatmap::pheatmap(cor(full_ann_matrix[, cell_types], method = "spearman"),
                   scale = "none",
                   low = "blue",
                   high = "red",
                   mid = "white",
                   midpoint = 0,
                   angle_col = 45,
                   fontsize = 16)
dev.off()

#make heatmaps for each sample
cell_type_heatmaps <- lapply(names(ann_mat_list), function(x) {
    p <- pheatmap::pheatmap(cor(ann_mat_list[[x]], method = "spearman"),
                       scale = "none",
                       low = "blue",
                       high = "red",
                       mid = "white",
                       midpoint = 0,
                       angle_col = 45,
                       fontsize = 16)
    png(paste0("output/figures/spatial/cooccurrence/cell_type_heatmap_", x, ".png"), width = 900, height = 900)
    print(p)
    dev.off()
    return(p)
})

# Make feature plots for cell types that correlate with each other
# epithelial and endothelial
plt_list <- lapply(names(spatial_list), function(x) {
    SpatialFeaturePlot(spatial_list[[x]],
                       features = c("Endothelial_cells", "Epithelial_cells"),
                       pt.size.factor = size.factors[[x]],
                       image.alpha = 0)
})

grid.arrange(grobs = plt_list, ncol = 2)


#see what cell types are most highly correlated with tumor subpopulations
tumor_types <- grep("Tumor", cell_types, value = TRUE)
for (feat in tumor_types) {
    #convert variable holding name of column to quosure
    feat_quo <- enquo(feat)

    p <- full_ann_matrix %>%
        dplyr::select(colnames(full_ann_matrix)[grep("Tumor",
                                                     colnames(full_ann_matrix),
                                                     invert = TRUE)],
                      feat) %>%
        cor() %>%
        as.data.frame() %>%
        rownames_to_column("celltype") %>%
        mutate(celltype = as.factor(celltype) %>%
            fct_reorder(.data[[feat]])) %>%
        filter(celltype != !!feat_quo) %>%
        ggplot(aes(x = "", y = celltype)) +
        geom_tile(aes(fill = .data[[feat_quo]])) +
        scale_fill_gradient2(low = "blue",
                             high = "red",
                             mid = "white",
                             midpoint = 0) +
        ggtitle(paste("Cell Type Correlation with", feat, "\n in the Same Spot"))
    png(paste0("output/figures/spatial/cooccurrence/cell_type_correlation_", feat, "_level2.png"))
    print(p)
    dev.off()
}
```

### Spatial Autocorrelation of Cell Types

#### ISCHIA

I'll be using ISCHIA and BANKSY to identify spatially co-occurring cell types

```{r ISCHIA}
for (ob_name in names(spatial_list)) {
    tmp <- spatial_list[[ob_name]]
    annotation_matrix <- tmp@meta.data[, cell_types]
    deconv_mat <- as.matrix(annotation_matrix)
    #find composition clusters 
    #This identifies spots tissue-wide with similar cellular composition; this will enable us to robustly identify communicating cell types within each spot (kinda like pseudo bulking on like spots)
    #Identify how many clusters there should be
    Composition.cluster.k(deconv_mat, 30)
    k <- readline("How many clusters?")
    k <- as.numeric(k)
    tmp <- Composition.cluster(tmp, deconv_mat, k = k)
    png(paste0("output/figures/spatial/ISCHIA/composition_cluster_", ob_name, ".png", width = 600))
    print(SpatialDimPlot(tmp,
                         group.by = "CompositionCluster_CC",
                         pt.size.factor = size.factors[[ob_name]],
                         label = TRUE,
                         image.alpha = 0) |
           SpatialDimPlot(tmp, pt.size.factor = 0))
    dev.off()
    enriched_ct_plots <- lapply(unique(tmp$CompositionCluster_CC),
                                function(cc) {
        Composition_cluster_enrichedCelltypes(tmp, cc, deconv_mat)
                                })
    png(paste0("output/figures/spatial/ISCHIA/ISCHIA_enriched_cell_types_", ob_name, ".png"),
        height = 1600,
        width = 2000)
    grid.arrange(grobs = enriched_ct_plots, ncol = 4)
    dev.off()

    png(paste0("output/figures/spatial/ISCHIA/ISCHIA_coocurring_cells_", ob_name, ".png"),
        height = 1600,
        width = 2000)
    co_occur_list <- lapply(as.list(unique(tmp$CompositionCluster_CC)),
                            spatial.celltype.cooccurence,
                            spatial.object = tmp,
                            deconv.prob.mat = deconv_mat,
                            Condition = unique(tmp$orig.ident),
                            prob.th = 0.05)
    grid.arrange(grobs = lapply(co_occur_list,
                                plot.celltype.cooccurence),
                 ncol = 4)

    dev.off()
    spatial_list[[ob_name]] <- tmp
}

co_occur_list <- lapply(as.list(unique(tmp$Composition_Cluster_CC)),
                        spatial.celltype.cooccurence,
                        spatial.object = tmp,
                        deconv.prob.mat = deconv_mat,
                        Condition = unique(tmp$orig.ident),
                        prob.th = 0.05)
grid.arrange(grobs = lapply(co_occur_list, plot.celltype.cooccurence), ncol = 4)


# devtools::install_github("ati-lz/ISCHIA")
library(ISCHIA)
#we'll be using our `tmp` object, which is the sample named "OS1_Seurat"
#extract devonvolution matrix
#our deconvolution matrix is the same as our `annotation_matrix` object
tmp <- spatial_list[[8]]
annotation_matrix <- tmp@meta.data[, cell_types]
deconv_mat <- as.matrix(annotation_matrix)

#Composition clustering of the deconvoluted spots
#First identify number of clusters there should be?
Composition.cluster.k(deconv_mat, 30)

set.seed(17)

tmp <- Composition.cluster(tmp, deconv_mat, 8)
table(tmp$CompositionCluster_CC)
SpatialDimPlot(tmp,
               group.by = "CompositionCluster_CC",
               pt.size.factor = size.factors[[8]],
               label = TRUE) | SpatialDimPlot(tmp, pt.size.factor = 0)

enriched_ct_plots <- lapply(unique(tmp$CompositionCluster_CC), function(cc) {
    Composition_cluster_enrichedCelltypes(tmp, cc, deconv_mat)
})

grid.arrange(grobs = enriched_ct_plots)


tmp_umaps <- Composition_cluster_umap(tmp, deconv_mat)
#Check cell type occurences
#examine globally
# tmp$CompositionCluster_CC <- "global"
CC1_co_occur <- spatial.celltype.cooccurence(tmp,
                                             deconv_mat,
                                             COI = "global",
                                             Condition = unique(tmp$orig.ident),
                                             prob.th = 0.1)

co_occur_list <- lapply(as.list(paste0("CC", 1:8)),
                        spatial.celltype.cooccurence,
                        spatial.object = tmp,
                        deconv.prob.mat = deconv_mat,
                        Condition = unique(tmp$orig.ident),
                        prob.th = 0.05)
grid.arrange(grobs = lapply(co_occur_list[1:4], plot.celltype.cooccurence))


plot.celltype.cooccurence(CC1_co_occur)
```

#### BANKSY

```{r banksy}

#had to update my packages to R 4.4.0 for this
#going to restart with samples with no deconvolution info
spatial_list <- qs::qread("output/spatial_objects/spatial_list_level2_annotations.qs")
library(Banksy)
library(SpatialExperiment)
library(scuttle)
library(scater)

### Calculate banksy clusters for each object
for (ob_name in names(spatial_list)) {
    s_obj <- spatial_list[[ob_name]]
    #Initialize SpatialExperiment objects
    spat_counts <- GetAssayData(s_obj, layer = "counts")
    locs <- GetTissueCoordinates(s_obj)
    se <- SpatialExperiment(assay =  list(counts = spat_counts),
                            spatialCoords = as.matrix(locs))
    #no need to QC as seurat object has already been QC'ed
    #normalize to mean library size
    se <- computeLibraryFactors(se)
    aname <- "normcounts"
    assay(se, aname) <- normalizeCounts(se, log = FALSE)
    #Compute neighborhood matrices
    #lambda = 0 will correspond to non-spatial clustering, and lambda = 0.2 corresponds to banksy   clustering
    #banksy clustering incorporates cell spot environment information into its clustering
    lambda = c(0, 0.2)
    k_geom = c(15, 30)
    se <- Banksy::computeBanksy(se,
                                assay_name = aname,
                                compute_agf = TRUE,
                                k_geom = k_geom)

    #next run PCA on the banksy matrix and perform clustering;
    #setting use_agf to true uses both M, the weighted mean of gene expression in the neighborhood, and G, the azimuthal gabor filter(?) -- this just allows cells that aren't physically proximal to be identified as the same cell type
    set.seed(17)
    se <- runBanksyPCA(se, use_agf = TRUE, lambda = lambda)
    se <- runBanksyUMAP(se, use_agf = TRUE, lambda = lambda)
    se <- clusterBanksy(se, use_agf = TRUE, lambda = lambda, resolution = seq(0.3, 1.5, by = 0.1))
    #relabel clustering runs to minimize their differences (not sure the point of this step)
    se <- Banksy::connectClusters(se)
    #add banksy clusters to seurat object
    compareClusters(se, func = "ARI")
    s_obj$banksy_clusts <- se$clust_M1_lam0.2_k50_res0.8[match(colnames(s_obj), colnames(se))]

    spatial_list[[ob_name]] <- s_obj
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level2_annotations.qs")

#Visualize clustering output
for (ob_name in names(spatial_list)) {
    png(paste0("output/figures/spatial/BANKSY/", ob_name, "_banksy_cluster_umap.png"), width = 800)
    print(
        SpatialDimPlot(spatial_list[[ob_name]],
               group = "banksy_clusts",
               pt.size.factor = size.factors[[ob_name]],
               image.alpha = 0,
               label = TRUE) |
    SpatialDimPlot(spatial_list[[ob_name]], pt.size.factor = 0)
    )
    dev.off()
}

#Make heatmaps
for (ob_name in names(spatial_list)) {
    s_obj <- spatial_list[[ob_name]]
    deconv_mat <- s_obj@meta.data[, c(cell_types, "banksy_clusts")]
    #get cell type means
    # ct_means <- colMeans(as.matrix(s_obj@meta.data[, cell_types]))
    tmp <- list()
    for (bc in unique(deconv_mat$banksy_clusts)) {
        ct_means <- colMeans(as.matrix(s_obj@meta.data[which(s_obj$banksy_clusts != bc), cell_types]))
        tmp_mat <- subset(deconv_mat, banksy_clusts == bc) %>%
            dplyr::select(cell_types)
        tmp[[bc]] <- colMeans(tmp_mat > ct_means)
        tmp[[bc]] <- as.data.frame(x = tmp[[bc]])
        colnames(tmp[[bc]]) <- paste0("banksy_", bc)
    }
    bind_tmp <- bind_cols(tmp)

    png(paste0("output/figures/spatial/BANKSY/", ob_name, "_banksy_mean_deconv_heatmap.png"))
    print(pheatmap::pheatmap(bind_tmp, scale = "row"))
    dev.off()
}

#going to make heat maps of % of spots within banksy cluster with deconv score greater than mean for all cell types
s_obj <- spatial_list[[6]]
mean_deconv <- apply(s_obj@meta.data[, cell_types], 2, mean)

tmp <- list()
for (bc in unique(s_obj$banksy_clusts)) {
    tmp[[bc]] <- subset(s_obj@meta.data, banksy_clusts == bc) %>%
        select(cell_types)
    tmp[[bc]] <- colMeans(tmp[[bc]] > mean_deconv)
    tmp[[bc]] <- as.data.frame(x = tmp[[bc]])
    colnames(tmp[[bc]]) <- paste0("banksy_", bc)
}
binded_res <- bind_cols(tmp)
pheatmap::pheatmap(binded_res)
SpatialDimPlot(s_obj, group = "banksy_clusts", pt.size.factor = 3000) | SpatialDimPlot(s_obj, pt.size.factor = 0)

```

#### Seurat Clusters

```{r cluster-based-correlation}
#Making seurat_cluster based heatmaps like I did for banksy
for (ob_name in names(spatial_list)) {
    s_obj <- spatial_list[[ob_name]]
    deconv_mat <- s_obj@meta.data[, c(cell_types, "seurat_clusters")]
    #get cell type means
    tmp <- list()
    for (clust in unique(s_obj$seurat_clusters)) {
        ct_means <- colMeans(s_obj@meta.data[which(s_obj$seurat_clusters != clust),
                                             cell_types])
        tmp_mat <- subset(deconv_mat, seurat_clusters == clust) %>%
            dplyr::select(cell_types)
        tmp[[clust]] <- colMeans(tmp_mat > ct_means)
        tmp[[clust]] <- as.data.frame(x = tmp[[clust]])
        colnames(tmp[[clust]]) <- paste0("cluster_", clust)
    }
    bind_tmp <- bind_cols(tmp)

    png(paste0("figures/spatial/seurat_cluster_heatmap_", ob_name, ".png"))
    print(pheatmap::pheatmap(bind_tmp, scale = "row"))
    dev.off()
}

```