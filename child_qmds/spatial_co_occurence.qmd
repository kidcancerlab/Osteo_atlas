## Cell Type Co-Occurrence

### Cell Type Correlation

The most simple way to address what cells are near each other is by using a simple correlation. For each sample I'll create a heatmap of correlations between cell types.

```{r cell-type-correlation}
for (ob in names(spatial_list)) {
    ann_matrix <- spatial_list[[ob]]@meta.data[ , cell_types]
    png(paste0("figures/spatial/cell_type_heatmap_", ob, "_level3.png"), height = 800, width = 800)
    pheatmap::pheatmap(cor(ann_matrix),
                       scale = "none",
                       low = "blue",
                       high = "red",
                       mid = "white",
                       midpoint = 0)
    dev.off()
}


#wanna look at correlation with tumor cells
for (ob in names(spatial_list)) {
    png(paste0("figures/spatial/tumor_correlation_", ob, ".png"))

    p <- spatial_list[[ob]]@meta.data[ , c(cell_types, "Tumor_Cumulative")] %>%
        select(-c(Tumor_Proliferative,
                  Tumor_Metabolic,
                  Tumor_ImmuneRegulatory,
                  Tumor_Inflammatory,
                  Tumor_Ground)) %>%
        cor() %>%
        as.data.frame() %>%
        rownames_to_column("celltype1") %>%
        mutate(celltype1 = as.factor(celltype1) %>%
                    fct_reorder(Tumor_Cumulative)) %>%
        filter(celltype1 != "Tumor_Cumulative") %>%
        ggplot(aes(x = "", y = celltype1)) +
        geom_tile(aes(fill = Tumor_Cumulative)) +
        scale_fill_gradient2(low = "blue",
                         high = "red",
                         mid = "white",
                         midpoint = 0)
    print(p)
    dev.off()
    Sys.sleep(0.1)
}


### Create one single annotation matrix with scores from all objects
ann_mat_list <- lapply(spatial_list, function(x) {
    x@meta.data[ , c(cell_types, "Tumor_Cumulative")]
})

full_ann_matrix <- bind_rows(ann_mat_list)
png("figures/spatial/all_sample_correlation.png", width = 1200, height = 1200)
pheatmap::pheatmap(cor(full_ann_matrix[, cell_types], method = "spearman"),
                   scale = "none",
                   low = "blue",
                   high = "red",
                   mid = "white",
                   midpoint = 0,
                   angle_col = 45,
                   fontsize = 16)
dev.off()

full_ann_matrix %>%
    select(-c(Tumor_Metabolic,
              Tumor_Proliferative,
              Tumor_ImmuneRegulatory,
              Tumor_Ground,
              Tumor_Inflammatory)) %>%
    cor(method = "spearman") %>%
    as.data.frame() %>%
    rownames_to_column("celltype1") %>%
    mutate(celltype1 = as.factor(celltype1) %>%
                fct_reorder(Tumor_Cumulative)) %>%
    filter(celltype1 != "Tumor_Cumulative") %>%
    ggplot(aes(x = "", y = celltype1)) +
    geom_tile(aes(fill = Tumor_Cumulative)) +
    scale_fill_gradient2(low = "blue",
                         high = "red",
                         mid = "white",
                         midpoint = 0)


tumor_types <- c("Tumor_Metabolic",
               "Tumor_Proliferative",
               "Tumor_ImmuneRegulatory",
               "Tumor_Ground",
               "Tumor_Inflammatory")

for (feat in tumor_types) {
    #convert variable holding name of column to quosure
    feat_quo <- enquo(feat)

    p <- full_ann_matrix %>%
        dplyr::select(colnames(full_ann_matrix)[grep("Tumor",
                                                     colnames(full_ann_matrix),
                                                     invert = TRUE)],
                      feat) %>%
        cor() %>%
        as.data.frame() %>%
        rownames_to_column("celltype") %>%
        mutate(celltype = as.factor(celltype) %>%
            fct_reorder(.data[[feat]])) %>%
        filter(celltype != !!feat_quo) %>%
        ggplot(aes(x = "", y = celltype)) +
        geom_tile(aes(fill = .data[[feat_quo]])) +
        scale_fill_gradient2(low = "blue",
                             high = "red",
                             mid = "white",
                             midpoint = 0) +
        ggtitle(paste("Cell Type Correlation with", feat, "\n in the Same Spot"))
    png(paste0("figures/spatial/cell_type_correlation_", feat, "_level3.png"))
    print(p)
    dev.off()
}
```

```{r scratch}
for(ob in names(spatial_list)) {
    tmp <- spatial_list[[3]]
    macs_tumor <- c("Scar_TAMs",
                    "Osteoclast_TAMs",
                    "Prolif_TAMs",
                    "Normal_Fibroblasts",
                    "Tuft_cells",
                    "Tumor_Cumulative",
                    "CAF")
    png(paste0("figures/spatial/tumor_macs_", ob, ".png"), width = 800)
    SpatialFeaturePlot(tmp,
                    features = macs_tumor,
                    pt.size.factor = size.factors[[ob]],
                    image.alpha = 0,
                    ncol = 4)
    SpatialDimPlot(tmp, pt.size.factor = 0)
    dev.off()
}


#going to try weighing annotation scores by distance?
coords <- GetTissueCoordinates(tmp)
coords[1:5, ]
coord_dist <- as.matrix(dist(coords))
cell_type_weights <- 1/(coord_dist+1)*tmp@meta.data[,cell_types]
head(cell_type_weights)

```

### Spatial Autocorrelation of Cell Types

I'll be using ISCHIA and BANKSY to identify spatially co-occurring cell types

```{r ISCHIA}
# devtools::install_github("ati-lz/ISCHIA")
library(ISCHIA)
#we'll be using our `tmp` object, which is the sample named "OS1_Seurat"
#extract devonvolution matrix
#our deconvolution matrix is the same as our `annotation_matrix` object
tmp <- spatial_list[[1]]
annotation_matrix <- tmp@meta.data[, cell_types]
deconv_mat <- as.matrix(annotation_matrix)

#Composition clustering of the deconvoluted spots
#This identifies spots tissue-wide with similar cellular composition; this will enable us to robustly identify communicating cell types within each spot (kinda like pseudo bulking on like spots)
#First identify number of clusters there should be?
Composition.cluster.k(deconv_mat, 30)

set.seed(17)

tmp <- Composition.cluster(tmp, deconv_mat, 8)
table(tmp$CompositionCluster_CC)
SpatialDimPlot(tmp,
               group.by = "CompositionCluster_CC",
               pt.size.factor = 1500,
               label = TRUE) | SpatialDimPlot(tmp, pt.size.factor = 0)

enriched_ct_plots <- lapply(unique(tmp$CompositionCluster_CC), function(cc) {
    Composition_cluster_enrichedCelltypes(tmp, cc, deconv_mat)
})

grid.arrange(grobs = enriched_ct_plots)


tmp_umaps <- Composition_cluster_umap(tmp, deconv_mat)
#Check cell type occurences
#examine globally
tmp$CompositionCluster_CC <- "global"
CC1_co_occur <- spatial.celltype.cooccurence(tmp,
                                             deconv_mat,
                                             COI = "global",
                                             Condition = unique(tmp$orig.ident),
                                             prob.th = 0.1)

co_occur_list <- lapply(as.list(paste0("CC", 1:8)),
                        spatial.celltype.cooccurence,
                        spatial.object = tmp,
                        deconv.prob.mat = deconv_mat,
                        Condition = unique(tmp$orig.ident),
                        prob.th = 0.05)
grid.arrange(grobs = lapply(co_occur_list[5:8], plot.celltype.cooccurence))


plot.celltype.cooccurence(CC1_co_occur)
```

```{r banksy}
#had to update my packages to R 4.4.0 for this
#going to restart with samples with no deconvolution info
spatial_list <- qs::qread("output/spatial_objects/spatial_list_level2_annotations.qs")
library(Banksy)
library(SpatialExperiment)
library(scuttle)
library(scater)

###Going to test on OS1
s_obj <- spatial_list[[1]]
#Initialize SpatialExperiment objects
spat_counts <- GetAssayData(s_obj, layer = "counts")
locs <- GetTissueCoordinates(s_obj)
se <- SpatialExperiment(assay =  list(counts = spat_counts),
                        spatialCoords = as.matrix(locs))
#no need to QC as seurat object has already been QC'ed
#normalize to mean library size
se <- computeLibraryFactors(se)
aname <- "normcounts"
assay(se, aname) <- normalizeCounts(se, log = FALSE)
#Compute neighborhood matrices
#lambda = 0 will correspond to non-spatial clustering, and lambda = 0.2 corresponds to banksy clustering
#banksy clustering incorporates cell spot environment information into its clustering
lambda = c(0, 0.2)
k_geom = c(15, 30)
se <- Banksy::computeBanksy(se,
                            assay_name = aname,
                            compute_agf = TRUE,
                            k_geom = k_geom)


#next run PCA on the banksy matrix and perform clustering;
#setting use_agf to true uses both M, the weighted mean of gene expression in the neighborhood, and G, the azimuthal gabor filter(?) -- this just allows cells that aren't physically proximal to be identified as the same cell type
set.seed(17)
se <- runBanksyPCA(se, use_agf = TRUE, lambda = lambda)
se <- runBanksyUMAP(se, use_agf = TRUE, lambda = lambda)
se <- clusterBanksy(se, use_agf = TRUE, lambda = lambda)
#relabel clustering runs to minimize their differences (not sure the point of this step)
se <- Banksy::connectClusters(se)

#Visualize clustering output
cnames <- colnames(colData(se))
cnames <- cnames[grep("^clust", cnames)]
colData(se) <- cbind(colData(se), spatialCoords(se))
plot_nsp <- plotColData(se,
                        x = "imagerow",
                        y = "imagecol",
                        point_size = 1.2,
                        colour_by = cnames[1])
plot_bank <- plotColData(se,
                         x = "imagerow",
                         y = "imagecol",
                         point_size = 1.5,
                         colour_by = cnames[2])

#add banksy clusters to seurat object
s_obj$banksy_clusts <- se$clust_M1_lam0.2_k50_res1[match(colnames(s_obj), colnames(se))]

SpatialDimPlot(s_obj,
               group = "banksy_clusts",
               pt.size.factor = 1500,
               image.alpha = 0,
               label = TRUE) | SpatialDimPlot(s_obj, pt.size.factor = 0)

r_dim_plot(s_obj, group = c("seurat_clusters", "banksy_clusts"))

#Lets see what cell types (from the deconvolution data) are enriched in each banksy cluster
deconv_mat <- s_obj@meta.data[, c(cell_types, "banksy_clusts")]
mean_deconv <- colMeans(deconv_mat[, cell_types])

tmp <- list()
for (bc in unique(deconv_mat$banksy_clusts)) {
    tmp[[bc]] <- subset(deconv_mat, banksy_clusts == bc) %>%
        dplyr::select(cell_types) %>%
        colMeans()
    tmp[[bc]]["banksy_clust"] <- bc
    as.data.frame(x = tmp[[bc]], col.names = "mean_deconv")
}

bind_rows(tmp, id = "banksy_clust") %>%
    pivot_longer(cols = cell_types, names_to = "cell_type", values_to = "mean_deconv") %>%
    print(n = 30)


s <- SpatialDimPlot(s_obj,
               group = "banksy_clusts",
               pt.size.factor = 1500,
               image.alpha = 0,
               label = TRUE)


ggplot(bind_rows(tmp)) +
    geom_tile(x = )



group_by(deconv_mat, banksy_clusts) %>%
    summarize(colMeans())






deconv_list <- split(deconv_mat, f = deconv_mat$banksy_clusts)
lapply(deconv_list, function(x) {
    dplyr::select(x, -banksy_clusts) %>%
    
})


```