
## Regulons analysis

Perform the regulon analysis using the SCENIC package. The regulon analysis is 
performed on the following groups:
- patient_prim_cancer_cells
- patient_mets_cancer_cells
- mm_prim_cancer_cells
- mm_mets_cancer_cells
- xeno_prim_human
- xeno_mets_human
- patient_prim_normal_cells
- patient_mets_normal_cells
- xeno_prim_mouse
- xeno_mets_mouse
- mm_prim_normal_cells
- mm_mets_normal_cells


```{r, eval = FALSE}
library(SCENIC)

#If needed to subset to subset_cell_number cells for quicker run
Run_GRA <- function(sobject,
                    idents,
                    org,      #organism "mgi" for mouse, "hgnc" for human
                    subset = "no",          #yes or no
                    subset_cell_number = NA) {
    #if you want to quickly run a small subset of cells, set subset = "yes" and provide the subset_cell_number for number of cells
    if (subset == "yes") {
        sobject <- subset(x = sobject,
                        cells = sample(Cells(sobject),
                                min(subset_cell_number, length(Cells(sobject)))))
    } else {
        sobject <- sobject
    }
    sobject <- JoinLayers(sobject)
    exprMat <- SeuratObject::GetAssayData(sobject, assay = 'RNA', slot= 'counts') %>% 
        as.matrix()
    Idents(sobject) <- idents
    if (idents == "seurat_clusters") {
        cellInfo <- data.frame(CellType=Idents(sobject)) %>%
            dplyr::arrange(CellType)
    } else {
        cellInfo <- data.frame(CellType=Idents(sobject))
    }
    saveRDS(cellInfo, file="input/downloads/SCENIC/cellInfo.Rds")
    cols <- c(plot_cols, sample(rainbow(1000)))
    CellType <- cols[1:length(unique(cellInfo$CellType))]
    names(CellType) <- unique(cellInfo$CellType)
    colVars <- list()
    colVars$CellType <- CellType
    saveRDS(colVars, file="input/downloads/SCENIC/colVars.Rds")

    #Running SCENIC begins
    scenicOptions <- SCENIC::initializeScenic(org = org,
                                              dbDir = "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/SCENIC",
                                              dbs = SCENIC::defaultDbNames[[org]],
                                              datasetTitle = "SCENIC tutorial",
                                              nCores = parallelly::availableCores())

    scenicOptions@inputDatasetInfo$cellInfo <- "input/downloads/SCENIC/cellInfo.Rds"
    scenicOptions@inputDatasetInfo$colVars <- "input/downloads/SCENIC/colVars.Rds"

    ##### III: Co-expression network
    ### 1. Gene filter/selection
    genesKept <- SCENIC::geneFiltering(exprMat,
                                       scenicOptions=scenicOptions,
                                       minCountsPerGene=3*.01*ncol(exprMat),
                                       minSamples=ncol(exprMat)*.01)
    
    # filter the expression matrix to contain only these genes from geneskept.
    exprMat_filtered <- exprMat[genesKept, ]

    ### 2. Correlation: positive means TF could upregulate the target gene and viceversa
    SCENIC::runCorrelation(exprMat_filtered, scenicOptions)

    ### 3. Run GENIE3 to infer potential transcription factor targets
    # Optional: add log (if it is not logged/normalized already)
    exprMat_filtered <- log2(exprMat_filtered+1)

    # Run GENIE3 and find potential TF targets
    SCENIC::runGenie3(exprMat_filtered, scenicOptions)

    ###### IV: Build the gene regulatory network & Identify cell states:
    ### Build the gene regulatory network: 
    # 1. Get co-expression modules
    scenicOptions <- SCENIC::runSCENIC_1_coexNetwork2modules(scenicOptions)

    # 2. Get regulons (with RcisTarget: TF motif analysis)
    scenicOptions <- SCENIC::runSCENIC_2_createRegulons(scenicOptions,
                                                coexMethod=c("top5perTarget"))

    ### Identify cell states: 
    # 3. Score GRN (regulons) in the cells (with AUCell) 
    exprMat_log <- log2(exprMat+1)

    scenicOptions <- SCENIC::runSCENIC_3_scoreCells(scenicOptions, exprMat_log)

    # 4.2 Binarize the network activity (regulon on/off)
    scenicOptions@settings$devType = "png"
    scenicOptions <- SCENIC::runSCENIC_4_aucell_binarize(scenicOptions,
                                                         exprMat = exprMat_log)

    return(list(scenicOptions= scenicOptions,
                cellInfo = cellInfo,
                colVars = colVars,
                exprMat_log = exprMat_log))
}

#load the motif annotations
data(list="motifAnnotations_hgnc", package="RcisTarget")
motifAnnotations_hgnc <- motifAnnotations

data(list="motifAnnotations_mgi", package="RcisTarget")
motifAnnotations_mgi <- motifAnnotations

object_list <- 
    c("patient_prim_cancer_cells",
    "patient_mets_cancer_cells",
    "mm_prim_cancer_cells",
    "mm_mets_cancer_cells",
    "xeno_prim_human",
    "xeno_mets_human",
    "patient_prim_normal_cells",
    "patient_mets_normal_cells",
    "xeno_prim_mouse",
    "xeno_mets_mouse",
    "mm_prim_normal_cells",
    "mm_mets_normal_cells")


for (group in object_list) {
    sobject <- 
        qs::qread(str_c("output/seurat_objects/resolution_optimized/",
                              group,
                              ".qs"))
    # 4.1 Run SCENIC
    if (sobject$organism[1] == "human") {
    GRA_output <- Run_GRA(sobject = sobject,
                            idents = "seurat_clusters",
                            org = "hgnc",
                            subset = "yes",
                            subset_cell_number = 2000)
    } else {
    GRA_output <- Run_GRA(sobject = sobject,
                            idents = "seurat_clusters",
                            org = "mgi",
                            subset = "yes",
                            subset_cell_number = 2000)
    }
    #reassign the varibale names
    exprMat_log <- GRA_output$exprMat_log
    colVars <- GRA_output$colVars
    cellInfo <- GRA_output$cellInfo
    scenicOptions <- GRA_output$scenicOptions

    # 4.3 Cluster cells according to the GRN activity (Optional)
    # 4.3.1 set number of PCs
    nPcs <- c(30)

    # 4.3.2 Calculates the t-SNE based on the regulon activity
    scenicOptions@settings$seed <- 123    #same seed for all of them
    fileNames <- SCENIC::tsneAUC(scenicOptions, aucType="AUC", nPcs= nPcs, perpl=c(5,15,50))

    ### 4. combine SCENIC analysis with other analysis tools Regulators for known cell types or clusters
    ## 4.1 ComplexHeatmap to show average regulon activity by cell clusters
    library(ComplexHeatmap)
    regulonAUC <- SCENIC::loadInt(scenicOptions, "aucell_regulonAUC")
    regulonAUC <- regulonAUC[SCENIC::onlyNonDuplicatedExtended(rownames(regulonAUC)),]
    regulonActivity_byCellType_Scaled <- 
        sapply(split(rownames(cellInfo),
                     cellInfo$CellType),
               function(cells) rowMeans(AUCell::getAUC(regulonAUC)[ , cells, drop=FALSE])) %>%
        t() %>%
        scale(center = F, scale = T) %>%
        t()
    x <- pheatmap::pheatmap(regulonActivity_byCellType_Scaled,
                        name="Regulon activity",
                        scale="none",
                        cluster_cols = FALSE,
                        show_row_dend = FALSE,
                        height = 10,
                        width = 5,
                        filename = str_c("output/Regulon_analysis/", group, "regulons_.png"))
    # ggsave(str_c("output/Regulon_analysis/",group, ".png"),
    #             width = 6,
    #             height = 10,
    #             plot = x)

    # topRegulators for each cell type: Relative Activity
    topRegulators <- reshape2::melt(regulonActivity_byCellType_Scaled)
    colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
    topRegulators <- topRegulators[which(topRegulators$RelativeActivity > 0.5),]
    # ggplot(data = topRegulators,
    #        aes(x = CellType,
    #               y = Regulon,
    #               size = RelativeActivity,
    #               color = RelativeActivity)) +
    #     geom_point()

    ## 4.2 Binarized data per cell 
    minPerc <- .4 # percentage of cells in a cluster with the regulon is active
    binaryRegulonActivity <- loadInt(scenicOptions, "aucell_binary_nonDupl")
    cellInfo_binarizedCells <- cellInfo[which(
    rownames(cellInfo)%in% colnames(binaryRegulonActivity)),, drop=FALSE]
    regulonActivity_byCellType_Binarized <- sapply(
        split(rownames(cellInfo_binarizedCells), cellInfo_binarizedCells$CellType), 
            function(cells) rowMeans(binaryRegulonActivity[,cells, drop=FALSE]))
    binaryActPerc_subset <- regulonActivity_byCellType_Binarized[which(
        rowSums(regulonActivity_byCellType_Binarized > minPerc) > 0),]

    #percentage of cells per each cluster that have the regulon activity
    y <- 
        pheatmap::pheatmap(binaryActPerc_subset,
                            name="Regulon activity", 
                            col = c("white","pink","red"),
                            display_numbers = T,
                            cluster_cols = FALSE,
                            width = 5,,
                            height = 10,
                            filename = str_c("output/Regulon_analysis/", group, "percent_.png"))
}



```


```{python, eval = FALSE}
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import scvelo as scv #just using for dataset

import celloracle as co
from celloracle.applications import Pseudotime_calculator
from celloracle.applications import Gradient_calculator
from celloracle.applications import Oracle_development_module

adata = scv.datasets.pancreas()
InstallData("pbmc3k")
data("pbmc3k.final")
pbmc3k.final

library(scater)
library(Seurat)
library(cowplot)
sobj <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_tumor.qs")

pbmc_sce <- srt_to_adata(sobj)


sceasy::convertFormat(ad, from="anndata", to="seurat", outFile='file.rds')

pbmc_sce <- Convert(from = pbmc, to = "sce")


library(Seurat)
library(SeuratDisk)

# step 1: Slim down a Seurat object. So you get raw counts, lognorm counts

seu = DietSeurat(
  sobj,
  counts = TRUE, # so, raw counts save to adata.raw.X 
  data = TRUE, # so, log1p counts save to adata.X
  scale.data = FALSE, # set to false, or else will save to adata.X
  features = rownames(sobj), # export all genes, not just top highly variable genes
  assays = "RNA",
  dimreducs = c("pca","umap"),
  graphs = c("RNA_nn", "RNA_snn"), # to RNA_nn -> distances, RNA_snn -> connectivities
  misc = TRUE
)

# step 2: factor to character, or else your factor will be number in adata 
i <- sapply(seu@meta.data, is.factor)
seu@meta.data[i] <- lapply(seu@meta.data[i], as.character)

# step 3: convert 
SaveH5Seurat(seu, filename = "srt.h5seurat", overwrite = TRUE)

Convert("srt.h5seurat", "srt.h5ad", assay="RNA", overwrite = TRUE)

adata = sc.read_h5ad("srt.h5ad")


library(reticulate)
library(anndata)
library(sceasy)

library(Seurat)
library(SeuratData)

```




```{r, eval = FALSE}

seuratobject <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_tumor.qs")
DimPlot(seuratobject)

sobj <- subset(x = seuratobject,
                     cells = sample(Cells(seuratobject),
                        min(700, length(Cells(seuratobject)))))
DimPlot(sobj)

library(BITFAM)


Run_BITFAM <- function(sobj,
                       species = "",
                       idents = "",
                       plot = "",
                       scATAC_obj = NA,) {
    SeuratObject::Idents(sobj) <- idents
    raw_mtx <- sobj@assays$RNA@counts
    mtx <- BITFAM_preprocess(raw_data = raw_mtx)
    res <- BITFAM(data = mtx,
             species = "human",
             scATAC_obj = scATAC_obj,
             ncores = parallelly::availableCores())
    Z <- BITFAM_activities(res)
    Z_tsne <- as.data.frame(Rtsne(Z)$Y)
    colnames(Z_tsne) <- c("tSNE_1", "tSNE_2")
    Z_tsne$Cell_type <- Idents(sobj)
    if (plot == "TRUE") {
        ggplot(Z_tsne, aes(tSNE_1, tSNE_2, color = Cell_type)) + geom_point(size=0.8)
    } else if (plot == "FALSE") {
        tsne_plot <- ggplot(Z_tsne, aes(tSNE_1, tSNE_2, color = Cell_type)) + 
            geom_point(size=0.8)
        print("type tsne_plot in the R terminal to visualize the plot")
    }

    cell_type_df <- data.frame()
    for (item in unique(Idents(sobj))) {
        cell_type_df[[item]] <- ifelse(Idents(sobj) == "1", 1, 0)
    }


    cell_type_df <- data.frame(C1 = ifelse(sobj$seurat_clusters == "1", 1, 0),
                                C2 = ifelse(sobj$seurat_clusters == "2", 1, 0),
                                C3 = ifelse(sobj$seurat_clusters == "3", 1, 0),
                                C4 = ifelse(sobj$seurat_clusters == "4", 1, 0))

}


for (item in unique(Idents(sobj))) {
    print(item)
}




raw_mtx <- sobj@assays$RNA@counts

mtx <- BITFAM_preprocess(raw_data = raw_mtx)

res <- BITFAM(data = mtx,
             species = "human",
             scATAC_obj = NA,
             ncores = parallelly::availableCores())

#qs::qsave(res, "res.qs")

Z <- BITFAM_activities(res)
write.table(Z, file = "BITFAM_out.csv", sep = ",")
Z_tsne <- as.data.frame(Rtsne(Z)$Y)
colnames(Z_tsne) <- c("tSNE_1", "tSNE_2")


Z_tsne$Cell_type <- sobj$seurat_clusters
ggplot(Z_tsne, aes(tSNE_1, tSNE_2, color = Cell_type)) + geom_point(size=0.8)


cell_type_df <- data.frame(C1 = ifelse(sobj$seurat_clusters == "1", 1, 0),
                           C2 = ifelse(sobj$seurat_clusters == "2", 1, 0),
                           C3 = ifelse(sobj$seurat_clusters == "3", 1, 0),
                           C4 = ifelse(sobj$seurat_clusters == "4", 1, 0))

library(randomForest)




Z <- as.data.frame(Z)
Z_C1 <- cbind(Z, cell_type_df$C1) 
colnames(Z_C1)[157] <- "C1"
Z_C1$C1 <- factor(Z_C1$C1)
fit_rf <- randomForest(C1~., data = Z_C1)  ## build the RF model 
C1_tf_top10 <- importance(fit_rf)[order(importance(fit_rf)[, 1], decreasing = T), ][1:10]




umaps_group <- 
    tribble(~sobj,            ~title,                  ~combine,
            "patient_prim",    "Patient Primary",      "no",
            "patient_mets",    "Patient Metastatic",   "no",
            "xeno_prim",       "Xenograft Primary",    "yes",
            "xeno_mets",       "Xenograft Metastatic", "yes",
            "mm_prim",         "Mouse Primary",        "no",
            "mm_mets",         "Mouse Metastatic",     "no")

annotated <- list()
merged <- list()
just_tumor <- list()
just_stroma <- list()

for (item in seq_len(nrow(umaps_group))) {
    sobj_name <- umaps_group$sobj[item]
    combine <- umaps_group$combine[item]
    title <- umaps_group$title[item]
    if (combine == "no") {
        object <-
            qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                            sobj_name,
                            ".qs"))
        annotated[[sobj_name]] <- 
            plot_my_stuff(object,
                          what = c("new_annot_clust", "seurat_clusters")) +
                ggtitle("Annotated cell types by cluster")
        merged[[sobj_name]] <- 
            plot_my_stuff(object,
                          what = c("cell_group")) +
                ggtitle("Tumor and Stromal cells") + 
                NoLegend() +
                coord_fixed()

        #plot the tumor cells
        tumor <-
            qs::qread(str_c("output/seurat_objects/resolution_optimized/",
                            sobj_name,
                            "_cancer_cells.qs"))
        just_tumor[[sobj_name]] <- 
            plot_my_stuff(tumor,
                          what = c("seurat_clusters")) +
                ggtitle("Tumor cells reclustering")

        #plot the stromal cells
        stroma <- 
            qs::qread(str_c("output/seurat_objects/resolution_optimized/",
                            sobj_name,
                            "_normal_cells.qs"))
        just_stroma[[sobj_name]] <- 
            plot_my_stuff(stroma,
                          what = c("seurat_clusters")) +
                ggtitle("Stromal cells reclustering")
    } else {
        first_obj <- 
            qs::qread(str_c("output/seurat_objects/resolution_optimized/",
                            sobj_name,
                            "_human.qs"))
        just_tumor[[sobj_name]] <-
            plot_my_stuff(first_obj,
                          what = c("sample_name", "seurat_clusters", "new_annot_clust")) +
                ggtitle("Tumor cells")

        second_obj <- 
            qs::qread(str_c("output/seurat_objects/resolution_optimized/",
                            sobj_name,
                            "_mouse.qs"))
        just_stroma[[sobj_name]] <- 
            plot_my_stuff(second_obj,
                          what = c("sample_name", "seurat_clusters", "new_annot_clust")) +
                ggtitle("Stromal cells")
    }
}




object_list <- 
    c("patient_prim_cancer_cells",
    "patient_mets_cancer_cells",
    #"mm_prim_cancer_cells",
    #"mm_mets_cancer_cells",
    #"xeno_prim_human",
    #"xeno_mets_human",
    "patient_prim_normal_cells",
    "patient_mets_normal_cells")
    #"xeno_prim_mouse",
    #"xeno_mets_mouse",
    #"mm_prim_normal_cells",
    #"mm_mets_normal_cells")

for (group in object_list) {
    object <- 
        qs::qread(str_c("output/seurat_objects/resolution_optimized/",
                              group,
                              ".qs"))
    plot = plot_my_stuff(object,
                  what = c("new_annot_clust")) +
        NoLegend() +
        coord_fixed()
    ggsave(str_c("output/plots/umaps/", group, "_annot.png"),
            width = 7,
            height = 7,
            plot = plot)
}
    #rename idents'
    Idents(object) <- object$seurat_clusters
    object <- RenameIdents(object = object,
                           `0` = "MYC Driven",
                           `1` = "Proliferating",
                           `2` = "Angiogenic",
                           `3` = "Inflammatory/NFkB",
                           `4` = "Basal",
                           `5` = "Dying",
                           `6` = "Dying",
                           `7` = "Dying")
    #plot the UMAP
    DimPlot(object, 
            shuffle = T,
            label = T,
            cols = c(plot_cols, sample(rainbow(1000)))) +
        coord_fixed() +
        ggtitle("Renamed Idents") 
}



for (group in c("patient_prim", "patient_mets")) {
    object <-
            qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                            group,
                            ".qs"))
    
    plot <- plot_my_stuff(object,
                          what = c("cell_group")) +
                NoLegend()

    ggsave(str_c("output/plots/umaps/", group, "cell_group.png"),
            width = 7,
            height = 7,
            plot = plot)

}
```