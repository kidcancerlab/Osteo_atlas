## Cancer cells vs normal cells using SCEVAN
Single CEll Variational Aneuploidy aNalysis
When run, the result is in three metadata column:
class: with tumor (blue) vs normal celltype(green), and (filtered (red): low quality cells i think)
subclone: clones numbered like a seurat clusters
SCEVAN starts from the raw count matrix removing irrelevant genes and cells.
Identification of a small set of highly confident normal cells.
Relative gene expression obtained from removal of the baseline inferred from confident normal cells.
Edge-preserving nonlinear diffusion filtering of relative gene expression.
Segmentation with a variational region-growing algorithm.
Identification of normal cells as those in the cluster containing the majority of confident normal cells.
Segments are then classified in five copy number states.
Analysis of subclones including clone tree, pathway activities, but it can be turned off

```{r scevan}
#| cache.vars: orthologs
#| fig.width: 10
#| fig.height: 10
#| fig.align: center
#| echo: FALSE
#| dependson: [annot_celltypes, dog_human_orthologs_function, dog_human_gene]

min_cells <- 500

# load the tsv for human_dog gene orthologs
orthologs <-
    read_tsv("input/downloads/dog_human_gene_orthologs.txt")

# run the SCEVAN pipeline
for (group in c("patient_prim", "patient_mets",
                "mm_prim", "mm_mets",
                "dogs_prim", "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))
    organism <-
        object$organism[1]

    #use the function to convert dog to human genes and make new seurat object
    if (organism == "dog") {
        object <-
            dog_to_human_setup(object)
        organism <- "human"
    }

    # SCEVAN results listed into an output for each seurat object
    result_list <-
        parallel::mclapply(unique(object$sample_name),
                            mc.preschedule = FALSE,
                            mc.cores = 1,
                            function(x) {
            # If we have too few cells SCEVAN errors out
            # dim(x) must have a positive length

            count_matrix <-
                object %>%
                subset(sample_name == x) %>%
                GetAssayData(layer = "counts")

            if (ncol(count_matrix) > min_cells) {
                # output <-
                #     SCEVAN::pipelineCNA(count_mtx = count_mtx_list[[x]],
                #                         sample = x,
                #                         organism = organism,
                #                         par_cores = parallelly::availableCores(),
                #                         SUBCLONES = FALSE)

                output <-
                    tryCatch(
                        {
                            SCEVAN::pipelineCNA(count_mtx = count_matrix,
                                                sample = x,
                                                organism = organism,
                                                par_cores = parallelly::availableCores(),
                                                SUBCLONES = FALSE)
                        },
                        error = function(e) {
                            message("SCEVAN failed for ",group, " ", x, " with error: ", e)
                        })

                 # SCEVAN writes a bunch of files to ./output/ so we need to move them
                system(paste0("mv output/",
                            x,
                            "* output/id_tumor/SCEVAN/"))
                # Two of the files have spaces in their names :-|
                system(paste0("mv output/' ",
                              x,
                              " vega_output' output/id_tumor/SCEVAN/"))
                system(paste0("mv output/' ",
                            x,
                            "onlytumor vega_output' output/id_tumor/SCEVAN/"))

                return(output)
            }
        })

    directory <-
        "output/id_tumor/SCEVAN/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }

    bind_rows(result_list) %>%
        mutate(scevan_tumor_call = if_else(class == "tumor",
                                           "cancer_cells",
                                           "normal_cells")) %>%
        rownames_to_column("cell") %>%
        write_tsv(str_c("output/id_tumor/SCEVAN/",
                        group,
                        "_metadata.tsv"))
}


```

## Cancer cells vs normal cells using scATOMIC
The result comes with the annotation of cell types including for both cancer type
and the normal cell types. Also outputs for each cell:
Classification_confidence: confident, low_confidence on annotation
pan_cancer_cluster: either cancer or normal
scATOMIC_pred : celltype annotation
```{r scatomic}

#| fig.width: 10
#| fig.height: 10
#| fig.align: center
#| echo: FALSE
#| dependson: [annot_celltypes, scevan, dog_human_gene]


for (group in c(
                # "patient_prim", "patient_mets",
                # "dogs_prim", "dogs_mets",
                "mm_prim", "mm_mets"
                )) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))

    organism <-
        object$organism[1]

    #use the function to convert dog to human genes and make new seurat object
    if (organism == "dog") {
        object <-
            dog_to_human_setup(object)
        organism <- "human"
    }
    if (organism == "mouse") {
        object <-
            mouse_to_human_setup(object,
                                harm_vars = c("sample_name", "model"),
                                theta = c(12, 12))
        organism <- "human"
    }

    min_count_per_gene <- 10
    count_mtx_list <- object %>%
        SplitObject(split.by = "sample_name") %>%
        lapply(FUN = function(x) {
            temp_data <- GetAssayData(x, layer = "counts")
            temp_data <- temp_data[rowSums(temp_data) > min_count_per_gene, ]
        })

    result_list <-
        parallel::mclapply(names(count_mtx_list),
                           mc.cores = parallelly::availableCores(),
                           mc.preschedule = FALSE,
                           function(x) {
            cell_predictions <-
                scATOMIC::run_scATOMIC(
                    rna_counts = count_mtx_list[[x]],
                    mc.cores = parallelly::availableCores()
                )
            scATOMIC_results <-
                tryCatch(
                    {
                        scATOMIC::create_summary_matrix(
                            prediction_list = cell_predictions,
                            use_CNVs = T,
                            modify_results = T,
                            mc.cores = parallelly::availableCores(),
                            raw_counts = count_mtx_list[[x]],
                            min_prop = 0.5
                        ) %>%
                        select(starts_with("layer_"),
                               any_of(c("scATOMIC_pred",
                                      "classification_confidence",
                                      "CNV_status",
                                      "pan_cancer_cluster")))
                },
                error = function(e) {
                    message("scATOMIC failed for ",group, " ", x, " with error: ", e)
                    scATOMIC::create_summary_matrix(
                        prediction_list = cell_predictions,
                        modify_results = T,
                        mc.cores = parallelly::availableCores(),
                        raw_counts = count_mtx_list[[x]],
                        min_prop = 0.5
                    ) %>%
                    select(starts_with("layer_"),
                               any_of(c("scATOMIC_pred",
                                      "classification_confidence",
                                      "CNV_status")))
                })

            return(scATOMIC_results)
        })

    directory <-
        "output/id_tumor/scATOMIC/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }

    dplyr::bind_rows(result_list) %>%
    mutate(scatomic_tumor_call = if_else(grepl("Cancer Cell$", scATOMIC_pred),
                                         "cancer_cells",
                                         "normal_cells")) %>%
    rownames_to_column("cell") %>%
    write_tsv(str_c("output/id_tumor/scATOMIC/",
                    group,
                    "_metadata.tsv"))
}


```

## plotting the results of scATOMIC
```{r scatomic_scevan_plots}
#| fig.width: 10
#| fig.height: 10
#| fig.align: center
#| echo: FALSE
#| dependson: scatomic
for (group in c(
                # "patient_prim", "patient_mets",
                # "dogs_prim", "dogs_mets",
                "mm_prim", "mm_mets"
                )) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))

    #add scatomic label
    scatomic_label <-
        readr::read_tsv(str_c("output/id_tumor/scATOMIC/",
                            group,
                            "_metadata.tsv")) %>%
        column_to_rownames("cell")
    object <- object %>%
            AddMetaData(metadata = scatomic_label)

    #loop over individual  samples to plot and save
    for (samples in unique(object$sample_name)) {
        sub_sobj <- subset(object, sample_name == samples) %>%
                        process_seurat()

        #make a plot
        scatomic1 <- dimplot_better(sub_sobj,
                                   group_by = "scATOMIC_pred") +
                        NoLegend()

        # check if CNV_status is present and if all of them are NA, cannot plot
        if (all(!is.na(sub_sobj$CNV_status))) {
            scatomic2 <- dimplot_better(sub_sobj,
                                        group_by = "CNV_status") +
                            NoLegend()
        } else {
            scatomic2 <- ggplot(data = NULL) +
                            aes(x = as.factor(1), y = as.factor(1)) +
                            geom_text(aes(label = str_c("CNV_status not present for ", samples)))
        }
        scatomic3 <- dimplot_better(sub_sobj,
                                   group_by = "scatomic_tumor_call") +
                        NoLegend()

        scatomic4 <- dimplot_better(sub_sobj,
                                   group_by = "new_annot_clust") +
                        NoLegend()

        # patchwork the plot for scatomic
        dimplot_sub_sobj <-
            patchwork::wrap_plots(scatomic1,
                                scatomic2,
                                scatomic3,
                                scatomic4,
                                ncol = 2) +
                patchwork::plot_annotation(title = samples)

        directory <-
            str_c("output/figures/scatomic/", group)
        if (!dir.exists(directory)) {
            dir.create(directory, recursive = TRUE)
        }
        # save the plot for scatomic
        ggsave(str_c("output/figures/scatomic/",
                        group, "/",
                        samples,
                        "_dimplot.png"),
                plot = dimplot_sub_sobj,
                width = 14,
                height = 14)
    }
}

# scevan was done in mice as well so have to loop over all of the groups
for (group in c("patient_prim", "patient_mets",
                "mm_prim", "mm_mets",
                "dogs_prim", "dogs_mets")) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                              group,
                              ".qs"))

    #add scevan label
    scevan_label <-
        readr::read_tsv(str_c("output/id_tumor/SCEVAN/",
                            group,
                            "_metadata.tsv")) %>%
        column_to_rownames("cell")
    object <-
        object %>%
        AddMetaData(metadata = scevan_label)

    #loop over individual  samples to plot and save
    for (samples in unique(object$sample_name)) {
        sub_sobj <-
            subset(object, sample_name == samples) %>%
            process_seurat()

        # check if CNV_status is present and if all of them are NA, cannot plot
        if (all(!is.na(sub_sobj$scevan_tumor_call))) {
            scevan1 <-
                dimplot_better(sub_sobj,
                                group_by = "scevan_tumor_call") +
                    NoLegend()
        } else {
            scevan1 <-
                ggplot(data = NULL) +
                    aes(x = as.factor(1), y = as.factor(1)) +
                    geom_text(aes(label = str_c("scevan_tumor_call not present for ", samples)))
        }

        scevan2 <-
            dimplot_better(sub_sobj,
                            group_by = "new_annot_clust") +
                NoLegend()

        # patchwork the plot for scatomic
        dimplot_sub_sobj <-
            patchwork::wrap_plots(scevan1,
                                scevan2,
                                ncol = 2) +
                patchwork::plot_annotation(title = samples)

        directory <-
            str_c("output/figures/scevan/", group)
        if (!dir.exists(directory)) {
            dir.create(directory, recursive = TRUE)
        }
        # save the plot for scatomic
        ggsave(str_c("output/figures/scevan/",
                        group, "/",
                        samples,
                        "_dimplot.png"),
                plot = dimplot_sub_sobj,
                width = 14,
                height = 7)
    }
}
```

## create the snv calling metadata and save it
```{r snv_calling}
# path to snv result metadata in Matts repo
snv_result_path <-
    "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/id_tumor/snvs/"
    #"/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/id_tumor/snvs/"

snv_depth <-
    read_tsv("misc/use_snv_tumor_calls.txt")

for (group in c("patient_prim", "patient_mets",
                "mm_prim", "mm_mets",
                "dogs_prim", "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))

    organism <-
        object$organism[1]

    #make a list of the samples
    metadata_list <- list()

    # read in the cmetadata
    for (samples in unique(object$sample_name)) {
        sobj <- subset(object, sample_name == samples)

        tsv_file <- str_c(snv_result_path,
                          organism, "_",
                          samples,
                          "_snv_calls.tsv")

        if (file.exists(tsv_file)) {
            pick_depth <-
                snv_depth %>%
                filter(sample_name == samples) %>%
                pull(use_snv_column)

            tumor_label <-
                snv_depth %>%
                filter(sample_name == samples) %>%
                pull(tumor_groups) %>%
                str_split(",") %>%
                unlist()

            if (!is.na(pick_depth)) {
                snv_metadata <-
                    readr::read_tsv(tsv_file) %>%
                    select(cell, all_of(pick_depth))
                snv_metadata$final_snv_call <-
                    ifelse(snv_metadata[[pick_depth]] %in% tumor_label,
                            "cancer_cells",
                            "normal_cells")
                snv_metadata <-
                    snv_metadata %>%
                    mutate(cell = paste(samples, cell, sep = "_")) %>%
                    # column_to_rownames(var = "cell") %>%
                    select(cell, final_snv_call) %>%
                    mutate(final_snv_call = tidyr::replace_na(final_snv_call, replace = "unknown"))
            } else {
                snv_metadata <-
                    sobj@meta.data %>%
                    rownames_to_column("cell") %>%
                    select(cell) %>%
                    mutate(final_snv_call = "unknown")
            }
        } else {
            snv_metadata <-
                sobj@meta.data %>%
                rownames_to_column("cell") %>%
                select(cell) %>%
                mutate(final_snv_call = "unknown")
        }
        metadata_list[[samples]] <- snv_metadata
    }
    directory <-
        "output/id_tumor/snv_calling/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }
    dplyr::bind_rows(metadata_list) %>%
        write_tsv(str_c("output/id_tumor/snv_calling/",
                        group,
                        "_metadata.tsv"))
}
```


## test that the PDX and cell culture tumor cell can be used to annotate the tumor
will use the reference we used to annoate the tumor cells in human, mice, and dog data
to annotate a curated dataset where we know what cells are tumor and what are not
the mouse These samples were injected with barcoded F420 cells. I'll be getting the barcode information from the bams and writing it off as a metadata table.
Barcoded samples that aren't PDXs:
    S0260
    S0261

For human part # reference has "S0170", "S0042" for xenograft hence we will use
"SJOS013769_X1_human", "X00018_human",
"S0034_human",          "X00020_human"


random samples for xeno primary validation: 1) S0042 2)SJOS016015_X1
 random samples for xeno mets validation: 1) S0055  2)SJOS001112_X1


```{r test_tumor_anno_with_curated_data}

# make mouse object for validation
### S0260 and S0261
bc_calling <- list()
for (ob in c("S0260", "S0261")) {
    if (file.exists(paste0("output/metadata/barcode_", ob, ".tsv"))) {
        bc_calling[[ob]] <- read.table(
            paste0("output/metadata/barcode_", ob, ".tsv"),
            header = TRUE
        )
    } else {
        bc_calling[[ob]] <- gen_cellecta_bc_data(
            file = paste0(
                "/home/gdrobertslab/lab/Counts_2/",
                ob,
                "/possorted_genome_bam.bam"
                    ),
            verbose = TRUE,
            output = paste0("output/metadata/barcode_", ob, ".tsv"),
            samtools_module = "GCC/9.3.0 SAMtools/1.15"
        )
    }
}

ob_list <- list()
for (ob in c("S0260", "S0261")) {
    ob_list[[ob]] <- tenx_load_qc(
        paste0(
            "/home/gdrobertslab/lab/Counts_2/",
            ob,
            "/filtered_feature_bc_matrix"
        ),
        violin_plot = FALSE
    )
    ob_list[[ob]]$sample_id <- ob
}

qc_plts <- lapply(ob_list, feature_hist, features = c("nCount_RNA", "percent.mt"))
grid.arrange(grobs = qc_plts)

ob_list <- lapply(ob_list, function(x) {
    subset(
        x,
        nCount_RNA %in% c(1000:60000) &
        percent.mt < 10
    ) %>%
    process_seurat()
})

# add barcode info to objects and
for (ob in names(ob_list)) {
    ob_list[[ob]]$barcoded <-
        colnames(ob_list[[ob]]) %in% paste0(bc_calling[[ob]]$cid, "-1")
}

# merge
mouse_sobj <- 
    merge(ob_list[[1]], ob_list[[2]]) %>%
    JoinLayers() %>%
    process_seurat()
mouse_sobj$organism <- "mouse"
mouse_sobj$sample_name <- mouse_sobj$sample_id

dimplot_better(mouse_sobj,
            group_by = "barcoded")
FeaturePlot(mouse_sobj,
            features = c("Runx2", "Satb2", "Col1a1", "Col1a2"))

# Identify the cluster(s) with the most barcoded=="tumor" cells
cluster_counts <- 
    table(mouse_sobj$seurat_clusters, mouse_sobj$barcoded)
# Find cluster(s) where most cells are barcoded (TRUE)
tumor_clusters <- 
    names(which(cluster_counts[, "TRUE"] == max(cluster_counts[, "TRUE"])))
# Assign "tumor" to cells in those clusters, "stroma" otherwise
mouse_sobj$truth_metadata <-

    ifelse(mouse_sobj$seurat_clusters %in% tumor_clusters, "tumor", "stroma")

dimplot_better(mouse_sobj, group_by= "truth_metadata")
# save the individual object
S0260 <- 
    mouse_sobj %>%
    subset(sample_name == "S0260") %>%
    process_seurat()
if (!dir.exists("output/seurat_objects/validation/tumor_annotation/")) {
    dir.create("output/seurat_objects/validation/tumor_annotation/", recursive = TRUE)
}
qs::qsave(S0260,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "S0260_mouse.qs"))
S0261 <-
    mouse_sobj %>%
    subset(sample_name == "S0261") %>%
    process_seurat()
qs::qsave(S0261,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "S0261_mouse.qs"))



## prepare the human healthy lung stroma to be merged 
lungblood_obj <-
    qs::qread("input/downloads/human_lung.qs")
dimplot_better(lungblood_obj,
            group_by = "free_annotation") +
    NoLegend() + ggtitle("lungblood object")

# make first stroma for human lung
stroma1 <-
    subset(lungblood_obj,
            cells = sample(colnames(lungblood_obj), 10000)) %>%
    process_seurat()
stroma1$sample_name <- "lungblood_stroma1"
qs::qsave(stroma1,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "human_lung_stroma1.qs"))
# make second stroma for human lung
stroma2 <-
    subset(lungblood_obj,
           cells = sample(setdiff(colnames(lungblood_obj), colnames(stroma1)), 10000)) %>%
    process_seurat()
stroma2$sample_name <- "lungblood_stroma2" 
qs::qsave(stroma2,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "human_lung_stroma2.qs"))

# combination of samples for human tumor annotation and reference validation

samples <- c(
    "SJOS016015_X1_human",  # xeno primary tumor cell with femur head
    "S0042_human",          # xeno primary tumor cell with femur head
    "S0055_human",          # xeno mets tumor cell
    "SJOS001112_X1_human",   # xeno mets tumor cell
    "X00018_human",
    "X00020_human"
)
# save into the one location for all the validation object
for (tumor_name in samples) {
    dir <- str_c("output/seurat_objects/sobj_preprocess")
    tumor <-
        qs::qread(str_c(dir, "/", tumor_name, ".qs"))
    tumor$truth_metadata <- "tumor"
    #dimplot_better(tumor, group_by = "truth_metadata")
    qs::qsave(tumor,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                tumor_name, ".qs"))
}

# the combination
samples_to_combine <- 
    tribble(~tumor_name,                ~stroma_name,
            "SJOS016015_X1_human",    "X00018_human",   #xeno primary tumor cell with femur head
            "S0042_human",            "X00020_human",   #xeno primary tumor cell with femur head
            "S0055_human",            "human_lung_stroma1",  # xeno mets tumor cell with human lung stroma
            "SJOS001112_X1_human",    "human_lung_stroma2") # xeno mets tumor cell with human lung stroma

# combine and prepare the stroma and tumor for validation
for (i in seq_len(nrow(samples_to_combine))) {
    stroma_name <- samples_to_combine$stroma_name[i]
    tumor_name <- samples_to_combine$tumor_name[i]
    stromal_metadata <- list()
    tumor_metadata <- list()

    dir <- str_c("output/seurat_objects/validation/tumor_annotation/")
    tumor <-
        qs::qread(str_c(dir, "/", tumor_name, ".qs"))
    tumor$truth_metadata <- "tumor"

    # check if the object already exists
    stroma <-
        qs::qread(str_c(dir, "/", stroma_name, ".qs"))
    stroma$truth_metadata <- "stroma"

    combine_sobject <-
        merge(stroma, tumor,
              add.cell.ids = c("stroma", "tumor")) %>%
        JoinLayers() %>%
        process_seurat()

    if (!dir.exists("output/seurat_objects/validation/tumor_annotation/")) {
        dir.create("output/seurat_objects/validation/tumor_annotation/", recursive = TRUE)
    }
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                tumor_name, "_", stroma_name,
                "_combined.qs"))

}

# actual validation parent
samples_for_validation <- 
    tribble(~names,                                           ~species,
            "S0260_mouse",                                    "mouse",
            "S0261_mouse",                                     "mouse",
            "S0042_human_X00020_human_combined",               "human",
            "SJOS016015_X1_human_X00018_human_combined",       "human",
            "SJOS001112_X1_human_human_lung_stroma2_combined", "human_lung",
            "S0055_human_human_lung_stroma1_combined",          "human_lung"
      )

for (item in seq_len(nrow(samples_for_validation))) {
    names <- samples_for_validation$names[item]
    species <- samples_for_validation$species[item]
    combine_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        names, ".qs"))
    dimplot1 <-
        dimplot_better(combine_sobject,
                    group_by = "truth_metadata") +
        NoLegend() + ggtitle("object with known tumor and stroma")
    # Annotation
    #use tumor before subsetting tumor
    big_obj_with_tumor <-
        annotate_celltypes(sobject = combine_sobject,
                            species = species,
                            with_tumor = TRUE,
                            aggr_ref = TRUE)

    # this is my method
    ann_obj <-
        annotate_celltypes(sobject = combine_sobject,
                            species = species,
                            with_tumor = FALSE,
                            aggr_ref = TRUE)

    ann_obj <-
        clusterbased_annot(s_obj = ann_obj)
 
    ann_obj$just_stroma_annot <- ann_obj$new_annot_clust
    dimplot2 <-
        dimplot_better(ann_obj,
                    group_by = "just_stroma_annot") +
        NoLegend() + ggtitle("Annotation with stroma referece")

    # identify the potential tumor cells using the aucell with osteosarcoma markers
    osteosarcoma_markers <- c("RUNX2", "COL1A1", "COL1A2", "SATB2")
    potential_tumor_cells_list <- list()
    genelist <- osteosarcoma_markers
    if (species == "mouse") {
        genelist <-
            nichenetr::convert_human_to_mouse_symbols(genelist) %>%
            na.omit() %>%
            unique()
    }
    # prepare the matrix
    entire_matrix <-
        ann_obj@assays$RNA$counts

    # run AUcell
    genelist_present <- 
        genelist[genelist %in% rownames(entire_matrix)]

    cell_ranks <-
        AUCell::AUCell_run(exprMat = entire_matrix,
                           geneSets = genelist)

    ann_obj$AUC_OsteoMarkers <- AUCell::getAUC(cell_ranks)[1,]

    bulk_score_per_cluster <-
        ann_obj@meta.data %>%
        dplyr::select(AUC_OsteoMarkers, just_stroma_annot) %>%
        dplyr::group_by(just_stroma_annot) %>%
        dplyr::summarise(median = median(AUC_OsteoMarkers, na.rm = TRUE)) %>%
        dplyr::arrange(desc(median))
    tumor_cells <-
        bulk_score_per_cluster %>%
        dplyr::filter(median > 0.3) %>%
        dplyr::pull(just_stroma_annot)

    stroma_cells <-
        bulk_score_per_cluster %>%
        dplyr::filter(median <= 0.3) %>%
        dplyr::pull(just_stroma_annot)
    # subset the object
    stroma_cells_sobj <-
        subset(ann_obj,
                just_stroma_annot %in% stroma_cells)
    tumor_cells_sobj <-
        subset(ann_obj,
                just_stroma_annot %in% tumor_cells) %>%
        process_seurat(resolution = 0.1)

    dimplot3 <-
        dimplot_better(tumor_cells_sobj,
                    group_by = "just_stroma_annot") +
        NoLegend() + ggtitle("Potential tumor cells")

    dimplot4 <-
        dimplot_better(tumor_cells_sobj,
                    group_by = "seurat_clusters") +
        NoLegend() + ggtitle("Potential tumor cells")

    Idents(tumor_cells_sobj) <- tumor_cells_sobj$seurat_clusters
    stromal_metadata <- list()
    tumor_metadata <- list()
    for (clusters in unique(tumor_cells_sobj$seurat_clusters)) {
        sub_obj <-
            subset(tumor_cells_sobj,
                   seurat_clusters == clusters) %>%
            process_seurat(resolution = 0.1)
        sub_obj <-
            annotate_celltypes(sobject = sub_obj,
                                species = species,
                                with_tumor = TRUE,
                                aggr_ref = TRUE)
        sub_obj <-
            clusterbased_annot(s_obj = sub_obj)

        sub_obj$annot_with_tumor <- sub_obj$annotations

    # save the ids
        normal_ids <-
            sub_obj@meta.data %>%
            filter(annot_with_tumor != "Tumor_cells") %>%
            rownames_to_column("cell_ids") %>%
            select(cell_ids)

        tumor_ids <-
            sub_obj@meta.data %>%
            filter(annot_with_tumor == "Tumor_cells") %>%
            rownames_to_column("cell_ids") %>%
            select(cell_ids)

        # save the metadata
        if (length(normal_ids$cell_ids) > 0) {
            stromal_metadata[[clusters]] <- normal_ids
        }
        if (length(tumor_ids$cell_ids) > 0) {
            tumor_metadata[[clusters]] <- tumor_ids
        }
    }
    # save the metadata
    stromal_cells_id <- bind_rows(stromal_metadata)
    tumor_cells_id <- bind_rows(tumor_metadata)

    combine_sobject$final_tumor_call <-
        ifelse(colnames(combine_sobject) %in% tumor_cells_id$cell_ids,
                "tumor",
                "stroma")
    dimplot5 <-
        DimPlot(combine_sobject,
            group.by = "final_tumor_call",
            label = T,
            cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
            label.box = T) +
        NoLegend() +
        theme_void() +
        ggtitle("Final tumor call")
    dimplot6 <-
        DimPlot(combine_sobject,
                group.by = "truth_metadata",
                label = T,
                cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
                label.box = T) +
        NoLegend() +
        theme_void() +
        ggtitle("truth metadata")

    big_obj_with_tumor$annot_with_tumor_as_whole <-
        ifelse(big_obj_with_tumor$annotations == "Tumor_cells",
                "tumor",
                "stroma")

    # add metadata of the big_obj_with_tumor column annot_with_tumor_as_whole to combine_sobject
    combine_sobject$annot_with_tumor_as_whole <-
        big_obj_with_tumor$annot_with_tumor_as_whole[
            match(colnames(combine_sobject),
                colnames(big_obj_with_tumor))]

    dimplot7 <-
        DimPlot(combine_sobject,
                group.by = "annot_with_tumor_as_whole",
                label = T,
                cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
                label.box = T) +
        NoLegend() +
        ggtitle("annotation with tumor in whole object")

    # patchwork the plots
    dimplot_combined <-
        patchwork::wrap_plots(dimplot5,
                            dimplot6,
                            dimplot7,
                            ncol = 2) +
            patchwork::plot_annotation(title = names)
    directory <-
        str_c("output/figures/validation/tumor_annotation_method/", names)

    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }
    ggsave(str_c(directory, "/",
                names, "_dimplot.png"),
            plot = dimplot_combined,
            width = 14,
            height = 14)
    # save the combined object
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                names, "_validated.qs"))
}

samples_for_validation <- 
    tribble(~names,                                           ~species,
            "S0260_mouse",                                    "mouse",
            "S0261_mouse",                                     "mouse",
            "S0042_human_X00020_human_combined",               "human",
            "SJOS016015_X1_human_X00018_human_combined",       "human",
            "SJOS001112_X1_human_human_lung_stroma2_combined", "human",
            "S0055_human_human_lung_stroma1_combined",          "human"
      )
for (item in seq_len(nrow(samples_for_validation))) {
    group <- samples_for_validation$names[item]
    organism <- samples_for_validation$species[item]
    object <- 
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        group, 
                        "_validated.qs"))
    # SCEVAN results listed into an output for each seurat object
    #count matrix
    count_matrix <- 
        object %>%
        GetAssayData(layer = "counts")
    output <- 
        SCEVAN::pipelineCNA(count_mtx = count_matrix,
                            sample = group,
                            organism = organism,
                            par_cores = parallelly::availableCores(),
                            SUBCLONES = FALSE)
    # SCEVAN writes a bunch of files to ./output/ so we need to move them
    system(paste0("mv output/",
                group,
                "* output/id_tumor/SCEVAN/"))
    # Two of the files have spaces in their names :-|
    system(paste0("mv output/' ",
                    group,
                    " vega_output' output/id_tumor/SCEVAN/"))
    system(paste0("mv output/' ",
                group,
                "onlytumor vega_output' output/id_tumor/SCEVAN/"))
    object <-
        AddMetaData(object,
                    metadata = output)
    object$scevan_tumor_call <-
        ifelse(object$class == "tumor",
                "cancer_cells",
                "normal_cells")

    mouse_obj <- object
    # for scatomic, convert mouse to human
     if (organism == "mouse") {
        raw_counts <-
            GetAssayData(object,
                        slot = "counts")
        human_genes <-
            object %>%
            rownames() %>%
            nichenetr::convert_mouse_to_human_symbols() %>%
            as.character()
        new_raw_counts <-
            raw_counts

        rownames(new_raw_counts) <- human_genes

        new_raw_counts <-
            new_raw_counts[!is.na(rownames(new_raw_counts)), ]

        new_raw_counts <-
            new_raw_counts[!duplicated(rownames(new_raw_counts)), ]

        new_seurat_object <-
            CreateSeuratObject(counts = new_raw_counts) %>%
            AddMetaData(metadata = object@meta.data)

        object <-
            new_seurat_object %>%
            process_seurat()
    }
    
    # run scATOMIC
    min_count_per_gene <- 10
    count_matrix <- 
        object %>%
        GetAssayData(layer = "counts")
    count_matrix <- 
        count_matrix[rowSums(count_matrix) > min_count_per_gene, ]
    cell_predictions <-
        scATOMIC::run_scATOMIC(rna_counts = count_matrix)

    scATOMIC_results <-
        scATOMIC::create_summary_matrix(prediction_list = cell_predictions,
                                        use_CNVs = T,
                                        modify_results = T,
                                        mc.cores = parallelly::availableCores(),
                                        raw_counts = count_matrix,
                                        min_prop = 0.5) %>%
        select(starts_with("layer_"),
                any_of(c("scATOMIC_pred",
                        "classification_confidence",
                        "CNV_status")))
    # save the scATOMIC results
    
    if (organism == "mouse") {
        mouse_obj <-
            AddMetaData(mouse_obj,
                        metadata = scATOMIC_results)
        qs::qsave(mouse_obj,
                str_c("output/seurat_objects/validation/tumor_annotation/",
                    group, "_alldone.qs"))
    } else {
        object <-
            AddMetaData(object,
                        metadata = scATOMIC_results)
        qs::qsave(object,
                str_c("output/seurat_objects/validation/tumor_annotation/",
                    group, "_alldone.qs"))
    }
}



# make the plots for the validation
samples_for_validation <- 
    c("S0260_mouse",
      "S0261_mouse",
      "S0042_human_X00020_human_combined",
      "SJOS016015_X1_human_X00018_human_combined",
      "SJOS001112_X1_human_human_lung_stroma2_combined",
      "S0055_human_human_lung_stroma1_combined")


for (group in samples_for_validation) {
    combine_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        group, "_alldone.qs"))
    combine_sobject$scatomic_tumor_call <-
        ifelse(grepl("Cancer Cell$", combine_sobject$scATOMIC_pred),
                "tumor",
                "stroma")
    combine_sobject$scevan_tumor_call <-
        ifelse(combine_sobject$scevan_tumor_call == "cancer_cells",
                "tumor",
                "stroma")
    #dimplot_better(combine_sobject, group_by = "scATOMIC_pred")
    # give me some kind of metric to see how well do the two annotations match
    metadata <-
        combine_sobject@meta.data %>%
        select(annot_with_tumor_as_whole, final_tumor_call,
                truth_metadata, scevan_tumor_call, scatomic_tumor_call) %>%
        rownames_to_column("cell_id") %>%
        arrange(truth_metadata,
                final_tumor_call,
                annot_with_tumor_as_whole,
                scevan_tumor_call,
                scatomic_tumor_call) %>%
        mutate(cell_id_number = row_number()) %>%
        rename(Truth = truth_metadata,
                FinalCall = final_tumor_call,
                CallAsWhole = annot_with_tumor_as_whole,
                SCEVAN = scevan_tumor_call,
                scATOMIC = scatomic_tumor_call)

    # make tile plot of the metadata
    prepared_metadata <-
        metadata %>%
        pivot_longer(cols = -c(cell_id, cell_id_number),
                names_to = "method",
                values_to = "call")
        # Set factor levels for method and call to control order in plot
    prepared_metadata$method <-
        factor(prepared_metadata$method,
                levels = c("Truth", "FinalCall", "CallAsWhole", "SCEVAN", "scATOMIC"))
    prepared_metadata$call <-
        factor(prepared_metadata$call,
              levels = c("tumor", "stroma"))
    tile_plot <-
        ggplot(prepared_metadata, aes(x = method, y = cell_id_number, fill = call)) +
            geom_tile() +
            scale_fill_manual(values = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF")) +
            theme_minimal() +
            labs(title = "Tumor annotation comparison",
                 x = "Annotation Method",
                 y = "Cell Index") +
            theme(
                axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid = element_blank(),
                plot.margin = margin(0, 0, 0, 0), # Remove extra space around plot
                plot.background = element_rect(fill = NA, color = NA),
                panel.spacing = unit(0, "pt"),
                panel.border = element_blank()
            ) +
            scale_y_reverse(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0)) +
            geom_vline(xintercept = seq(1.5, length(unique(prepared_metadata$method)) - 0.5, by = 1),
                   color = "black", linetype = "dotted", size = 0.2) +
            coord_cartesian(clip = "on")

    # Confusion matrices and accuracy
    # Confusion matrices and accuracy for FinalCall, CallAsWhole, SCEVAN, scATOMIC
    confusion_matrix_final <- table(metadata$Truth, metadata$FinalCall)
    confusion_matrix_whole <- table(metadata$Truth, metadata$CallAsWhole)
    confusion_matrix_scevan <- table(metadata$Truth, metadata$SCEVAN)
    confusion_matrix_scatomic <- table(metadata$Truth, metadata$scATOMIC)

    accuracy_final <- sum(diag(confusion_matrix_final)) / sum(confusion_matrix_final)
    accuracy_whole <- sum(diag(confusion_matrix_whole)) / sum(confusion_matrix_whole)
    accuracy_scevan <- sum(diag(confusion_matrix_scevan)) / sum(confusion_matrix_scevan)
    accuracy_scatomic <- sum(diag(confusion_matrix_scatomic)) / sum(confusion_matrix_scatomic)

    # Accuracy barplot
    accuracy_df <- data.frame(
        Method = factor(c("Truth", "FinalCall", "CallAsWhole", "SCEVAN", "scATOMIC"),
                        levels = c("Truth", "FinalCall", "CallAsWhole", "SCEVAN", "scATOMIC")),
        Accuracy = c(1, accuracy_final, accuracy_whole, accuracy_scevan, accuracy_scatomic)
    )
    accuracy_barplot <-
        ggplot(accuracy_df, aes(x = Method, y = Accuracy, fill = Method)) +
            geom_bar(stat = "identity", width = 0.7, show.legend = FALSE) +
            geom_text(aes(label = round(Accuracy, 3), y = Accuracy/2), color = "white", size = 4) +
            labs(title = "Accuracy of Tumor Calls", x = "Methods", y = "Accuracy") +
            theme_minimal() +
            theme(axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
                  axis.text.y = element_text(face = "bold"),
                  panel.grid = element_blank(),
                  panel.border = element_blank()) +
            scale_fill_manual(values = c("Truth" = "#A0522D", "FinalCall" = "#D43F3AFF", "CallAsWhole" = "#0072B2FF", "SCEVAN" = "#377EB8", "scATOMIC" = "#4DAF4A")) +
            ylim(0, 1.05) +
            scale_y_continuous(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0))

    # Confusion matrix plots
    confusion_list <- list(
        FinalCall = list(tbl = confusion_matrix_final, acc = accuracy_final),
        CallAsWhole = list(tbl = confusion_matrix_whole, acc = accuracy_whole),
        SCEVAN = list(tbl = confusion_matrix_scevan, acc = accuracy_scevan),
        scATOMIC = list(tbl = confusion_matrix_scatomic, acc = accuracy_scatomic)
    )
    confusion_plots <-
        lapply(names(confusion_list), function(method) {
            tbl <- confusion_list[[method]]$tbl
            acc <- confusion_list[[method]]$acc
            df_tbl <- as.data.frame(as.table(tbl))
            colnames(df_tbl) <- c("Truth", "Prediction", "Freq")
            ggplot(df_tbl, aes(x = Prediction, y = Truth, fill = Freq)) +
                geom_tile(color = "white") +
                geom_text(aes(label = Freq), size = 2.5) +
                scale_fill_gradient(low = "#F0F0F0", high = "#D43F3AFF") +
                theme_minimal() +
                labs(title = paste0("Confusion Matrix: ", method,
                                   "\nAccuracy: ", round(acc, 3)),
                     x = "Predicted", y = "Truth") +
                theme(panel.grid = element_blank(),
                      plot.title = element_text(hjust = 0.5, size = 6, face = "bold"),
                      legend.position = "none",
                      axis.title.y = element_text(angle = 90),
                      axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 0.5))
        })
    confusion_combined <-
        patchwork::wrap_plots(confusion_plots, nrow = 1)

    # save the plot_grid
    all_plot <-
        cowplot::plot_grid(tile_plot,
                            accuracy_barplot,
                            confusion_combined,
                            ncol = 1,
                            rel_heights = c(1, 0.5, 0.4),
                            align = "v") +
            patchwork::plot_annotation(title = str_c(group, " Tumor ID by methods")) &
            theme(plot.title = element_text(size = 10))

    # save the confusion matrix plot
    if (!dir.exists("output/figures/validation/tumor_annotation_method/")) {
        dir.create("output/figures/validation/tumor_annotation_method/", recursive = TRUE)
    }
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                group, "_tumor_annotation_method.png"),
            plot = all_plot,
            width = 5,
            height = 10)
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                group, "_tumor_annotation_method.pdf"),
            plot = all_plot,
            width = 5,
            height = 10)

    if (!dir.exists("output/seurat_objects/validation/tumor_annotation/")) {
        dir.create("output/seurat_objects/validation/tumor_annotation/", recursive = TRUE)
    }
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/anno_",
                group))
}

```