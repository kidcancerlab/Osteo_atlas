## Cancer cells vs normal cells using SCEVAN
Single CEll Variational Aneuploidy aNalysis
When run, the result is in three metadata column:
class: with tumor (blue) vs normal celltype(green), and (filtered (red): low quality cells i think)
subclone: clones numbered like a seurat clusters
SCEVAN starts from the raw count matrix removing irrelevant genes and cells.
Identification of a small set of highly confident normal cells.
Relative gene expression obtained from removal of the baseline inferred from confident normal cells.
Edge-preserving nonlinear diffusion filtering of relative gene expression.
Segmentation with a variational region-growing algorithm.
Identification of normal cells as those in the cluster containing the majority of confident normal cells.
Segments are then classified in five copy number states.
Analysis of subclones including clone tree, pathway activities, but it can be turned off

```{r scevan}
#| cache.vars: orthologs
#| fig.width: 10
#| fig.height: 10
#| fig.align: center
#| echo: FALSE
#| dependson: [annot_celltypes, dog_human_orthologs_function, dog_human_gene]

min_cells <- 500

# load the tsv for human_dog gene orthologs
orthologs <-
    read_tsv("input/downloads/dog_human_gene_orthologs.txt")

# run the SCEVAN pipeline
for (group in c("patient_prim", "patient_mets",
                "mm_prim", "mm_mets",
                "dogs_prim", "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))
    organism <-
        object$organism[1]

    #use the function to convert dog to human genes and make new seurat object
    if (organism == "dog") {
        object <-
            dog_to_human_setup(object)
        organism <- "human"
    }

    # SCEVAN results listed into an output for each seurat object
    result_list <-
        parallel::mclapply(unique(object$sample_name),
                            mc.preschedule = FALSE,
                            mc.cores = 1,
                            function(x) {
            # If we have too few cells SCEVAN errors out
            # dim(x) must have a positive length

            count_matrix <-
                object %>%
                subset(sample_name == x) %>%
                GetAssayData(layer = "counts")

            if (ncol(count_matrix) > min_cells) {
                # output <-
                #     SCEVAN::pipelineCNA(count_mtx = count_mtx_list[[x]],
                #                         sample = x,
                #                         organism = organism,
                #                         par_cores = parallelly::availableCores(),
                #                         SUBCLONES = FALSE)

                output <-
                    tryCatch(
                        {
                            SCEVAN::pipelineCNA(count_mtx = count_matrix,
                                                sample = x,
                                                organism = organism,
                                                par_cores = parallelly::availableCores(),
                                                SUBCLONES = FALSE)
                        },
                        error = function(e) {
                            message("SCEVAN failed for ",group, " ", x, " with error: ", e)
                        })

                 # SCEVAN writes a bunch of files to ./output/ so we need to move them
                system(paste0("mv output/",
                            x,
                            "* output/id_tumor/SCEVAN/"))
                # Two of the files have spaces in their names :-|
                system(paste0("mv output/' ",
                              x,
                              " vega_output' output/id_tumor/SCEVAN/"))
                system(paste0("mv output/' ",
                            x,
                            "onlytumor vega_output' output/id_tumor/SCEVAN/"))

                return(output)
            }
        })

    directory <-
        "output/id_tumor/SCEVAN/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }

    bind_rows(result_list) %>%
        mutate(scevan_tumor_call = if_else(class == "tumor",
                                           "cancer_cells",
                                           "normal_cells")) %>%
        rownames_to_column("cell") %>%
        write_tsv(str_c("output/id_tumor/SCEVAN/",
                        group,
                        "_metadata.tsv"))
}


```

## Cancer cells vs normal cells using scATOMIC
The result comes with the annotation of cell types including for both cancer type
and the normal cell types. Also outputs for each cell:
Classification_confidence: confident, low_confidence on annotation
pan_cancer_cluster: either cancer or normal
scATOMIC_pred : celltype annotation
```{r scatomic}

#| fig.width: 10
#| fig.height: 10
#| fig.align: center
#| echo: FALSE
#| dependson: [annot_celltypes, scevan, dog_human_gene]


for (group in c(
                # "patient_prim", "patient_mets",
                # "dogs_prim", "dogs_mets",
                "mm_prim", "mm_mets"
                )) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))

    organism <-
        object$organism[1]

    #use the function to convert dog to human genes and make new seurat object
    if (organism == "dog") {
        object <-
            dog_to_human_setup(object)
        organism <- "human"
    }
    if (organism == "mouse") {
        object <-
            mouse_to_human_setup(object,
                                harm_vars = c("sample_name", "model"),
                                theta = c(12, 12))
        organism <- "human"
    }

    min_count_per_gene <- 10
    count_mtx_list <- object %>%
        SplitObject(split.by = "sample_name") %>%
        lapply(FUN = function(x) {
            temp_data <- GetAssayData(x, layer = "counts")
            temp_data <- temp_data[rowSums(temp_data) > min_count_per_gene, ]
        })

    result_list <-
        parallel::mclapply(names(count_mtx_list),
                           mc.cores = parallelly::availableCores(),
                           mc.preschedule = FALSE,
                           function(x) {
            cell_predictions <-
                scATOMIC::run_scATOMIC(
                    rna_counts = count_mtx_list[[x]],
                    mc.cores = parallelly::availableCores()
                )
            scATOMIC_results <-
                tryCatch(
                    {
                        scATOMIC::create_summary_matrix(
                            prediction_list = cell_predictions,
                            use_CNVs = T,
                            modify_results = T,
                            mc.cores = parallelly::availableCores(),
                            raw_counts = count_mtx_list[[x]],
                            min_prop = 0.5
                        ) %>%
                        select(starts_with("layer_"),
                               any_of(c("scATOMIC_pred",
                                      "classification_confidence",
                                      "CNV_status",
                                      "pan_cancer_cluster")))
                },
                error = function(e) {
                    message("scATOMIC failed for ",group, " ", x, " with error: ", e)
                    scATOMIC::create_summary_matrix(
                        prediction_list = cell_predictions,
                        modify_results = T,
                        mc.cores = parallelly::availableCores(),
                        raw_counts = count_mtx_list[[x]],
                        min_prop = 0.5
                    ) %>%
                    select(starts_with("layer_"),
                               any_of(c("scATOMIC_pred",
                                      "classification_confidence",
                                      "CNV_status")))
                })

            return(scATOMIC_results)
        })

    directory <-
        "output/id_tumor/scATOMIC/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }

    dplyr::bind_rows(result_list) %>%
    mutate(scatomic_tumor_call = if_else(grepl("Cancer Cell$", scATOMIC_pred),
                                         "cancer_cells",
                                         "normal_cells")) %>%
    rownames_to_column("cell") %>%
    write_tsv(str_c("output/id_tumor/scATOMIC/",
                    group,
                    "_metadata.tsv"))
}


```

## plotting the results of scATOMIC
```{r scatomic_scevan_plots}
#| fig.width: 10
#| fig.height: 10
#| fig.align: center
#| echo: FALSE
#| dependson: scatomic
for (group in c(
                # "patient_prim", "patient_mets",
                # "dogs_prim", "dogs_mets",
                "mm_prim", "mm_mets"
                )) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))

    #add scatomic label
    scatomic_label <-
        readr::read_tsv(str_c("output/id_tumor/scATOMIC/",
                            group,
                            "_metadata.tsv")) %>%
        column_to_rownames("cell")
    object <- object %>%
            AddMetaData(metadata = scatomic_label)

    #loop over individual  samples to plot and save
    for (samples in unique(object$sample_name)) {
        sub_sobj <- subset(object, sample_name == samples) %>%
                        process_seurat()

        #make a plot
        scatomic1 <- dimplot_better(sub_sobj,
                                   group_by = "scATOMIC_pred") +
                        NoLegend()

        # check if CNV_status is present and if all of them are NA, cannot plot
        if (all(!is.na(sub_sobj$CNV_status))) {
            scatomic2 <- dimplot_better(sub_sobj,
                                        group_by = "CNV_status") +
                            NoLegend()
        } else {
            scatomic2 <- ggplot(data = NULL) +
                            aes(x = as.factor(1), y = as.factor(1)) +
                            geom_text(aes(label = str_c("CNV_status not present for ", samples)))
        }
        scatomic3 <- dimplot_better(sub_sobj,
                                   group_by = "scatomic_tumor_call") +
                        NoLegend()

        scatomic4 <- dimplot_better(sub_sobj,
                                   group_by = "new_annot_clust") +
                        NoLegend()

        # patchwork the plot for scatomic
        dimplot_sub_sobj <-
            patchwork::wrap_plots(scatomic1,
                                scatomic2,
                                scatomic3,
                                scatomic4,
                                ncol = 2) +
                patchwork::plot_annotation(title = samples)

        directory <-
            str_c("output/figures/scatomic/", group)
        if (!dir.exists(directory)) {
            dir.create(directory, recursive = TRUE)
        }
        # save the plot for scatomic
        ggsave(str_c("output/figures/scatomic/",
                        group, "/",
                        samples,
                        "_dimplot.png"),
                plot = dimplot_sub_sobj,
                width = 14,
                height = 14)
    }
}

# scevan was done in mice as well so have to loop over all of the groups
for (group in c("patient_prim", "patient_mets",
                "mm_prim", "mm_mets",
                "dogs_prim", "dogs_mets")) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                              group,
                              ".qs"))

    #add scevan label
    scevan_label <-
        readr::read_tsv(str_c("output/id_tumor/SCEVAN/",
                            group,
                            "_metadata.tsv")) %>%
        column_to_rownames("cell")
    object <-
        object %>%
        AddMetaData(metadata = scevan_label)

    #loop over individual  samples to plot and save
    for (samples in unique(object$sample_name)) {
        sub_sobj <-
            subset(object, sample_name == samples) %>%
            process_seurat()

        # check if CNV_status is present and if all of them are NA, cannot plot
        if (all(!is.na(sub_sobj$scevan_tumor_call))) {
            scevan1 <-
                dimplot_better(sub_sobj,
                                group_by = "scevan_tumor_call") +
                    NoLegend()
        } else {
            scevan1 <-
                ggplot(data = NULL) +
                    aes(x = as.factor(1), y = as.factor(1)) +
                    geom_text(aes(label = str_c("scevan_tumor_call not present for ", samples)))
        }

        scevan2 <-
            dimplot_better(sub_sobj,
                            group_by = "new_annot_clust") +
                NoLegend()

        # patchwork the plot for scatomic
        dimplot_sub_sobj <-
            patchwork::wrap_plots(scevan1,
                                scevan2,
                                ncol = 2) +
                patchwork::plot_annotation(title = samples)

        directory <-
            str_c("output/figures/scevan/", group)
        if (!dir.exists(directory)) {
            dir.create(directory, recursive = TRUE)
        }
        # save the plot for scatomic
        ggsave(str_c("output/figures/scevan/",
                        group, "/",
                        samples,
                        "_dimplot.png"),
                plot = dimplot_sub_sobj,
                width = 14,
                height = 7)
    }
}
```

## create the snv calling metadata and save it
```{r snv_calling}
# path to snv result metadata in Matts repo
snv_result_path <-
    "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/id_tumor/snvs/"
    #"/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/id_tumor/snvs/"

snv_depth <-
    read_tsv("misc/use_snv_tumor_calls.txt")

for (group in c("patient_prim", "patient_mets",
                "mm_prim", "mm_mets",
                "dogs_prim", "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/harmony_sobjs_annot/",
                        group,
                        ".qs"))

    organism <-
        object$organism[1]

    #make a list of the samples
    metadata_list <- list()

    # read in the cmetadata
    for (samples in unique(object$sample_name)) {
        sobj <- subset(object, sample_name == samples)

        tsv_file <- str_c(snv_result_path,
                          organism, "_",
                          samples,
                          "_snv_calls.tsv")

        if (file.exists(tsv_file)) {
            pick_depth <-
                snv_depth %>%
                filter(sample_name == samples) %>%
                pull(use_snv_column)

            tumor_label <-
                snv_depth %>%
                filter(sample_name == samples) %>%
                pull(tumor_groups) %>%
                str_split(",") %>%
                unlist()

            if (!is.na(pick_depth)) {
                snv_metadata <-
                    readr::read_tsv(tsv_file) %>%
                    select(cell, all_of(pick_depth))
                snv_metadata$final_snv_call <-
                    ifelse(snv_metadata[[pick_depth]] %in% tumor_label,
                            "cancer_cells",
                            "normal_cells")
                snv_metadata <-
                    snv_metadata %>%
                    mutate(cell = paste(samples, cell, sep = "_")) %>%
                    # column_to_rownames(var = "cell") %>%
                    select(cell, final_snv_call) %>%
                    mutate(final_snv_call = tidyr::replace_na(final_snv_call, replace = "unknown"))
            } else {
                snv_metadata <-
                    sobj@meta.data %>%
                    rownames_to_column("cell") %>%
                    select(cell) %>%
                    mutate(final_snv_call = "unknown")
            }
        } else {
            snv_metadata <-
                sobj@meta.data %>%
                rownames_to_column("cell") %>%
                select(cell) %>%
                mutate(final_snv_call = "unknown")
        }
        metadata_list[[samples]] <- snv_metadata
    }
    directory <-
        "output/id_tumor/snv_calling/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }
    dplyr::bind_rows(metadata_list) %>%
        write_tsv(str_c("output/id_tumor/snv_calling/",
                        group,
                        "_metadata.tsv"))
}
```


## test that the PDX and cell culture tumor cell can be used to annotate the tumor
will use the reference we used to annoate the tumor cells in human, mice, and dog data
to annotate a curated dataset where we know what cells are tumor and what are not
the mouse These samples were injected with barcoded F420 cells. I'll be getting the barcode information from the bams and writing it off as a metadata table.
Barcoded samples that aren't PDXs:
    S0260
    S0261

For human part # reference has "S0170", "S0042" for xenograft hence we will use
"SJOS013769_X1_human", "X00018_human",
"S0034_human",          "X00020_human"

Four normal bone samples are
X00018
X00019
X00020
X00021

random samples for xeno primary validation: 1) S0042 2)SJOS016015_X1
 random samples for xeno mets validation: 1) S0055  2)SJOS001112_X1


```{r test_tumor_anno_with_curated_data}

# make mouse object for validation
### S0260 and S0261
bc_calling <- list()
for (ob in c("S0260", "S0261")) {
    if (file.exists(paste0("output/metadata/barcode_", ob, ".tsv"))) {
        bc_calling[[ob]] <- read.table(
            paste0("output/metadata/barcode_", ob, ".tsv"),
            header = TRUE
        )
    } else {
        bc_calling[[ob]] <- gen_cellecta_bc_data(
            file = paste0(
                "/home/gdrobertslab/lab/Counts_2/",
                ob,
                "/possorted_genome_bam.bam"
                    ),
            verbose = TRUE,
            output = paste0("output/metadata/barcode_", ob, ".tsv"),
            samtools_module = "GCC/9.3.0 SAMtools/1.15"
        )
    }
}

ob_list <- list()
for (ob in c("S0260", "S0261")) {
    ob_list[[ob]] <- tenx_load_qc(
        paste0(
            "/home/gdrobertslab/lab/Counts_2/",
            ob,
            "/filtered_feature_bc_matrix"
        ),
        violin_plot = FALSE
    )
    ob_list[[ob]]$sample_id <- ob
}

qc_plts <- lapply(ob_list, feature_hist, features = c("nCount_RNA", "percent.mt"))
grid.arrange(grobs = qc_plts)

ob_list <- lapply(ob_list, function(x) {
    subset(
        x,
        nCount_RNA %in% c(1000:60000) &
        percent.mt < 10
    ) %>%
    process_seurat()
})

# add barcode info to objects and
for (ob in names(ob_list)) {
    ob_list[[ob]]$barcoded <-
        colnames(ob_list[[ob]]) %in% paste0(bc_calling[[ob]]$cid, "-1")
}

# merge
mouse_sobj <- 
    merge(ob_list[[1]], ob_list[[2]]) %>%
    JoinLayers() %>%
    process_seurat()
mouse_sobj$organism <- "mouse"
mouse_sobj$sample_name <- mouse_sobj$sample_id

dimplot_better(mouse_sobj,
            group_by = "barcoded")
FeaturePlot(mouse_sobj,
            features = c("Runx2", "Satb2", "Col1a1", "Col1a2"))

# Identify the cluster(s) with the most barcoded=="tumor" cells
cluster_counts <- 
    table(mouse_sobj$seurat_clusters, mouse_sobj$barcoded)
# Find cluster(s) where most cells are barcoded (TRUE)
tumor_clusters <- 
    names(which(cluster_counts[, "TRUE"] == max(cluster_counts[, "TRUE"])))
# Assign "tumor" to cells in those clusters, "stroma" otherwise
mouse_sobj$truth_metadata <-
    ifelse(mouse_sobj$seurat_clusters %in% tumor_clusters, "tumor", "stroma")

dimplot_better(mouse_sobj, group_by= "truth_metadata")
# save the individual object
S0260 <- 
    mouse_sobj %>%
    subset(sample_name == "S0260") %>%
    process_seurat()
if (!dir.exists("output/seurat_objects/validation/tumor_annotation/")) {
    dir.create("output/seurat_objects/validation/tumor_annotation/", recursive = TRUE)
}
qs::qsave(S0260,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "S0260_mouse.qs"))
S0261 <-
    mouse_sobj %>%
    subset(sample_name == "S0261") %>%
    process_seurat()
qs::qsave(S0261,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "S0261_mouse.qs"))



## prepare the human healthy lung stroma to be merged 
lungblood_obj <-
    qs::qread("input/downloads/human_lung.qs")
dimplot_better(lungblood_obj,
            group_by = "free_annotation") +
    NoLegend() + ggtitle("lungblood object")

# make first stroma for human lung
stroma1 <-
    subset(lungblood_obj,
            cells = sample(colnames(lungblood_obj), 20000)) %>%
    process_seurat()
stroma1$sample_name <- "lungblood_stroma1"
qs::qsave(stroma1,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "human_lung_stroma1.qs"))
# make second stroma for human lung
stroma2 <-
    subset(lungblood_obj,
           cells = sample(setdiff(colnames(lungblood_obj), colnames(stroma1)), 20000)) %>%
    process_seurat()
stroma2$sample_name <- "lungblood_stroma2" 
qs::qsave(stroma2,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                "human_lung_stroma2.qs"))

# combination of samples for human tumor annotation and reference validation

samples <- 
    tribble(~tumor_name,            ~truth_metadata,
            "SJOS016015_X1_human",   "tumor",       # xeno primary tumor cell with femur head
            "S0042_human",           "tumor",        # xeno primary tumor cell with femur head
            "S0055_human",            "tumor",   # xeno mets tumor cell
            "SJOS001112_X1_human",    "tumor",        # xeno mets tumor cell
            "X00018_human",            "stroma",
            "X00020_human",            "stroma",
            "X00021_human",             "stroma", # xeno primary tumor cell with femur head
            "X00019_human",            "stroma" # xeno primary tumor cell with femur head
)
# save into the one location for all the validation object
for (item in seq_len(ncol(samples))) {
    tumor_name <- samples$tumor_name[item]
    truth_metadata <- samples$truth_metadata[item]
    dir <- str_c("output/seurat_objects/sobj_preprocess")
    tumor <-
        qs::qread(str_c(dir, "/", tumor_name, ".qs"))

    tumor$sample_name <- tumor_name
    tumor$truth_metadata <- truth_metadata
    #dimplot_better(tumor, group_by = "truth_metadata")
    qs::qsave(tumor,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                tumor_name, ".qs"))
}

# make the stroma human primary
stroma_names <-
    tribble(~stroma_name1,   ~stroma_name2,   ~name,
            "X00018_human", "X00019_human",    "prim_stroma1",
            "X00020_human",  "X00021_human",   "prim_stroma2")
# combine the stroma and tumor for validation
for (i in seq_len(nrow(stroma_names))) {
    stroma_name1 <- stroma_names$stroma_name1[i]
    stroma_name2 <- stroma_names$stroma_name2[i]
    stroma_name <- stroma_names$name[i]
    stroma1_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        stroma_name1, ".qs"))

    stroma2_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        stroma_name2, ".qs"))

    combined_stroma <-
        merge(stroma1_sobject, stroma2_sobject,
              add.cell.ids = c("stroma1", "stroma2")) %>%
        JoinLayers() %>%
        process_seurat()
    
    qs::qsave(combined_stroma,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                stroma_name, ".qs"))
}


# the combination
samples_to_combine <- 
    tribble(~tumor_name,                ~stroma_name,
            "SJOS016015_X1_human",    "prim_stroma1",   #xeno primary tumor cell with femur head
            "S0042_human",            "prim_stroma2",   #xeno primary tumor cell with femur head
            "S0055_human",            "human_lung_stroma1",  # xeno mets tumor cell with human lung stroma
            "SJOS001112_X1_human",    "human_lung_stroma2") # xeno mets tumor cell with human lung stroma

# combine and prepare the stroma and tumor for validation
for (i in seq_len(nrow(samples_to_combine))) {
    stroma_name <- samples_to_combine$stroma_name[i]
    tumor_name <- samples_to_combine$tumor_name[i]
    stromal_metadata <- list()
    tumor_metadata <- list()

    dir <- str_c("output/seurat_objects/validation/tumor_annotation/")
    tumor <-
        qs::qread(str_c(dir, "/", tumor_name, ".qs"))
    tumor$truth_metadata <- "tumor"

    # check if the object already exists
    stroma <-
        qs::qread(str_c(dir, "/", stroma_name, ".qs"))
    stroma$truth_metadata <- "stroma"

    combine_sobject <-
        merge(stroma, tumor,
              add.cell.ids = c("stroma", "tumor")) %>%
        JoinLayers() %>%
        process_seurat() %>%
        RunHarmony(group.by.vars = "sample_name",
                    theta = 7) %>%
        process_seurat(reduction = "harmony")

    dimplot_better(combine_sobject,
                group_by = "truth_metadata")

    if (!dir.exists("output/seurat_objects/validation/tumor_annotation/")) {
        dir.create("output/seurat_objects/validation/tumor_annotation/", recursive = TRUE)
    }
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                tumor_name, "_", stroma_name,
                "_combined.qs"))

}



clusterbased_annot <- function(s_obj) {
    Idents(s_obj) <- s_obj$seurat_clusters
    clust_info <- tibble()
    for (cluster in unique(s_obj$seurat_clusters)) {
        set.seed(199820)
        print(str_c("Reclustering cluster ", cluster))
        subset_object <- subset(s_obj, ident = cluster) %>%
            FindVariableFeatures() %>%
            ScaleData() %>%
            # don't ask for more PCs than there are cells
            RunPCA(npcs = min(50,
                            sum(s_obj$seurat_clusters == cluster) - 1))

        subset_object$re_cluster <- str_c(cluster,
                                        ".",
                                        subset_object$seurat_clusters)

        clust_info <- subset_object@meta.data %>%
                as.data.frame() %>%
                select(re_cluster) %>%
                rbind(clust_info)
    }

    s_obj <- AddMetaData(s_obj, metadata = clust_info)
    s_obj$new_annot_clust <- s_obj$re_cluster

    cluster_celltypes <-
        table(s_obj$re_cluster, s_obj$annotations) %>%
        as.data.frame() %>%
        group_by(Var1) %>%
        arrange(desc(Freq), .by_group = TRUE) %>%
        slice_head(n = 1)

    for (i in seq_len(nrow(cluster_celltypes))) {
        seurat_clust <- str_c("^", cluster_celltypes$Var1[i], "$") %>%
            as.character()

        celltype <- cluster_celltypes$Var2[i] %>%
            as.character()

        s_obj$new_annot_clust <-
            str_replace_all(string = s_obj$new_annot_clust,
                            pattern = seurat_clust,
                            replacement = celltype)
    }
    return(s_obj)
}
# actual validation parent
samples_for_validation <- 
    tribble(~names,                                           ~species,
            # "S0260_mouse",                                    "mouse",
            # "S0261_mouse",                                     "mouse",
            # "S0042_human_prim_stroma2_combined",               "human",
            # "SJOS016015_X1_human_prim_stroma1_combined",       "human",
            # "SJOS001112_X1_human_human_lung_stroma2_combined", "human_lung",
            # "S0055_human_human_lung_stroma1_combined",          "human_lung",
            "SJOS016015_X1_human_femur_nonunion_exchange_nailing_combined",  "human",
            "S0042_human_femur_nonunion_exchange_nailing_combined",  "human",
            "S0042_human_femur_non_union_01162020_combined",  "human",
            "SJOS016015_X1_human_Femur_NonUnion_Fresh_02062020_combined",  "human",
            "S0042_human_Femur_NonUnion_Fresh_02062020_combined",  "human",
            "S0055_human_2020_10_IPF_LL_replicate_6_combined",  "human_lung",
            "S0055_human_10194_IPF_LL_replicate_5_combined",  "human_lung",
            "SJOS001112_X1_human_10183_IPF_LL_replicate_4_combined",  "human_lung",
            "SJOS016015_X1_human_femur_non_union_01142020_combined",  "human",
            "SJOS001112_X1_human_10172_IPF_LL_replicate_3_combined",  "human_lung"
      )


for (item in seq_len(nrow(samples_for_validation))) {
    names <- samples_for_validation$names[item]
    species <- samples_for_validation$species[item]
    combine_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        names, ".qs"))
    dimplot1 <-
        dimplot_better(combine_sobject,
                    group_by = "truth_metadata") +
        NoLegend() + ggtitle("object with known tumor and stroma")
    # Annotation
    # #use tumor before subsetting tumor
    # big_obj_with_tumor <-
    #     annotate_celltypes(sobject = combine_sobject,
    #                         species = species,
    #                         with_tumor = TRUE,
    #                         aggr_ref = TRUE)

    # this is my method
    ann_obj <-
        annotate_celltypes(sobject = combine_sobject,
                            species = species,
                            with_tumor = FALSE,
                            aggr_ref = TRUE)

    ann_obj <-
        clusterbased_annot(s_obj = ann_obj)
 
    ann_obj$just_stroma_annot <- ann_obj$new_annot_clust
    dimplot2 <-
        dimplot_better(ann_obj,
                    group_by = "just_stroma_annot") +
        NoLegend() + ggtitle("Annotation with stroma referece")

    # identify the potential tumor cells using the aucell with osteosarcoma markers
    osteosarcoma_markers <- c("RUNX2", "COL1A1", "COL1A2", "SATB2")
    potential_tumor_cells_list <- list()
    genelist <- osteosarcoma_markers
    if (species == "mouse") {
        genelist <-
            nichenetr::convert_human_to_mouse_symbols(genelist) %>%
            na.omit() %>%
            unique()
    }
    # prepare the matrix
    entire_matrix <-
        ann_obj@assays$RNA$counts

    # run AUcell
    genelist_present <- 
        genelist[genelist %in% rownames(entire_matrix)]

    cell_ranks <-
        AUCell::AUCell_run(exprMat = entire_matrix,
                           geneSets = genelist)

    ann_obj$AUC_OsteoMarkers <- AUCell::getAUC(cell_ranks)[1,]

    bulk_score_per_cluster <-
        ann_obj@meta.data %>%
        dplyr::select(AUC_OsteoMarkers, just_stroma_annot) %>%
        dplyr::group_by(just_stroma_annot) %>%
        dplyr::summarise(median = median(AUC_OsteoMarkers, na.rm = TRUE)) %>%
        dplyr::arrange(desc(median))
    tumor_cells <-
        bulk_score_per_cluster %>%
        dplyr::filter(median > 0.3) %>%
        dplyr::pull(just_stroma_annot)

    stroma_cells <-
        bulk_score_per_cluster %>%
        dplyr::filter(median <= 0.3) %>%
        dplyr::pull(just_stroma_annot)
    # subset the object
    stroma_cells_sobj <-
        subset(ann_obj,
                just_stroma_annot %in% stroma_cells)
    tumor_cells_sobj <-
        subset(ann_obj,
                just_stroma_annot %in% tumor_cells) %>%
        process_seurat(resolution = 0.1)

    dimplot3 <-
        dimplot_better(tumor_cells_sobj,
                    group_by = "just_stroma_annot") +
        NoLegend() + ggtitle("Potential tumor cells")

    dimplot4 <-
        dimplot_better(tumor_cells_sobj,
                    group_by = "seurat_clusters") +
        NoLegend() + ggtitle("Potential tumor cells")

    Idents(tumor_cells_sobj) <- tumor_cells_sobj$seurat_clusters
    stromal_metadata <- list()
    tumor_metadata <- list()
    for (clusters in unique(tumor_cells_sobj$seurat_clusters)) {
        sub_obj <-
            subset(tumor_cells_sobj,
                   seurat_clusters == clusters)
        if (ncol(sub_obj) > 100) {
            sub_obj <-
                sub_obj %>%
                process_seurat(resolution = 0.1)
        } else {
            sub_obj <- sub_obj
        }
        sub_obj <-
            annotate_celltypes(sobject = sub_obj,
                                species = species,
                                with_tumor = TRUE,
                                aggr_ref = TRUE)
        sub_obj <-
            clusterbased_annot(s_obj = sub_obj)

        sub_obj$annot_with_tumor <- sub_obj$annotations

    # save the ids
        normal_ids <-
            sub_obj@meta.data %>%
            filter(annot_with_tumor != "Tumor_cells") %>%
            rownames_to_column("cell_ids") %>%
            select(cell_ids)

        tumor_ids <-
            sub_obj@meta.data %>%
            filter(annot_with_tumor == "Tumor_cells") %>%
            rownames_to_column("cell_ids") %>%
            select(cell_ids)

        # save the metadata
        if (length(normal_ids$cell_ids) > 0) {
            stromal_metadata[[clusters]] <- normal_ids
        }
        if (length(tumor_ids$cell_ids) > 0) {
            tumor_metadata[[clusters]] <- tumor_ids
        }
    }
    # save the metadata
    stromal_cells_id <- bind_rows(stromal_metadata)
    tumor_cells_id <- bind_rows(tumor_metadata)

    combine_sobject$final_tumor_call <-
        ifelse(colnames(combine_sobject) %in% tumor_cells_id$cell_ids,
                "tumor",
                "stroma")
    dimplot5 <-
        DimPlot(combine_sobject,
            group.by = "final_tumor_call",
            label = T,
            cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
            label.box = T) +
        NoLegend() +
        theme_void() +
        ggtitle("Final tumor call")
    dimplot6 <-
        DimPlot(combine_sobject,
                group.by = "truth_metadata",
                label = T,
                cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
                label.box = T) +
        NoLegend() +
        theme_void() +
        ggtitle("truth metadata")

    # big_obj_with_tumor$annot_with_tumor_as_whole <-
    #     ifelse(big_obj_with_tumor$annotations == "Tumor_cells",
    #             "tumor",
    #             "stroma")

    # # add metadata of the big_obj_with_tumor column annot_with_tumor_as_whole to combine_sobject
    # combine_sobject$annot_with_tumor_as_whole <-
    #     big_obj_with_tumor$annot_with_tumor_as_whole[
    #         match(colnames(combine_sobject),
    #             colnames(big_obj_with_tumor))]

    # dimplot7 <-
    #     DimPlot(combine_sobject,
    #             group.by = "annot_with_tumor_as_whole",
    #             label = T,
    #             cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
    #             label.box = T) +
    #     NoLegend() +
    #     ggtitle("annotation with tumor in whole object")

    # patchwork the plots
    dimplot_combined <-
        patchwork::wrap_plots(dimplot5,
                            dimplot6,
                            ncol = 2) +
            patchwork::plot_annotation(title = names)
    directory <-
        str_c("output/figures/validation/tumor_annotation_method/", names)

    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }
    ggsave(str_c(directory, "/",
                names, "_dimplot.png"),
            plot = dimplot_combined,
            width = 14,
            height = 14)
    # save the combined object
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                names, "_validated.qs"))
}


samples_for_validation <- 
    tribble(~names,                                           ~species,
            # "S0260_mouse",                                    "mouse",
            # "S0261_mouse",                                     "mouse",
            "S0042_human_prim_arthritis",                        "human"
            # "SJOS001112_X1_human_human_lung_stroma2_combined", "human",
            # "S0055_human_human_lung_stroma1_combined",          "human",
            # "S0042_human_prim_stroma2_combined",               "human",
            # "SJOS016015_X1_human_prim_stroma1_combined",       "human"     #problematic smaple
      )


patchwork::wrap_plots(
    dimplot_better(object, group_by = "truth_metadata"),
    dimplot_better(object, group_by = "final_tumor_call"),
    ncol = 2
)


for (item in seq_len(nrow(samples_for_validation))) {
    group <- samples_for_validation$names[item]
    organism <- samples_for_validation$species[item]
    object <- 
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        group, 
                        "_validated.qs"))
    # SCEVAN results listed into an output for each seurat object
    #count matrix
    count_matrix <- 
        object %>%
        GetAssayData(layer = "counts")
    output <- 
        SCEVAN::pipelineCNA(count_mtx = count_matrix,
                            sample = group,
                            organism = organism,
                            par_cores = parallelly::availableCores(),
                            SUBCLONES = FALSE)
    # SCEVAN writes a bunch of files to ./output/ so we need to move them
    system(paste0("mv output/",
                group,
                "* output/id_tumor/SCEVAN/"))
    # Two of the files have spaces in their names :-|
    system(paste0("mv output/' ",
                    group,
                    " vega_output' output/id_tumor/SCEVAN/"))
    system(paste0("mv output/' ",
                group,
                "onlytumor vega_output' output/id_tumor/SCEVAN/"))
    object <-
        AddMetaData(object,
                    metadata = output)
    object$scevan_tumor_call <-
        ifelse(object$class == "tumor",
                "cancer_cells",
                "normal_cells")

    mouse_obj <- object
    # for scatomic, convert mouse to human
     if (organism == "mouse") {
        raw_counts <-
            GetAssayData(object,
                        slot = "counts")
        human_genes <-
            object %>%
            rownames() %>%
            nichenetr::convert_mouse_to_human_symbols() %>%
            as.character()
        new_raw_counts <-
            raw_counts

        rownames(new_raw_counts) <- human_genes

        new_raw_counts <-
            new_raw_counts[!is.na(rownames(new_raw_counts)), ]

        new_raw_counts <-
            new_raw_counts[!duplicated(rownames(new_raw_counts)), ]

        new_seurat_object <-
            CreateSeuratObject(counts = new_raw_counts) %>%
            AddMetaData(metadata = object@meta.data)

        object <-
            new_seurat_object %>%
            process_seurat()
    }
    
    # run scATOMIC
    min_count_per_gene <- 10
    count_matrix <- 
        object %>%
        GetAssayData(layer = "counts")
    count_matrix <- 
        count_matrix[rowSums(count_matrix) > min_count_per_gene, ]
    cell_predictions <-
        scATOMIC::run_scATOMIC(rna_counts = count_matrix)

    scATOMIC_results <-
        scATOMIC::create_summary_matrix(prediction_list = cell_predictions,
                                        use_CNVs = T,
                                        modify_results = T,
                                        mc.cores = parallelly::availableCores(),
                                        raw_counts = count_matrix,
                                        min_prop = 0.5) %>%
        select(starts_with("layer_"),
                any_of(c("scATOMIC_pred",
                        "classification_confidence",
                        "CNV_status")))
    # save the scATOMIC results
    
    if (organism == "mouse") {
        mouse_obj <-
            AddMetaData(mouse_obj,
                        metadata = scATOMIC_results)
        qs::qsave(mouse_obj,
                str_c("output/seurat_objects/validation/tumor_annotation/",
                    group, "_alldone.qs"))
    } else {
        object <-
            AddMetaData(object,
                        metadata = scATOMIC_results)
        qs::qsave(object,
                str_c("output/seurat_objects/validation/tumor_annotation/",
                    group, "_alldone.qs"))
    }
}



# make the plots for the validation
samples_for_validation <- 
    c("S0260_mouse",
      "S0261_mouse",
      "SJOS001112_X1_human_human_lung_stroma2_combined",
      "S0055_human_human_lung_stroma1_combined",
      "S0042_human_prim_stroma2_combined",
      "SJOS016015_X1_human_prim_stroma1_combined")

cols <-
    list("Tumor" = "#D43F3AFF",
        "Normal" = "#EEA236FF",
        "Unknown" = "#357EBDFF",
        "Host" = "#EEA236FF")

patchwork::wrap_plots(
    dimplot_better(combine_sobject, group_by = "truth_metadata"),
    dimplot_better(combine_sobject, group_by = "scatomic_tumor_call"),
    dimplot_better(combine_sobject, group_by = "scevan_tumor_call"),
    dimplot_better(combine_sobject, group_by = "copykat_tumor_call"),
    dimplot_better(combine_sobject, group_by = "final_tumor_call"),
    ncol = 3
    
)

for (group in samples_for_validation) {
    combine_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        group, "_alldone.qs"))
    combine_sobject$scatomic_tumor_call <-
        ifelse(grepl("Cancer Cell$", combine_sobject$scATOMIC_pred),
                "tumor",
                "stroma")
    combine_sobject$scevan_tumor_call <-
        ifelse(combine_sobject$scevan_tumor_call == "cancer_cells",
                "tumor",
                "stroma")
    combine_sobject$copykat_tumor_call <-
        ifelse(combine_sobject$CNV_status == "aneuploid",
                "tumor",
                "stroma")
    #dimplot_better(combine_sobject, group_by = "scATOMIC_pred")
    # give me some kind of metric to see how well do the two annotations match
    metadata <-
        combine_sobject@meta.data %>%
        select(final_tumor_call, truth_metadata,
                copykat_tumor_call, scevan_tumor_call, scatomic_tumor_call) %>%
        rownames_to_column("cell_id") %>%
        arrange(truth_metadata,
                final_tumor_call,
                copykat_tumor_call,
                scevan_tumor_call,
                scatomic_tumor_call) %>%
        mutate(cell_id_number = row_number()) %>%
        rename(Truth = truth_metadata,
                FinalCall = final_tumor_call,
                CopyKAT = copykat_tumor_call,
                SCEVAN = scevan_tumor_call,
                scATOMIC = scatomic_tumor_call)

    # make tile plot of the metadata
    prepared_metadata <-
        metadata %>%
        pivot_longer(cols = -c(cell_id, cell_id_number),
                names_to = "method",
                values_to = "call")
        # Set factor levels for method and call to control order in plot
    prepared_metadata$method <-
        factor(prepared_metadata$method,
                levels = c("Truth", "FinalCall", "CopyKAT", "SCEVAN", "scATOMIC"))
    prepared_metadata$call <-
        factor(prepared_metadata$call,
              levels = c("tumor", "stroma"))
    tile_plot <-
        ggplot(prepared_metadata, aes(x = method, y = cell_id_number, fill = call)) +
            geom_tile() +
            scale_fill_manual(values = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF")) +
            theme_minimal() +
            labs(title = "Tumor annotation comparison",
                 x = "Annotation Method",
                 y = "Cell Index") +
            theme(
                axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid = element_blank(),
                plot.margin = margin(0, 0, 0, 0), # Remove extra space around plot
                plot.background = element_rect(fill = NA, color = NA),
                panel.spacing = unit(0, "pt"),
                panel.border = element_blank()
            ) +
            scale_y_reverse(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0)) +
            geom_vline(xintercept = seq(1.5, length(unique(prepared_metadata$method)) - 0.5, by = 1),
                   color = "black", linetype = "dotted", size = 0.2) +
            coord_cartesian(clip = "on")

    # Confusion matrices and accuracy
    # Confusion matrices and accuracy for FinalCall, CallAsWhole, SCEVAN, scATOMIC
    confusion_matrix_final <- table(metadata$Truth, metadata$FinalCall)
    confusion_matrix_scevan <- table(metadata$Truth, metadata$SCEVAN)
    confusion_matrix_scatomic <- table(metadata$Truth, metadata$scATOMIC)

    accuracy_final <- sum(diag(confusion_matrix_final)) / sum(confusion_matrix_final)
    accuracy_scevan <- sum(diag(confusion_matrix_scevan)) / sum(confusion_matrix_scevan)
    accuracy_scatomic <- sum(diag(confusion_matrix_scatomic)) / sum(confusion_matrix_scatomic)

    # Accuracy barplot
    accuracy_df <- data.frame(
        Method = factor(c("Truth", "FinalCall", "SCEVAN", "scATOMIC"),
                        levels = c("Truth", "FinalCall", "SCEVAN", "scATOMIC")),
        Accuracy = c(1, accuracy_final, accuracy_scevan, accuracy_scatomic)
    )
    accuracy_barplot <-
        ggplot(accuracy_df, aes(x = Method, y = Accuracy, fill = Method)) +
            geom_bar(stat = "identity", width = 0.7, show.legend = FALSE) +
            geom_text(aes(label = round(Accuracy, 3), y = Accuracy/2), color = "white", size = 4) +
            labs(title = "Accuracy of Tumor Calls", x = "Methods", y = "Accuracy") +
            theme_minimal() +
            theme(axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
                  axis.text.y = element_text(face = "bold"),
                  panel.grid = element_blank(),
                  panel.border = element_blank()) +
            scale_fill_manual(values = c("Truth" = "#A0522D", "FinalCall" = "#D43F3AFF", "CallAsWhole" = "#0072B2FF", "SCEVAN" = "#377EB8", "scATOMIC" = "#4DAF4A")) +
            ylim(0, 1.05) +
            scale_y_continuous(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0))

    # Confusion matrix plots
    confusion_list <- list(
        FinalCall = list(tbl = confusion_matrix_final, acc = accuracy_final),
        SCEVAN = list(tbl = confusion_matrix_scevan, acc = accuracy_scevan),
        scATOMIC = list(tbl = confusion_matrix_scatomic, acc = accuracy_scatomic)
    )
    confusion_plots <-
        lapply(names(confusion_list), function(method) {
            tbl <- confusion_list[[method]]$tbl
            acc <- confusion_list[[method]]$acc
            df_tbl <- as.data.frame(as.table(tbl))
            colnames(df_tbl) <- c("Truth", "Prediction", "Freq")
            ggplot(df_tbl, aes(x = Prediction, y = Truth, fill = Freq)) +
                geom_tile(color = "white") +
                geom_text(aes(label = Freq), size = 2.5) +
                scale_fill_gradient(low = "#F0F0F0", high = "#D43F3AFF") +
                theme_minimal() +
                labs(title = paste0("Confusion Matrix: ", method,
                                   "\nAccuracy: ", round(acc, 3)),
                     x = "Predicted", y = "Truth") +
                theme(panel.grid = element_blank(),
                      plot.title = element_text(hjust = 0.5, size = 6, face = "bold"),
                      legend.position = "none",
                      axis.title.y = element_text(angle = 90),
                      axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 0.5))
        })
    confusion_combined <-
        patchwork::wrap_plots(confusion_plots, nrow = 1)

    # save the plot_grid
    all_plot <-
        cowplot::plot_grid(tile_plot,
                            accuracy_barplot,
                            confusion_combined,
                            ncol = 1,
                            rel_heights = c(1, 0.5, 0.4),
                            align = "v") +
            patchwork::plot_annotation(title = str_c(group, " Tumor ID by methods")) &
            theme(plot.title = element_text(size = 10))

    # save the confusion matrix plot
    if (!dir.exists("output/figures/validation/tumor_annotation_method/")) {
        dir.create("output/figures/validation/tumor_annotation_method/", recursive = TRUE)
    }
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                group, "_tumor_annotation_method.png"),
            plot = all_plot,
            width = 5,
            height = 10)
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                group, "_tumor_annotation_method.pdf"),
            plot = all_plot,
            width = 5,
            height = 10)

    if (!dir.exists("output/seurat_objects/validation/tumor_annotation/")) {
        dir.create("output/seurat_objects/validation/tumor_annotation/", recursive = TRUE)
    }
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/anno_",
                group))
}


sobj <-
    qs::qread("/home/gdrobertslab/lab/Analysis/MattGust/projects/Roberts_Lab/24_validate_snvs/output/seurat_objects/merged_S0260_61_with_calls.qs")

sobj$final_snv_call <-
    ifelse(sobj$snv_top_lvl_group_5 == "top_lvl_group0",
            "Tumor",
            "Stroma") %>%
    


dimplot_better(sobj,
            group_by = "final_snv_call") +
    NoLegend() + ggtitle("SNV calls in S0260 and S0261")

```

## downloaded for validations
```{r downloaded_sobj}
# arthritis data
arthritis <-
    readRDS("input/downloads/seurat_objects/arthritis_sobj.RDS")

# List all .h5 files in the directory GSE217792_RAW
h5_files <- list.files(
    "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/seurat_objects/GSE217792_RAW/",
    pattern = "\\.h5$",
    full.names = TRUE
)


# make tribble for qc_plts
cutoff_qc <-
    tribble(~sample_name,                           ~max_count,        ~percent_mt,
        "femur_nonunion_013119",                 70000,              20,
        "control_femur_reaming_09052019",        70000,              20,
        "Control_Femur_Canal_10292019",          30000,              20,
        "Control_femur_ICT_12032019",            30000,              20,
        "IMN_canal_020119",                      50000,              20,
        "femur_nonunion_exchange_nailing",      40000,              20,
        "Femur_non_union_01142020",             40000,              20,
        "Femur_non_union_01162020",              60000,              20,
        "Femur_NonUnion_Fresh_02062020",           50000,              20)

# Read each h5 file and create a Seurat object
seurat_objects <- lapply(h5_files, function(f) {
    obj <- 
        Seurat::Read10X_h5(f)
    seurat_obj <- 
        Seurat::CreateSeuratObject(counts = obj)
    seurat_obj$percent.mt <- 
        PercentageFeatureSet(seurat_obj, pattern = "^MT-") # Adjust pattern for mitochondrial genes if 
    seurat_obj$sample_name <- 
        basename(f) %>%
        str_replace("^[^_]+_", "") %>%           # Remove everything before first underscore
        str_replace("_filtered.*$", "") %>%         # Remove everything after _filtered %>%
        str_replace("-", "_") # Replace underscores with dashes for better readability
    max_ncount <-
        cutoff_qc$max_count[cutoff_qc$sample_name == seurat_obj$sample_name[1]]
    seurat_obj <-
        seurat_obj %>%
        subset(subset = nCount_RNA < max_ncount & percent.mt < 20) %>%
        process_seurat()
    seurat_obj$truth_metadata <- "stroma"
    return(seurat_obj)
})

# Optionally, name the list by file
names(seurat_objects) <- 
    basename(h5_files) %>%
        str_replace("^[^_]+_", "") %>%           # Remove everything before first underscore
        str_replace("_filtered.*$", "") %>%         # Remove everything after _filtered
        str_replace("-", "_")
# Save each Seurat object in the specified directory
output_dir <- "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/seurat_objects/GSE217792_Sobjs/"
if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)

for (obj_name in names(seurat_objects)) {
    qs::qsave(
        seurat_objects[[obj_name]],
        file = file.path(output_dir, paste0(obj_name, ".qs"))
    )
}
#combine the samples
combined_all1 <-
    merge(x = seurat_objects[[1]],
            y = seurat_objects[-1],
            add.cell.ids = names(seurat_objects),
            project = "GSE217792_All_Samples") %>%
    JoinLayers() %>%
    process_seurat()
dimplot_better(combined_all, group_by = "sample_name") +
    NoLegend() + ggtitle("Combined GSE217792_Sobj Samples")

qs::qsave(combined_all,
        file = "input/downloads/seurat_objects/GSE217792_Sobjs/GSE217792_All_Samples.qs")


# make the seurat object from the GSE283885
# List all .txt.gz files in the directory
txt_files <- list.files(
    "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/seurat_objects/GSE283885_RAW/",
    pattern = "\\.txt\\.gz$",
    full.names = TRUE
)

sample_qcs <-
    tribble(~ sample_name,                           ~max_count,        ~percent_mt,
        "20095_Healthy_replicate_1",                  12000,            20,  
        "20132_Healthy_replicate_2",                  6000,           20,    
        "20160_Healthy_replicate_3",                   4000,           20,
        "20108_Healthy_replicate_4",                     15000,           20,
        "20116_Healthy_replicate_5",                     15000,           20,
        "20126_Healthy_replicate_6",                     10000,           20,
        "20141_Healthy_replicate_7",                      30000,           20,
        "20150_Healthy_replicate_8",                      40000,           20,
        "20166_Healthy_replicate_9",                       20000,           20,
        "10160_IPF_LL_replicate_1",                        10000,           20,
        "101601_IPF_LL_replicate_2",                        10000,           20,
        "10172_IPF_LL_replicate_3",                         40000,           20,
        "10183_IPF_LL_replicate_4",                         15000,           20,
        "10194_IPF_LL_replicate_5",                         20000,           20,
        "2020_10_IPF_LL_replicate_6",                     15000,           20)

feature_hist(seurat_obj,
    features = c("nCount_RNA", "nFeature_RNA", "percent.mt"))

# Read each txt.gz file and create a Seurat object
seurat_objects_gse283885 <- lapply(txt_files, function(f) {
    Sys.setenv(VROOM_CONNECTION_SIZE = 131072 * 10)
    counts <- readr::read_tsv(f)
    # Assume first column is gene names, set as rownames
    mat <- as.matrix(counts[,-1])
    rownames(mat) <- counts[[1]]
    seurat_obj <- 
        Seurat::CreateSeuratObject(counts = mat)
    seurat_obj$percent.mt <- 
        PercentageFeatureSet(seurat_obj, pattern = "^MT-")
    seurat_obj$sample_name <- 
        basename(f) %>%
        stringr::str_extract("(?<=counts_).*(?=\\.txt\\.gz)")
    max_ncount <-
        sample_qcs$max_count[sample_qcs$sample_name == seurat_obj$sample_name[1]]
    seurat_obj <-
        seurat_obj %>%
        subset(subset = nCount_RNA < max_ncount & percent.mt < 20) %>%
        process_seurat()
    # Add truth metadata
    seurat_obj$truth_metadata <- "stroma"
    return(seurat_obj)
})

# Optionally, name the list by file
names(seurat_objects_gse283885) <- basename(txt_files) %>%
    stringr::str_extract("(?<=counts_).*(?=\\.txt\\.gz)")

# Save each Seurat object in the specified directory
output_dir_gse283885 <- 
    "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/seurat_objects/GSE283885_Sobjs/"
if (!dir.exists(output_dir_gse283885)) dir.create(output_dir_gse283885, recursive = TRUE)

for (obj_name in names(seurat_objects_gse283885)) {
    qs::qsave(
        seurat_objects_gse283885[[obj_name]],
        file = file.path(output_dir_gse283885, paste0(obj_name, ".qs"))
    )
}

combine_all <-
    merge(x = seurat_objects_gse283885[[1]],
            y = seurat_objects_gse283885[-1],
            add.cell.ids = names(seurat_objects_gse283885),
            project = "GSE283885_All_Samples") %>%
    JoinLayers() %>%
    process_seurat()

qs::qsave(combine_all,
        file = "input/downloads/seurat_objects/GSE283885_Sobjs/GSE283885_All_Samples.qs")
dimplot_better(combine_all, group_by = "sample_name") +
    NoLegend() + ggtitle("Combined GSE283885 Samples")

```


# make new synthetic objects from the downloaded objects
```{r make_synthetic_from_downloaded}

samples_to_combine <- 
    tribble(~primary,                               ~metastatic,                   
            "SJOS016015_X1_human",                  "S0055_human",              #tumor
            "S0042_human",                          "SJOS001112_X1_human",       #tumor
            "Femur_NonUnion_Fresh_02062020",        "2020_10_IPF_LL_replicate_6", #stroma  
            "Femur_non_union_01162020",             "10172_IPF_LL_replicate_3",  #stroma
            "Femur_non_union_01142020",             "10194_IPF_LL_replicate_5",   #stroma
            "femur_nonunion_exchange_nailing",      "10183_IPF_LL_replicate_4")   #stroma


primary_list <- list()
metastatic_list <- list()

# combine and prepare the stroma and tumor for validation
for (i in seq_len(nrow(samples_to_combine))) {
    primary <- samples_to_combine$primary[i]
    metastatic <- samples_to_combine$metastatic[i]

    dir1 <- str_c("output/seurat_objects/validation/tumor_annotation/")
    dir2 <- str_c("input/downloads/seurat_objects/GSE283885_Sobjs/")
    dir3 <- str_c("input/downloads/seurat_objects/GSE217792_Sobjs/")
    if (file.exists(file.path(dir1, paste0(primary, ".qs")))) {
        dir <- dir1
    } else if (file.exists(file.path(dir2, paste0(primary, ".qs")))) {
        dir <- dir2
    } else {
        dir <- dir3
    }
    primary_sobj <-
        qs::qread(str_c(dir, "/", primary, ".qs"))
    primary_list[[i]] <- primary_sobj

    # check if the object already exists
    if (file.exists(str_c(dir1, "/", metastatic, ".qs"))) {
        dir <- dir1
    } else if (file.exists(str_c(dir2, "/", metastatic, ".qs"))) {
        dir <- dir2
    } else {
        dir <- dir3
    }
    metastatic_sobj <-
        qs::qread(str_c(dir, "/", metastatic, ".qs"))
    metastatic_list[[i]] <- metastatic_sobj
}

# combine the primary and metastatic objects
primary_synthetic <-
    merge(x = primary_list[[1]],
            y = primary_list[-1],
            add.cell.ids = samples_to_combine$primary,
            project = "Primary_Synthetic") %>%
    JoinLayers() %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = "sample_name",
                theta = 7) %>%
    process_seurat(reduction = "harmony")
qs::qsave(primary_synthetic,
        str_c("output/seurat_objects/validation/tumor_annotation/primary_synthetic.qs"))

metastatic_synthetic <-
    merge(x = metastatic_list[[1]],
            y = metastatic_list[-1],
            add.cell.ids = samples_to_combine$metastatic,
            project = "Metastatic_Synthetic") %>%
    JoinLayers() %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = "sample_name",
                theta = 7) %>%
    process_seurat(reduction = "harmony")
qs::qsave(metastatic_synthetic,
        str_c("output/seurat_objects/validation/tumor_annotation/metastatic_synthetic.qs"))

# mosue object
S0260_mouse <-
    qs::qread("output/seurat_objects/validation/tumor_annotation/S0260_mouse.qs")
S0261_mouse <-
    qs::qread("output/seurat_objects/validation/tumor_annotation/S0261_mouse.qs")
S0260_61_mouse <-
    merge(x = S0260_mouse,
            y = S0261_mouse,
            add.cell.ids = c("S0260", "S0261"),
            project = "S0260_61_mouse") %>%
    JoinLayers() %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = "sample_name",
                theta = 7) %>%
    process_seurat(reduction = "harmony")
S0260_61_mouse$species <- "mouse"
qs::qsave(S0260_61_mouse,
        str_c("output/seurat_objects/validation/tumor_annotation/S0260_61_mouse.qs"))

# run scevan on the synthetic objects
min_cells <- 500

# run the SCEVAN pipeline
for (group in c(
                # "primary_synthetic", 
                #  "metastatic_synthetic",
                 "S0260_61_mouse")) {
    object <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        group,
                        ".qs"))
    organism <-
        object$organism[1]

    # SCEVAN results listed into an output for each seurat object
    result_list <-
        parallel::mclapply(unique(object$sample_name),
                            mc.preschedule = FALSE,
                            mc.cores = 1,
                            function(x) {
            # If we have too few cells SCEVAN errors out
            # dim(x) must have a positive length

            count_matrix <-
                object %>%
                subset(sample_name == x) %>%
                GetAssayData(layer = "counts")

            if (ncol(count_matrix) > min_cells) {
                # output <-
                #     SCEVAN::pipelineCNA(count_mtx = count_mtx_list[[x]],
                #                         sample = x,
                #                         organism = organism,
                #                         par_cores = parallelly::availableCores(),
                #                         SUBCLONES = FALSE)

                output <-
                    tryCatch(
                        {
                            SCEVAN::pipelineCNA(count_mtx = count_matrix,
                                                sample = x,
                                                organism = organism,
                                                par_cores = parallelly::availableCores(),
                                                SUBCLONES = FALSE)
                        },
                        error = function(e) {
                            message("SCEVAN failed for ",group, " ", x, " with error: ", e)
                        })

                 # SCEVAN writes a bunch of files to ./output/ so we need to move them
                system(paste0("mv output/",
                            x,
                            "* output/id_tumor/SCEVAN/"))
                # Two of the files have spaces in their names :-|
                system(paste0("mv output/' ",
                              x,
                              " vega_output' output/id_tumor/SCEVAN/"))
                system(paste0("mv output/' ",
                            x,
                            "onlytumor vega_output' output/id_tumor/SCEVAN/"))

                return(output)
            }
        })

    directory <-
        "output/id_tumor/SCEVAN/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }

    bind_rows(result_list) %>%
        mutate(scevan_tumor_call = if_else(class == "tumor",
                                           "cancer_cells",
                                           "normal_cells")) %>%
        rownames_to_column("cell") %>%
        write_tsv(str_c("output/id_tumor/SCEVAN/",
                        group,
                        "_metadata.tsv"))
}

# run scatomic on the synthetic objects
for (group in c(
                "primary_synthetic", 
                 "metastatic_synthetic",
                 "S0260_61_mouse")) {
    object <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        group,
                        ".qs"))
    dimplot_better(object, group_by = "organism") +
        NoLegend() + ggtitle(str_c(group, " before scATOMIC"))

    organism <-
        object$organism[1]

    #use the function to convert dog to human genes and make new seurat object
    if (organism == "mouse") {
        object <-
            mouse_to_human_setup(object,
                                harm_vars = c("sample_name"),
                                theta = c(7))
        organism <- "human"
    }

    min_count_per_gene <- 10
    count_mtx_list <- object %>%
        SplitObject(split.by = "sample_name") %>%
        lapply(FUN = function(x) {
            temp_data <- GetAssayData(x, layer = "counts")
            temp_data <- temp_data[rowSums(temp_data) > min_count_per_gene, ]
        })

    result_list <-
        parallel::mclapply(names(count_mtx_list),
                           mc.cores = parallelly::availableCores(),
                           mc.preschedule = FALSE,
                           function(x) {
            cell_predictions <-
                scATOMIC::run_scATOMIC(
                    rna_counts = count_mtx_list[[x]],
                    mc.cores = parallelly::availableCores()
                )
            scATOMIC_results <-
                tryCatch(
                    {
                        scATOMIC::create_summary_matrix(
                            prediction_list = cell_predictions,
                            use_CNVs = T,
                            modify_results = T,
                            mc.cores = parallelly::availableCores(),
                            raw_counts = count_mtx_list[[x]],
                            min_prop = 0.5
                        ) %>%
                        select(starts_with("layer_"),
                               any_of(c("scATOMIC_pred",
                                      "classification_confidence",
                                      "CNV_status",
                                      "pan_cancer_cluster")))
                },
                error = function(e) {
                    message("scATOMIC failed for ",group, " ", x, " with error: ", e)
                    scATOMIC::create_summary_matrix(
                        prediction_list = cell_predictions,
                        modify_results = T,
                        mc.cores = parallelly::availableCores(),
                        raw_counts = count_mtx_list[[x]],
                        min_prop = 0.5
                    ) %>%
                    select(starts_with("layer_"),
                               any_of(c("scATOMIC_pred",
                                      "classification_confidence",
                                      "CNV_status")))
                })

            return(scATOMIC_results)
        })

    directory <-
        "output/id_tumor/scATOMIC/"
    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }

    dplyr::bind_rows(result_list) %>%
    mutate(scatomic_tumor_call = if_else(grepl("Cancer Cell$", scATOMIC_pred),
                                         "cancer_cells",
                                         "normal_cells")) %>%
    rownames_to_column("cell") %>%
    write_tsv(str_c("output/id_tumor/scATOMIC/",
                    group,
                    "_metadata.tsv"))
}



# run my methods on the synthetic objects
samples_for_validation <- 
    tribble(~names,                                           ~species,
            "primary_synthetic",                              "human",
            "metastatic_synthetic",                           "human_lung",
            "S0260_61_mouse",                                "mouse_lung")

for (item in seq_len(nrow(samples_for_validation))) {
    names <- samples_for_validation$names[item]
    species <- samples_for_validation$species[item]
    combine_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        names, ".qs"))
    dimplot1 <-
        dimplot_better(combine_sobject,
                    group_by = "truth_metadata") +
        NoLegend() + ggtitle("object with known tumor and stroma")

    # this is my method
    ann_obj <-
        annotate_celltypes(sobject = combine_sobject,
                            species = species,
                            with_tumor = FALSE,
                            aggr_ref = TRUE)

    ann_obj <-
        clusterbased_annot(s_obj = ann_obj)
 
    ann_obj$just_stroma_annot <- ann_obj$new_annot_clust
    dimplot2 <-
        dimplot_better(ann_obj,
                    group_by = "just_stroma_annot") +
        NoLegend() + ggtitle("Annotation with stroma referece")

    # identify the potential tumor cells using the aucell with osteosarcoma markers
    osteosarcoma_markers <- c("RUNX2", "COL1A1", "COL1A2", "SATB2")
    potential_tumor_cells_list <- list()
    genelist <- osteosarcoma_markers
    if (species == "mouse" | species == "mouse_lung") {
        genelist <-
            nichenetr::convert_human_to_mouse_symbols(genelist) %>%
            na.omit() %>%
            unique()
    }
    # prepare the matrix
    entire_matrix <-
        ann_obj@assays$RNA$counts

    # run AUcell
    genelist_present <- 
        genelist[genelist %in% rownames(entire_matrix)]

    cell_ranks <-
        AUCell::AUCell_run(exprMat = entire_matrix,
                           geneSets = genelist)

    ann_obj$AUC_OsteoMarkers <- AUCell::getAUC(cell_ranks)[1,]

    bulk_score_per_cluster <-
        ann_obj@meta.data %>%
        dplyr::select(AUC_OsteoMarkers, just_stroma_annot) %>%
        dplyr::group_by(just_stroma_annot) %>%
        dplyr::summarise(median = median(AUC_OsteoMarkers, na.rm = TRUE)) %>%
        dplyr::arrange(desc(median))
    tumor_cells <-
        bulk_score_per_cluster %>%
        dplyr::filter(median > 0.3) %>%
        dplyr::pull(just_stroma_annot)

    stroma_cells <-
        bulk_score_per_cluster %>%
        dplyr::filter(median <= 0.3) %>%
        dplyr::pull(just_stroma_annot)
    # subset the object
    stroma_cells_sobj <-
        subset(ann_obj,
                just_stroma_annot %in% stroma_cells)
    tumor_cells_sobj <-
        subset(ann_obj,
                just_stroma_annot %in% tumor_cells) %>%
        process_seurat(resolution = 0.1)

    dimplot3 <-
        dimplot_better(tumor_cells_sobj,
                    group_by = "just_stroma_annot") +
        NoLegend() + ggtitle("Potential tumor cells")

    dimplot4 <-
        dimplot_better(tumor_cells_sobj,
                    group_by = "seurat_clusters") +
        NoLegend() + ggtitle("Potential tumor cells")

    Idents(tumor_cells_sobj) <- tumor_cells_sobj$seurat_clusters
    stromal_metadata <- list()
    tumor_metadata <- list()
    for (clusters in unique(tumor_cells_sobj$seurat_clusters)) {
        sub_obj <-
            subset(tumor_cells_sobj,
                   seurat_clusters == clusters)
        if (ncol(sub_obj) > 100) {
            sub_obj <-
                sub_obj %>%
                process_seurat(resolution = 0.1)
        } else {
            sub_obj <- sub_obj
        }
        sub_obj <-
            annotate_celltypes(sobject = sub_obj,
                                species = species,
                                with_tumor = TRUE,
                                aggr_ref = TRUE)
        sub_obj <-
            clusterbased_annot(s_obj = sub_obj)

        sub_obj$annot_with_tumor <- sub_obj$annotations

    # save the ids
        normal_ids <-
            sub_obj@meta.data %>%
            filter(annot_with_tumor != "Tumor_cells") %>%
            rownames_to_column("cell_ids") %>%
            select(cell_ids)

        tumor_ids <-
            sub_obj@meta.data %>%
            filter(annot_with_tumor == "Tumor_cells") %>%
            rownames_to_column("cell_ids") %>%
            select(cell_ids)

        # save the metadata
        if (length(normal_ids$cell_ids) > 0) {
            stromal_metadata[[clusters]] <- normal_ids
        }
        if (length(tumor_ids$cell_ids) > 0) {
            tumor_metadata[[clusters]] <- tumor_ids
        }
    }
    # save the metadata
    stromal_cells_id <- bind_rows(stromal_metadata)
    tumor_cells_id <- bind_rows(tumor_metadata)

    combine_sobject$final_tumor_call <-
        ifelse(colnames(combine_sobject) %in% tumor_cells_id$cell_ids,
                "tumor",
                "stroma")
    combine_sobject <-
        AddMetaData(combine_sobject,
                    ann_obj@meta.data %>% select(c("annotations", "just_stroma_annot")))

    dimplot5 <-
        DimPlot(combine_sobject,
            group.by = "final_tumor_call",
            label = T,
            cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
            label.box = T) +
        NoLegend() +
        theme_void() +
        ggtitle("Final tumor call")
    dimplot6 <-
        DimPlot(combine_sobject,
                group.by = "truth_metadata",
                label = T,
                cols = c("stroma" = "#EEA236FF", "tumor" = "#D43F3AFF"),
                label.box = T) +
        NoLegend() +
        theme_void() +
        ggtitle("truth metadata")

    # patchwork the plots
    dimplot_combined <-
        patchwork::wrap_plots(dimplot5,
                            dimplot6,
                            ncol = 2) +
            patchwork::plot_annotation(title = names)
    directory <-
        str_c("output/figures/validation/tumor_annotation_method/", names)

    if (!dir.exists(directory)) {
        dir.create(directory, recursive = TRUE)
    }
    ggsave(str_c(directory, "/",
                names, "_dimplot.png"),
            plot = dimplot_combined,
            width = 14,
            height = 14)
    # save the combined object
    qs::qsave(combine_sobject,
            str_c("output/seurat_objects/validation/tumor_annotation/",
                names, "_validated.qs"))
}

# Make plots

patchwork::wrap_plots(
    dimplot_better(combine_sobject, group_by = "truth_metadata"),
    dimplot_better(combine_sobject, group_by = "final_tumor_call"),
    dimplot_better(combine_sobject, group_by = "scevan_tumor_call"),
    dimplot_better(combine_sobject,  group_by = "scatomic_tumor_call"),
    dimplot_better(combine_sobject, group_by = "CNV_status"),
    dimplot_better(combine_sobject, group_by = "just_stroma_annot"),
    ncol = 3
) 
samples_for_validation <- 
    tribble(~names,                                           ~species,
            "primary_synthetic",                              "human",
            "metastatic_synthetic",                           "human_lung"
            # "S0260_61_mouse",                                "mouse_lung"
            )

#scanbit results for the mouse object
mouse_scanbit <-
    qs::qread("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/id_tumor/snvs/S0260_S0261_scanbit_sobj.qs")

mouse_scanbit$scanbit_tumor_call <-
    ifelse(mouse_scanbit$snv_top_lvl_group_5 == "top_lvl_group0",
            "Tumor",
            "Normal")
scanbit_metadata <-
    mouse_scanbit@meta.data %>%
    select(scanbit_tumor_call) %>%
    rownames_to_column("cell") %>%
    mutate(cell = case_when(
        grepl("^S0260", cell) ~ paste0(cell, "_1"),
        grepl("^S0261", cell) ~ paste0(cell, "_2"),
        TRUE ~ cell
    ))

plot_cols_new <- list(
    Tumor = "#D43F3AFF",
    Normal = "#EEA236FF",
    Unknown = "#357EBDFF",
    B_cells = "#B8B8B8FF",
    Basophil_Mast = "#9632B8FF",
    CD34_plusB_cells = "#46B8DAFF",
    CMP_Progenitors = "#90302DFF",
    Chondrocytes = "#A66D04FF",
    Dendritic_cells = "#2D577FFF",
    Endothelial_cells = "#3E7E3EFF",
    Epithelial_cells = "#7D7D7DFF",
    Erythroblast = "#6D1D87FF",
    GMP_Progenitors = "#097F9AFF",
    MEP_progenitors = "#FF6E6AFF",
    MSC = "#FFBB70FF",
    Macrophages = "#68A4E3FF",
    Monocytes = "#79D379FF",
    Myelocyte = "#CDCDCDFF",
    NK_cells = "#0038FF",
    Smooth_muscle_cells = "#70FF00",
    T_cells = "#FF3D00",
    Tissue_stem_cells = "#80FF00",
    AT1 = "#B8B8B8FF",
    AT2 = "#9632B8FF",
    Adventitial_fibroblasts = "#46B8DAFF",
    Alveolar_fibroblasts = "#90302DFF",
    Alveolar_macrophages = "#A66D04FF",
    Basal_resting = "#3E7E3EFF",
    CD4T_cells = "#7D7D7DFF",
    DC1 = "#6D1D87FF",
    EC_aerocyte_capillary = "#FF6E6AFF",
    EC_arterial = "#FFBB70FF",
    EC_general_capillary = "#68A4E3FF",
    EC_venous_pulmonary = "#79D379FF",
    Goblet = "#CDCDCDFF",
    Lymphatic_EC = "#FF005C",
    Macrophages2 = "#000AFF",
    Mast_cells = "#0066FF",
    Migratory_DCs = "#CC00FF",
    Monocytes2 = "#0038FF",
    Multiciliated = "#00FF85",
    Myofibroblasts = "#FF007A",
    NK_cells2 = "#FF0F00",
    Neutrophils = "#3300FF",
    Non_classical_monocytes = "#FF008A",
    Osteoblasts = "#00FF47",
    Pericytes = "#FF002E",
    Plasma_cells = "#00A3FF",
    SM_activated_stress_response = "#00FF0A"
)

for (item in seq_len(nrow(samples_for_validation))) {
    names <- samples_for_validation$names[item]
    species <- samples_for_validation$species[item]
    combine_sobject <-
        qs::qread(str_c("output/seurat_objects/validation/tumor_annotation/",
                        names, "_validated.qs")) %>%
        process_seurat()
    # add the scanbit metadata for mouse_obj
    if (names == "S0260_61_mouse") {
        combine_sobject <-
            combine_sobject %>%
            AddMetaData(metadata = scanbit_metadata %>%
                        filter(cell %in% colnames(combine_sobject)) %>%
                        distinct(cell, .keep_all = TRUE))
    }
    SCEVAN_metadata <-
        read_tsv(str_c("output/id_tumor/SCEVAN/",
                        names,
                        "_metadata.tsv")) %>%
        dplyr::filter(cell %in% colnames(combine_sobject)) %>%
        dplyr::distinct(cell, .keep_all = TRUE) %>%
        tibble::column_to_rownames("cell")
    combine_sobject <-
        combine_sobject %>%
        AddMetaData(metadata = SCEVAN_metadata)

    scATOMIC_metadata <-
        read_tsv(str_c("output/id_tumor/scATOMIC/",
                        names,
                        "_metadata.tsv")) %>%
        dplyr::filter(cell %in% colnames(combine_sobject)) %>%
        dplyr::distinct(cell, .keep_all = TRUE) %>%
        tibble::column_to_rownames("cell")

    combine_sobject <-
        combine_sobject %>%
        AddMetaData(metadata = scATOMIC_metadata)

    combine_sobject$scatomic_tumor_call <-
        ifelse(grepl("Cancer Cell$", combine_sobject$scATOMIC_pred),
                "Tumor",
                "Normal")
    combine_sobject$scevan_tumor_call <-
        ifelse(combine_sobject$scevan_tumor_call == "cancer_cells",
                "Tumor",
                "Normal")
    combine_sobject$copykat_tumor_call <-
        ifelse(is.na(combine_sobject$CNV_status), "Unknown",
            ifelse(combine_sobject$CNV_status == "aneuploid", "Tumor", "Normal"))

    combine_sobject$truth_metadata <-
        ifelse(combine_sobject$truth_metadata == "tumor",
                "Tumor",
                "Normal")
    combine_sobject$final_tumor_call <-
        ifelse(combine_sobject$final_tumor_call == "tumor",
                "Tumor",
                "Normal")
    diplot_list <- list()
    for (col in c("final_tumor_call","copykat_tumor_call","scevan_tumor_call",
                "scatomic_tumor_call","truth_metadata")) {
        diplot_list[[col]] <-
            DimPlot(combine_sobject,
                group.by = col,
                label = T,
                cols = c("Tumor" = "#D43F3AFF", "Normal" = "#EEA236FF",
                        "Unknown" = "#357EBDFF"),
                label.box = T) +
            coord_fixed() +
        theme(aspect.ratio=1) +
        theme_void() +
        theme(plot.title = element_text(hjust = 0.5))
    }
    panel_dim <-
        patchwork::wrap_plots(diplot_list$final_tumor_call,
                            diplot_list$copykat_tumor_call,
                            diplot_list$scevan_tumor_call,
                            diplot_list$scatomic_tumor_call,
                            diplot_list$truth_metadata,
                            ncol = 2) +
            patchwork::plot_annotation(title = names) +
        theme(plot.title = element_text(size = 15)) &
        theme(panel.border = element_rect(colour = "black", fill = NA, linewidth = 1))
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                names, "_dimplot_celltypes.png"),
            plot = panel_dim,
            width = 14,
            height = 21)

    combine_sobject$just_stroma_annot <-
        ifelse(combine_sobject$truth_metadata == "Tumor", "Tumor", combine_sobject$just_stroma_annot)
    #dimplot_better(combine_sobject, group_by = "scATOMIC_pred")
    # give me some kind of metric to see how well do the two annotations match
    metadata <-
        combine_sobject@meta.data %>%
        select(final_tumor_call, truth_metadata, #scanbit_tumor_call,
                copykat_tumor_call, scevan_tumor_call, scatomic_tumor_call,
                just_stroma_annot) %>%
        rownames_to_column("cell_id") %>%
        arrange(truth_metadata,
                just_stroma_annot,
                final_tumor_call,
                copykat_tumor_call,
                scevan_tumor_call,
                scatomic_tumor_call) %>%
        mutate(cell_id_number = row_number()) %>%
        rename(Truth = truth_metadata,
                AtlasCall = final_tumor_call,
                CellTypes = just_stroma_annot,
                CopyKAT = copykat_tumor_call,
                SCEVAN = scevan_tumor_call,
                scATOMIC = scatomic_tumor_call) %>%
        mutate(across(c(Truth,
                        AtlasCall,
                        CellTypes,
                        scATOMIC, 
                        SCEVAN, 
                        CopyKAT), ~replace_na(., "Unknown")))
    
    # with new celltypes 
    prep_metadata <-
        metadata %>%
        pivot_longer(cols = -c(cell_id, cell_id_number),
                names_to = "method",
                values_to = "call")
    # Set factor levels for method and call to control order in plot
    prep_metadata$method <-
        factor(prep_metadata$method,
                levels = c("Truth", "AtlasCall", "CopyKAT", "SCEVAN", "scATOMIC", "CellTypes"))
    # Automatically make levels from prep_metadata$call, preserving order and uniqueness
    levels_all <- prep_metadata %>% filter(method == "CellTypes") %>% pull(call) %>% unique()
    prep_metadata$call <-
        factor(prep_metadata$call,
              levels = c(levels_all, "Normal", "Unknown"))

    tile_plot_new <-
        ggplot(prep_metadata, aes(x = method, y = cell_id_number, fill = call)) +
            geom_tile() +
            scale_fill_manual(values = plot_cols_new) +
            theme_minimal() +
            labs(title = "Tumor annotation comparison",
                 x = "Annotation Method",
                 y = "Cell Index") +
            theme(
                axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid = element_blank(),
                plot.margin = margin(0, 0, 0, 0), # Remove extra space around plot
                plot.background = element_rect(fill = NA, color = NA),
                panel.spacing = unit(0, "pt"),
                panel.border = element_blank()
            ) +
            scale_y_reverse(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0)) +
            coord_cartesian(clip = "on")
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                names, "_tumor_w_celltypes.pdf"),
            plot = tile_plot_new,
            width = 14,
            height = 8)

    # make tile plot of the metadata
    prepared_metadata <-
        metadata %>%
         arrange(truth_metadata,
                final_tumor_call,
                copykat_tumor_call,
                scevan_tumor_call,
                scatomic_tumor_call) %>%
        select(cell_id, cell_id_number, Truth, AtlasCall, CopyKAT, SCEVAN, scATOMIC) %>%
        pivot_longer(cols = -c(cell_id, cell_id_number),
                names_to = "method",
                values_to = "call")
    # Set factor levels for method and call to control order in plot
    prepared_metadata$method <-
        factor(prepared_metadata$method,
                levels = c("Truth", "AtlasCall", "CopyKAT", "SCEVAN", "scATOMIC"))
    prepared_metadata$call <-
        factor(prepared_metadata$call,
              levels = c("Tumor", "Normal", "Unknown"))
    tile_plot <-
        ggplot(prepared_metadata, aes(x = method, y = cell_id_number, fill = call)) +
            geom_tile() +
            scale_fill_manual(values = c("Normal" = "#EEA236FF",
                                        "Tumor" = "#D43F3AFF",
                                        "Unknown" = "#357EBDFF")) +
            theme_minimal() +
            labs(title = "Tumor annotation comparison",
                 x = "Annotation Method",
                 y = "Cell Index") +
            theme(
                axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                panel.grid = element_blank(),
                plot.margin = margin(0, 0, 0, 0), # Remove extra space around plot
                plot.background = element_rect(fill = NA, color = NA),
                panel.spacing = unit(0, "pt"),
                panel.border = element_blank()
            ) +
            scale_y_reverse(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0)) +
            coord_cartesian(clip = "on")

    # Confusion matrices and accuracy
    # Confusion matrices and accuracy for FinalCall, CallAsWhole, SCEVAN, scATOMIC
    confusion_matrix_final <- table(metadata$Truth, metadata$AtlasCall)
    confusion_matrix_scevan <- table(metadata$Truth, metadata$SCEVAN)
    confusion_matrix_scatomic <- table(metadata$Truth, metadata$scATOMIC)
    confusion_matrix_copykat <- table(metadata$Truth, metadata$CopyKAT)
    #confusion_matrix_scanbit <- table(metadata$Truth, metadata$ScanBit)

    accuracy_final <- sum(diag(confusion_matrix_final)) / sum(confusion_matrix_final)
    accuracy_scevan <- sum(diag(confusion_matrix_scevan)) / sum(confusion_matrix_scevan)
    accuracy_scatomic <- sum(diag(confusion_matrix_scatomic)) / sum(confusion_matrix_scatomic)
    accuracy_copykat <- sum(diag(confusion_matrix_copykat)) / sum(confusion_matrix_copykat)
    #accuracy_scanbit <- sum(diag(confusion_matrix_scanbit)) / sum(confusion_matrix_scanbit)

    # Accuracy barplot
    accuracy_df <- data.frame(
        Method = factor(c("Truth", "AtlasCall", "CopyKAT", "SCEVAN", "scATOMIC"),
                        levels = c("Truth", "AtlasCall","CopyKAT", "SCEVAN", "scATOMIC")),
        Accuracy = c(1, accuracy_final, accuracy_copykat, accuracy_scevan, accuracy_scatomic)
    )
    accuracy_barplot <-
        ggplot(accuracy_df, aes(x = Method, y = Accuracy, fill = Method)) +
            geom_bar(stat = "identity", width = 0.7, show.legend = FALSE) +
            geom_text(aes(label = round(Accuracy, 3), y = Accuracy/2), color = "white", size = 4) +
            labs(title = "Accuracy of Tumor Calls", x = "Methods", y = "Accuracy") +
            theme_minimal() +
            theme(axis.text.x = element_text(angle = 0, hjust = 0.5, face = "bold"),
              axis.text.y = element_text(face = "bold"),
              panel.grid = element_blank(),
              panel.border = element_blank()) +
            scale_fill_manual(values = c("Truth" = "#A0522D", 
                         "AtlasCall" = "#D43F3AFF", 
                         "CopyKAT" = "#0072B2FF", 
                         "SCEVAN" = "#377EB8", 
                         "scATOMIC" = "#4DAF4A")) +
            ylim(0, 1.05) +
            scale_y_continuous(expand = c(0, 0)) +
            scale_x_discrete(expand = c(0, 0))

    # Confusion matrix plots
    confusion_list <- list(
        AtlasCall = list(tbl = confusion_matrix_final, acc = accuracy_final),
        #ScanBit = list(tbl = confusion_matrix_scanbit, acc = accuracy_scanbit),
        CopyKAT = list(tbl = confusion_matrix_copykat, acc = accuracy_copykat),
        SCEVAN = list(tbl = confusion_matrix_scevan, acc = accuracy_scevan),
        scATOMIC = list(tbl = confusion_matrix_scatomic, acc = accuracy_scatomic)
    )
    confusion_plots <-
        lapply(names(confusion_list), function(method) {
            tbl <- confusion_list[[method]]$tbl
            acc <- confusion_list[[method]]$acc
            df_tbl <- as.data.frame(as.table(tbl))
            colnames(df_tbl) <- c("Truth", "Prediction", "Freq")
            ggplot(df_tbl, aes(x = Prediction, y = Truth, fill = Freq)) +
                geom_tile(color = "white") +
                geom_text(aes(label = Freq), size = 2.5) +
                scale_fill_gradient(low = "#F0F0F0", high = "#D43F3AFF") +
                theme_minimal() +
                labs(title = paste0("Confusion Matrix: ", method,
                                   "\nAccuracy: ", round(acc, 3)),
                     x = "Predicted", y = "Truth") +
                theme(panel.grid = element_blank(),
                      plot.title = element_text(hjust = 0.5, size = 6, face = "bold"),
                      legend.position = "none",
                      axis.title.y = element_text(angle = 90),
                      axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 0.5))
        })
    confusion_combined <-
        patchwork::wrap_plots(confusion_plots, nrow = 1)

    # save the plot_grid
    all_plot <-
        cowplot::plot_grid(tile_plot,
                            #accuracy_barplot,
                            confusion_combined,
                            ncol = 1,
                            rel_heights = c(0.5, 0.2),
                            align = "v") +
            patchwork::plot_annotation(title = str_c(names, " Tumor ID by methods")) &
            theme(plot.title = element_text(size = 10))

    # save the confusion matrix plot
    if (!dir.exists("output/figures/validation/tumor_annotation_method/")) {
        dir.create("output/figures/validation/tumor_annotation_method/", recursive = TRUE)
    }
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                names, "_tumor_annotation_method.png"),
            plot = all_plot,
            width = 7,
            height = 8)
    ggsave(str_c("output/figures/validation/tumor_annotation_method/",
                names, "_tumor_annotation_method.pdf"),
            plot = all_plot,
            width = 7,
            height = 8)

}



```