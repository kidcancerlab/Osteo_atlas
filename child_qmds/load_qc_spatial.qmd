## Loading in Spatial Data

This analysis will go along with the cellchat analysis. I'll weigh the interactions by the amount of cells in proximity to each other.

This will also serve as practice for me to get more familiar with analyzing single-spot spatial transcriptomics.

```{r load-spatial}
spatial_path <- "/home/gdrobertslab/lab/ExternalData/McEachron_lab/spatial_data/rdata/"
spatial_list <-
    sapply(paste0(spatial_path, list.files(spatial_path)), readr::read_rds)
names(spatial_list) <- str_remove(string = list.files(spatial_path), pattern = ".rds")

system("mkdir output/spatial_pathway_analysis")

#Remove pathway columns in metadata
for (ob_name in names(spatial_list)) {
    x <- spatial_list[[ob_name]]
    #first extract pathway scores from metadata
    pathway_metadata <- x@meta.data[, str_detect(colnames(x@meta.data),
                                    "^GOBP|^REACTOME|^HALLMARK")]
    # write.table(pathway_metadata,
    #             file = paste0("output/spatial_pathway_analysis/",
    #                           ob_name,
    #                           ".tsv"),
    #             sep = "\t")

    x@meta.data <- x@meta.data[, !str_detect(colnames(x@meta.data),
                                             "^GOBP|^REACTOME|^HALLMARK")]
    x$sample_name <- ob_name
    spatial_list[[ob_name]] <- x
}

#plot just the h&e slides
he_plts <- lapply(names(spatial_list), function(x) {
    p <- SpatialDimPlot(spatial_list[[x]], pt.size.factor=0) +
        NoLegend() +
        labs(title = x)
    png(paste0("figures/spatial/h_and_e_", x, ".png"))
    print(p)
    dev.off()
    return(p)
})

png("figures/spatial/h_and_e_all.png", width = 800, height = 500)
grid.arrange(grobs = he_plts, ncol = 4)
dev.off()
```

## Label Cell Types Using Spacexr

We'll be using RCTD on full mode to perform cell-type annotation 

### Create Reference Object

I need to create a reference object. This object is created using the RCTD constructor function, which requires a counts matrix, cell types, and nUMI

```{r}
yogi_path <- "/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/"

patient_mets <- qs::qread(paste0(yogi_path, "final_tumor_vs_stroma/patient_mets.qs"))

dimplot_better(patient_mets, group = "Ann_Level2", raster = FALSE)

cell_types <- unique(patient_mets$Ann_Level2)

#Ann_level3 was too granular, going to try using Ann_Level2
spacexr_reference <-
    spacexr::Reference(GetAssayData(patient_mets, layer = "counts"),
                       as.factor(patient_mets$Ann_Level2),
                       n_max_cells = 2000)

# Create level 1 reference too
spacexr_level1 <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level1),
        n_max_cells = 2000
    )

# level 3 reference
spacexr3 <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level3),
        n_max_cells = 2000
    )

level1_types <- unique(patient_mets$Ann_Level1)
```


### Run RCTD on Spatial Data

```{r}
#first I'm going to just use spacexr to add scores to each spot for the cell types in our reference
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(my_data,
                                     spacexr_reference,
                                     max_cores = 6,
                                     UMI_min = 3,
                                     counts_MIN = 0, 
                                     UMI_max = 900000000,
                                     CELL_MIN_INSTANCE = 0)
    rctd_out <- spacexr::run.RCTD(rctd_obj, doublet_mode = "full")
    qs::qsave(rctd_out, paste0("output/spatial_objects/spacexr_", ob_name, ".qs"))

    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level2_annotations.qs")

# do it at level 1
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(my_data,
                                     spacexr_level1,
                                     max_cores = 6,
                                     UMI_min = 3,
                                     counts_MIN = 0, 
                                     UMI_max = 900000000,
                                     CELL_MIN_INSTANCE = 0)
    rctd_out <- spacexr::run.RCTD(rctd_obj, doublet_mode = "full")
    qs::qsave(rctd_out, paste0("output/spatial_objects/spacexr_", ob_name, ".qs"))

    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level1_annotations.qs")


# going to do it at level 3, specifying multi mode, though
rctd_res <- list()
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(
        my_data,                     
        spacexr3,
        max_cores = 6,
        UMI_min = 3,
        counts_MIN = 0, 
        UMI_max = 900000000,
        CELL_MIN_INSTANCE = 0
    )
    rctd_out <- spacexr::run.RCTD(
        rctd_obj,
        doublet_mode = "doublet"
    )
    rctd_res[[ob_name]] <- rctd_out
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level3_annotations.qs")

```

## Plot Tumor Cell Scores

The first sanity check we can perform is looking at how the tumor cell types' feature scores look compared to the H&E slides.

```{r plot-tumor-scores}
size.factors <- list("OS1_Seurat" = 1500,
                     "OS2_Seurat" = 1400,
                     "OS3_Seurat" = 2700,
                     "OS4_Seurat" = 1700,
                     "OS5_Seurat" = 650,
                     "OS6_Seurat" = 3000,
                     "OS7_Seurat" = 2500,
                     "OS8_Seurat" = 1300)

cell_types2 <- unique(patient_mets$Ann_Level2)
for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp$Tumor_Cumulative <- tmp$Basal_Progenitor +
                             tmp$Fibrogenic +
                             tmp$Interactive +
                             tmp$MP_Progenitor +
                             tmp$Proliferative +
                             tmp$Stressed
    
    pdf(paste0("figures/spatial/spacexr/", ob, "_level2.pdf"), height = 4, width = 4)
    print(
        SpatialDimPlot(
            tmp,
            pt.size.factor = 0) + NoLegend()
    )
    print(
        SpatialFeaturePlot(
            tmp,
            features = "Tumor_Cumulative",
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    )
    for (ct in cell_types2) {
        print(
            SpatialFeaturePlot(
                tmp,
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
        )
    }
    dev.off()
}

png("figures/spatial/all_h_and_e_slides.png", height = 600, width = 1000)
he_list <-lapply(names(spatial_list), function(x) {
    SpatialDimPlot(spatial_list[[x]], pt.size.factor = 0) +
        NoLegend() +
        ggtitle(x)
})
grid.arrange(grobs = he_list, nrow = 2)
dev.off()
```

## STdeconvolve

Troy likes this method so I'm going to give it a go.

### Fit Models

```{r stdeconvolve}
library(STdeconvolve)

all_ldas <- list()
parallel::mclapply(names(spatial_list), function(sid) {
    ob <- spatial_list[[sid]]
    pos <- GetTissueCoordinates(ob)
    counts <- GetAssayData(ob, layer = "counts")
    # feature select
    corpus <- restrictCorpus(
        counts,
        removeAbove = 1.0,
        removeBelow = 0.05,
        alpha = 0.05,
        plot = FALSE,
        verbose = TRUE
    )
    lda_mod <- fitLDA(
        t(as.matrix(corpus)),
        Ks = seq(5, 20, by = 1),
        perc.rare.thresh = 0.05,
        plot = FALSE,
        ncores = 8
    )
    all_ldas[[sid]] <- lda_mod
    qs::qsave(
        lda_mod,
        paste0("output/STdeconvolve/", sid, "_lda.qs"))
    },
    mc.cores = 6
)

qs::qsave(all_ldas, "output/STdeconvolve/all_ldas.qs")
```

### Read back in Models

```{r}
all_ldas <- list()
for (ob in names(spatial_list)) {
    all_ldas[[ob]] <-
        qs::qread(
            paste0("output/STdeconvolve/", ob, "_lda.qs")
        )
}

for (ob in names(all_ldas)) {
    tmp_mod <- all_ldas[[ob]]
    png(paste0("output/STdeconvolve/figures/bias_variance_", ob, ".png"))
    perplexityPlot(tmp_mod)
    dev.off()
}
```

### Pick Optimal Models

I'm not sure which optimization procedure I should use, so I'm going to analyze using both methods.

```{r}
# minimizing perplexity
min_lda <- lapply(all_ldas, optimalModel, opt = "min")
min_lda

# knee point of perplexity and # of cell types w < 5% of all cells
# essentially point that minimizes bias-variance trade-off
kneed_lda <- lapply(all_ldas, optimalModel, opt = "kneed")
kneed_lda
```

As we can see, the kneed models have a lot more topics than the minimized_perplexity group.

### Visualize Topics

```{r}
# create different radii based on spatial object
r_vals <- list(
    "OS1_Seurat" = 2,
    "OS2_Seurat" = 2,
    "OS3_Seurat" = 1.5,
    "OS4_Seurat" = 2,
    "OS5_Seurat" = 1.5,
    "OS6_Seurat" = 1.5,
    "OS7_Seurat" = 1.5,
    "OS8_Seurat" = 2
)

# Following along with their vignette,using patient mets instead of mOB
patient_mets <- qs::qread("/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")

pdf("output/STdeconvolve/figures/all_sample_correlation.pdf")
for (ob in names(spatial_list)) {
    s_obj <- spatial_list[[ob]]
    cor_plt <- make_cor_plt(kneed_lda[[ob]], s_obj)
    print(cor_plt)
}
dev.off()

pdf("output/STdeconvolve/figures/all_sample_topics.pdf", height = 3, width = 4)
for (ob in names(spatial_list)) {
    s_obj <- spatial_list[[ob]]
    # get tissue coordinates and adjust so they match the h&e slide
    pos <- GetTissueCoordinates(s_obj)
    colnames(pos) <- c("y", "x")
    pos$y <- -pos$y
    # get beta and theta from model
    beta_theta <-
        getBetaTheta(kneed_lda[[ob]], perc.filt = 0.05, betaScale = 1000)
    print(
        vizAllTopics(
            beta_theta$theta,
            pos = pos,
            r = r_vals[[ob]]) +
            ggtitle(label = paste(ob, "Deconvolution Topics")) |
        SpatialDimPlot(s_obj, pt.size.factor = 0) +
            ggtitle(label = ob)
    )
}
dev.off()
```

### Topic-Based GSEA

I'm also going to try running GSEA on 

```{r}
Idents(patient_mets) <- patient_mets$Ann_Level2
ref_degs <- FindAllMarkers(
    patient_mets,
    only.pos = TRUE,
    min.pct = 0.25
)
write.table(
    ref_degs,
    "output/degs/ann_level2_degs.tsv",
    sep = "\t",
    row.names = TRUE)

# for fuse with STdeconvolve, I need a list of marker genes for each cell type
# We'll limit things to the top 200 genes for each cell type
ref_gene_set <- list()
for (ct in unique(ref_degs$cluster)) {
    tmp_degs <- subset(
        ref_degs,
        cluster == ct &
        p_val_adj < 0.05 &
        avg_log2FC > 1
        ) %>%
        arrange(desc(avg_log2FC))
    ref_gene_set[[ct]] <- rownames(tmp_degs)
}

# going to try this with the kneed-optimized models first
kneed_gsea <- list()
for (ob in names(spatial_list)) {
    mod_res <- getBetaTheta(
        kneed_lda[[ob]],
        perc.filt = 0.05,
        betaScale = 1000
        )
    kneed_gsea[[ob]] <-
        annotateCellTypesGSEA(
            beta = mod_res$beta,
            gset = ref_gene_set,
            qval = 0.05
        )
}

lapply(kneed_gsea, function(x) {
    print(x$predictions)
})
```

I really don't like this method of annotating. Perhaps it's an issue with the data type and the inherent heterogeneity of OS tumor samples, but very few topics get annotated as any particular cell type. Furthermore, I obtain different annotations when I restrict gene sets to the top 200 genes as determined by log2FC

### Look at Cell Types of Interest

I think for the time being, I'm better off sticking with the spacexr results, since they give an actual prediction (maybe?).

Right now I'm interested in module

```{r}
# read in dataset with fibrogenic tams
myeloid <- qs::qread(
    "/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/stromal_subtypes/patient_mets_normal_cells/Immune_Myeloid.qs"
)


# get degs for each cell type
Idents(myeloid) <- myeloid$Ann_Level3
myeloid_degs <- FindAllMarkers(
    myeloid,
    min.pct = 0.1,
    only.pos = TRUE
)

myeloid_modules <- 
    subset(myeloid_degs, avg_log2FC > 1 & p_val_adj < 0.05) %>%
    group_by(cluster) %>%
    dplyr::select(gene) %>%
    split(f = .$cluster)
myeloid_modules <- lapply(myeloid_modules, function(x) {
    x$gene
})

spatial_list <- lapply(
    spatial_list,
    AddModuleScore,
    features = myeloid_modules,
    name = "myeloid"
)

# have descriptive names for our modules
descriptive_modules <- 
    setNames(paste0("myeloid", 1:13), paste0("mod_score_", names(myeloid_modules)))
# only include any kind of TAMs
tam_modules <- descriptive_modules[grep("TAMs", names(descriptive_modules))]

# update names of our metadata columns and make figures
for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp@meta.data <- tmp@meta.data %>%
        rename(any_of(descriptive_modules))
    plts <- lapply(names(tam_modules), function(mod) {
        SpatialFeaturePlot(
            tmp,
            features = mod,
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    })
    h_e <- SpatialDimPlot(tmp, pt.size.factor = 0) + NoLegend()
    plts[["H&E"]] <- h_e

    png(
        paste0("figures/spatial/module_scores/myeloid_", ob, ".png"),
        width = 1500,
        height = 1500,
    )
    gridExtra::grid.arrange(grobs = plts, ncol = 3)
    dev.off()
}

spatial_list <- lapply(spatial_list, function(ob) {
    ob@meta.data <- ob@meta.data %>%
        rename(any_of(descriptive_modules))
})
```

```{r}
# I want to try this, but calculating the degs from the whole object first
# adding myeloid annotations to patient mets, perhaps we won't see as many 
patient_mets@meta.data[colnames(myeloid), ]$Ann_Level3 <- myeloid$Ann_Level3
Idents(patient_mets) <- patient_mets$Ann_Level3
full_myeloid_mods <- list()
for (ct in names(tam_modules)) {
    ct <- str_remove(ct, "mod_score_")
    print(ct)
    tmp <- FindMarkers(
        patient_mets,
        ident.1 = ct,
        max.cells.per.ident = 2000,
        min.pct = 0.1,
        only.pos = TRUE) %>%
        subset(p_val_adj < 0.05 & avg_log2FC > 1)
    full_myeloid_mods[[ct]] <- rownames(tmp)
}


```
