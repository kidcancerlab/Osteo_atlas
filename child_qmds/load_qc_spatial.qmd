## Loading in Spatial Data

This analysis will go along with the cellchat analysis. I'll weigh the interactions by the amount of cells in proximity to each other.

This will also serve as practice for me to get more familiar with analyzing single-spot spatial transcriptomics.

```{r load-spatial}
spatial_path <- "/home/gdrobertslab/lab/ExternalData/McEachron_lab/spatial_data/rdata/"
spatial_list <-
    sapply(paste0(spatial_path, list.files(spatial_path)), readr::read_rds)
names(spatial_list) <- str_remove(string = list.files(spatial_path), pattern = ".rds")

system("mkdir output/spatial_pathway_analysis")

#Remove pathway columns in metadata
for (ob_name in names(spatial_list)) {
    x <- spatial_list[[ob_name]]
    #first extract pathway scores from metadata
    pathway_metadata <- x@meta.data[, str_detect(colnames(x@meta.data),
                                    "^GOBP|^REACTOME|^HALLMARK")]
    # write.table(pathway_metadata,
    #             file = paste0("output/spatial_pathway_analysis/",
    #                           ob_name,
    #                           ".tsv"),
    #             sep = "\t")

    x@meta.data <- x@meta.data[, !str_detect(colnames(x@meta.data),
                                             "^GOBP|^REACTOME|^HALLMARK")]
    x$sample_name <- ob_name
    spatial_list[[ob_name]] <- x
}

#plot just the h&e slides
he_plts <- lapply(names(spatial_list), function(x) {
    p <- SpatialDimPlot(spatial_list[[x]], pt.size.factor=0) +
        NoLegend() +
        labs(title = x)
    png(paste0("output/figures/spatial/h_and_e_", x, ".png"))
    print(p)
    dev.off()
    return(p)
})

png("output/figures/spatial/h_and_e_all.png", width = 800, height = 500)
grid.arrange(grobs = he_plts, ncol = 4)
dev.off()

qs::qsave(spatial_list, "output/spatial_objects/spatial_list_unannotated.qs")
```

## Label Cell Types Using Spacexr

We'll be using RCTD on full mode to perform cell-type annotation 

### Read in Atlas Object Object

I need to create a reference object. This object is created using the RCTD constructor function, which requires a counts matrix, cell types, and nUMI

```{r}
yogi_path <- "/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/"

patient_mets <- qs::qread(paste0(yogi_path, "final_tumor_vs_stroma/patient_mets.qs"))
patient_mets$Ann_Level1 <- ifelse(
    patient_mets$Ann_Level1 == "Alv_Macrophages",
    "Immune_Myeloid",
    patient_mets$Ann_Level1
)

dimplot_better(patient_mets, group = c(paste0("Ann_Level", 1:3)), raster = FALSE)
```

### Run RCTD on Spatial Data

#### Level 1

```{r}
level1_ref <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level1),
        n_max_cells = 2000
    )

spatial_list <- qs::qread("output/spatial_objects/spatial_list_unannotated.qs")
# do it at level 1
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    run_rctd(sp_ob, ref = level1_ref)
    qs::qsave(rctd_out, paste0("output/spacexr/rctd_level1_", ob_name, ".qs"))

    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level1_annotations.qs")
rm("spatial_list")
```

#### Level 2

```{r}
level2_ref <- spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level2),
        n_max_cells = 2000
)

spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
#first I'm going to just use spacexr to add scores to each spot for the cell types in our reference
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = level2_ref)
    qs::qsave(rctd_out, paste0("output/spacexr/rctd_level2_", ob_name, ".qs"))
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level2_annotations.qs")
rm("spatial_list")
```

#### Level 3

```{r}
level3_ref <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level3),
        n_max_cells = 2000
    )

spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
# going to do it at level 3, specifying multi mode, though
spacexr_res <- parallel::mclapply(names(spatial_list), function(ob_name) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = level3_ref)
    qs::qsave(rctd_out, paste0("output/spacexr/rctd_level3_", ob_name, ".qs"))
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    return(AddMetaData(sp_ob, norm_weights))
    },
    mc.cores = parallelly::availableCores(),
    mc.preschedule = FALSE
    )
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level3_annotations.qs")
rm("spatial_list")
```

#### Myeloid and Tumor Focus

This may be cheating... but I'm wondering if we can perform deconvolution with a reference that only has level 3 granularity for the myeloid and tumor populations.

```{r}
table(patient_mets$Ann_Level1)
# we'll make a new column in our object called myeloid_tumor
patient_mets@meta.data <- patient_mets@meta.data %>%
    mutate(myeloid_tumor = recode(
        Ann_Level1,
        "Alv_Macrophages" = "Alv_Macrophages",
        "Epithelial_Endothelial" = "Epithelial_Endothelial",
        "Immune_Lymphoid" = "Immune_Lymphoid",
        "Mesenchymal" = "Mesenchymal",
        "Immune_Myeloid" = Ann_Level3,
        "Tumor" = Ann_Level3
    ))

dimplot_better(patient_mets, group = c("myeloid_tumor", "Ann_Level3"), raster = FALSE)

myeloid_tumor_ref <- spacexr::Reference(
    GetAssayData(patient_mets, layer = "counts"),
    as.factor(patient_mets$myeloid_tumor),
    n_max_cells = 2000
)

spatial_list <- parallel::mclapply(names(spatial_list), function(ob_name) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = myeloid_tumor_ref)
    qs::qsave(
        rctd_out,
        paste0("output/spacexr/rctd_myeloid_tumor_", ob_name, ".qs")
    )
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    return(AddMetaData(sp_ob, norm_weights))
    },
    mc.cores = parallelly::availableCores(),
    mc.preschedule = FALSE
    )

qs::qsave(spatial_list, "output/spatial_objects/spatial_list_myeloid_tumor.qs")
rm("spatial_list")
```


## Plot Deconvolution Scores

The first sanity check we can perform is looking at how the tumor cell types' feature scores look compared to the H&E slides.

### Ann_Level2

```{r plot-tumor-scores}
size.factors <- list("OS1_Seurat" = 1500,
                     "OS2_Seurat" = 1400,
                     "OS3_Seurat" = 2700,
                     "OS4_Seurat" = 1700,
                     "OS5_Seurat" = 650,
                     "OS6_Seurat" = 3000,
                     "OS7_Seurat" = 2500,
                     "OS8_Seurat" = 1300)

cell_types2 <- unique(patient_mets$Ann_Level2)
for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp$Tumor_Cumulative <- tmp$Basal_Progenitor +
                             tmp$Fibrogenic +
                             tmp$Interactive +
                             tmp$MP_Progenitor +
                             tmp$Proliferative +
                             tmp$Stressed
    
    pdf(paste0("output/figures/spatial/spacexr/spacexr_", ob, "_level2.pdf"), height = 4, width = 4)
    print(
        SpatialDimPlot(
            tmp,
            pt.size.factor = 0) + NoLegend()
    )
    print(
        SpatialFeaturePlot(
            tmp,
            features = "Tumor_Cumulative",
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    )
    for (ct in cell_types2) {
        print(
            SpatialFeaturePlot(
                tmp,
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
        )
    }
    dev.off()
}
```

### Ann_Level3

```{r}
cell_types3 <- unique(patient_mets$Ann_Level3)
for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp$Tumor_Cumulative <- tmp$Basal_Progenitor +
                             tmp$Fibrogenic +
                             tmp$Interactive +
                             tmp$MP_Progenitor +
                             tmp$Proliferative +
                             tmp$Stressed
    
    pdf(paste0("output/figures/spatial/spacexr/spacexr_", ob, "_level3.pdf"), height = 4, width = 4)
    print(
        SpatialDimPlot(
            tmp,
            pt.size.factor = 0) + NoLegend()
    )
    print(
        SpatialFeaturePlot(
            tmp,
            features = "Tumor_Cumulative",
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    )
    for (ct in cell_types3) {
        print(
            SpatialFeaturePlot(
                tmp,
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
        )
    }
    dev.off()
}
```

### Myeloid_Tumor

This is using the deconvolution results from using the myeloid_tumor reference

```{r}
cell_types_myeloid_tumor <- unique(patient_mets$myeloid_tumor)
for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp$Tumor_Cumulative <- tmp$Basal_Progenitor +
                             tmp$Fibrogenic +
                             tmp$Interactive +
                             tmp$MP_Progenitor +
                             tmp$Proliferative +
                             tmp$Stressed
    
    pdf(paste0("output/figures/spatial/spacexr/spacexr_", ob, "_myeloid_tumor.pdf"), height = 4, width = 4)
    print(
        SpatialDimPlot(
            tmp,
            pt.size.factor = 0) + NoLegend()
    )
    print(
        SpatialFeaturePlot(
            tmp,
            features = "Tumor_Cumulative",
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    )
    for (ct in sort(cell_types_myeloid_tumor)) {
        print(
            SpatialFeaturePlot(
                tmp,
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
        )
    }
    dev.off()
}

pdf("output/figures/spatial/spacexr/myeloid_tumor_all_samples.pdf", width = 35)
for (ct in sort(cell_types_myeloid_tumor)) {
    plt <- lapply(names(spatial_list), function(ob) {
        SpatialFeaturePlot(
            spatial_list[[ob]],
            features = ct,
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    }
    )
    print(
        gridExtra::grid.arrange(grobs = plt, nrow = 1)
    )
}
dev.off()
```

### Different Granularities

Inspired by the section above using the myeloid_tumor reference, I'm going to repeat this exercise, but keep Ann_Level2 instead of Ann_Level1. Likewise, I'm going to repeat it for each Ann_Level1 compartment

```{r}
# figure out how many cell types will be in each
ref_list <- list()
for (ct in unique(patient_mets$Ann_Level1)) {
    tmp <- patient_mets
    tmp$new_anns <- ifelse(
        patient_mets$Ann_Level1 == ct,
        patient_mets$Ann_Level3,
        patient_mets$Ann_Level2
    )
    ref_list[[ct]] <- spacexr::Reference(
        GetAssayData(tmp, layer = "counts"),
        as.factor(tmp$new_anns),
        n_max_cells = 2000
    )
}

dir.create("output/spacexr/granular_references/")

rctd_res <- list()
for (ref in names(ref_list)) {
    spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
    rctd_res[[ref]] <- mclapply(
        spatial_list,
        run_rctd,
        ref = ref_list[[ref]],
        mc.cores = parallelly::availableCores(),
        mc.preschedule = FALSE
    )
    qs::qsave(
        rctd_res[[ref]],
        paste0("output/spacexr/granular_references/", ref, "_level3_rctd.qs"))
}


```


## Make Panel Plots

I want to make a figure where each column is a tumor type, and each row is a sample.

### Tumor Panel Plots

```{r}
spatial_list <- qs::qread("output/spatial_objects/spatial_list_level3_annotations.qs")
tumor_types <- c(
    "Basal_Progenitor",
    "Fibrogenic",
    "Interactive",
    "MP_Progenitor",
    "Proliferative",
    "Stressed")

pdf("output/figures/spatial/spacexr/tumor_level_3.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        max_score = max(spatial_list[[ob]]@meta.data[, ct])
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            # ) +
            # ggplot2::scale_fill_continuous(
            #     low = "#2D577FFF",
            #     high = "#D43F3AFF",
            #     # high = "#D43F3AFF"
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()


spatial_list <- qs::qread("output/spatial_objects/spatial_list_level2_annotations.qs")
pdf("output/figures/spatial/spacexr/tumor_level2.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()


spatial_list <- qs::qread("output/spatial_objects/spatial_list_myeloid_tumor.qs")
pdf("output/figures/spatial/spacexr/tumor_myeloid_tumor.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```


### TAM Panel Plots

This is using the Ann_Level3 deconvolution results

```{r}
tam_types <- grep("TAM", colnames(spatial_list[[1]]@meta.data), value = TRUE)

pdf("output/figures/spatial/spacexr/tam_subpopulations.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (tam in tam_types) {
        plts[[tam]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = tam,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```

This is using the myeloid_tumor deconvolution results

```{r}
tam_types <- grep("TAM", colnames(spatial_list[[1]]@meta.data), value = TRUE)

pdf("output/figures/spatial/spacexr/tam_subpopulations_myeloid_tumor.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (tam in tam_types) {
        plts[[tam]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = tam,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```