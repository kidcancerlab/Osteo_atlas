## Loading in Spatial Data

This analysis will go along with the cellchat analysis. I'll weigh the interactions by the amount of cells in proximity to each other.

This will also serve as practice for me to get more familiar with analyzing single-spot spatial transcriptomics.

```{r load-spatial}
spatial_path <- "/home/gdrobertslab/lab/ExternalData/McEachron_lab/spatial_data/rdata/"
spatial_list <-
    sapply(paste0(spatial_path, list.files(spatial_path)), readr::read_rds)
names(spatial_list) <- str_remove(string = list.files(spatial_path), pattern = ".rds")

system("mkdir output/spatial_pathway_analysis")

#Remove pathway columns in metadata
for (ob_name in names(spatial_list)) {
    x <- spatial_list[[ob_name]]
    #first extract pathway scores from metadata
    pathway_metadata <- x@meta.data[, str_detect(colnames(x@meta.data),
                                    "^GOBP|^REACTOME|^HALLMARK")]
    # write.table(pathway_metadata,
    #             file = paste0("output/spatial_pathway_analysis/",
    #                           ob_name,
    #                           ".tsv"),
    #             sep = "\t")

    x@meta.data <- x@meta.data[, !str_detect(colnames(x@meta.data),
                                             "^GOBP|^REACTOME|^HALLMARK")]
    x$sample_name <- ob_name
    spatial_list[[ob_name]] <- x
}

#plot just the h&e slides
he_plts <- lapply(names(spatial_list), function(x) {
    p <- SpatialDimPlot(spatial_list[[x]], pt.size.factor=0) +
        NoLegend() +
        labs(title = x)
    png(paste0("figures/spatial/h_and_e_", x, ".png"))
    print(p)
    dev.off()
    return(p)
})

png("figures/spatial/h_and_e_all.png", width = 800, height = 500)
grid.arrange(grobs = he_plts, ncol = 4)
dev.off()
```

## Label Cell Types Using Spacexr

We'll be using RCTD on full mode to perform cell-type annotation 

### Create Reference Object

I need to create a reference object. This object is created using the RCTD constructor function, which requires a counts matrix, cell types, and nUMI

```{r}
yogi_path <- "/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/"

patient_mets <- qs::qread(paste0(yogi_path, "final_tumor_vs_stroma/patient_mets.qs"))

dimplot_better(patient_mets, group = "Ann_Level2", raster = FALSE)

cell_types <- unique(patient_mets$Ann_Level2)

#Ann_level3 was too granular, going to try using Ann_Level2
spacexr_reference <-
    spacexr::Reference(GetAssayData(patient_mets, layer = "counts"),
                       as.factor(patient_mets$Ann_Level2),
                       n_max_cells = 2000)
```

### Run RCTD on Spatial Data

```{r}
#first I'm going to just use spacexr to add scores to each spot for the cell types in our reference
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(my_data,
                                     spacexr_reference,
                                     max_cores = 6,
                                     UMI_min = 3,
                                     counts_MIN = 0, 
                                     UMI_max = 900000000,
                                     CELL_MIN_INSTANCE = 0)
    rctd_out <- spacexr::run.RCTD(rctd_obj, doublet_mode = "full")
    qs::qsave(rctd_out, paste0("output/spatial_objects/spacexr_", ob_name, ".qs"))

    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level2_annotations.qs")
```

## Plot Tumor Cell Scores

The first sanity check we can perform is looking at how the tumor cell types' feature scores look compared to the H&E slides.

```{r plot-tumor-scores}
size.factors <- list("OS1_Seurat" = 1500,
                     "OS2_Seurat" = 1400,
                     "OS3_Seurat" = 2700,
                     "OS4_Seurat" = 1700,
                     "OS5_Seurat" = 650,
                     "OS6_Seurat" = 3000,
                     "OS7_Seurat" = 2500,
                     "OS8_Seurat" = 1300)

for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp$Tumor_Cumulative <- tmp$Tumor_Fibrogenic +
                             tmp$Tumor_Apoptosis +
                             tmp$Tumor_Interactive +
                             tmp$Tumor_Progenitor +
                             tmp$Tumor_Proliferative +
                             tmp$Tumor_Synthetic
    plot_list <- list("H&E" = SpatialDimPlot(tmp,
                                             pt.size.factor = 0) + NoLegend())
    tumor_feats <- grep("Tumor", colnames(tmp@meta.data), value = TRUE)

    tumor_plts <- lapply(tumor_feats, function(x) {
        SpatialFeaturePlot(tmp,
                       features = x,
                       pt.size.factor = size.factors[[ob]],
                       image.alpha = 0)
    })
    names(tumor_plts) <- tumor_feats
    plot_list <- c(plot_list, tumor_plts)
    
    #create matrix for ideal figure arrangement
    layout <- matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8),
                            nrow = 2)
    png(paste0("figures/spatial/tumor_scores", ob, ".png"), res = 400, width = 6000, height = 3000)
    grid.arrange(grobs = plot_list,
                 nrow = 2,
                 layout_matrix = layout,
                 top = grid::textGrob(ob))
    dev.off()
    #update spatial_list with object containing Tumor_Cumulative
    spatial_list[[ob]] <- tmp
}

png("figures/spatial/all_h_and_e_slides.png", height = 600, width = 1000)
he_list <-lapply(names(spatial_list), function(x) {
    SpatialDimPlot(spatial_list[[x]], pt.size.factor = 0) +
        NoLegend() +
        ggtitle(x)
})
grid.arrange(grobs = he_list, nrow = 2)
dev.off()
```

## Try STdeconvolve

Troy likes this method so I'm going to give it a go.


```{r stdeconvolve}
library(STdeconvolve)
all_ldas <- list()
for (sid in names(spatial_list)) {
    ob <- spatial_list[[sid]]
    pos <- GetTissueCoordinates(ob)
    counts <- GetAssayData(ob, layer = "counts")
    # feature select for genes
    corpus <- restrictCorpus(
        counts,
        removeAbove = 1.0,
        removeBelow = 0.05,
        alpha = 0.05,
        plot = FALSE,
        verbose = TRUE
    )
    # fit LDA models for
    all_ldas[[sid]] <- fitLDA(
        t(as.matrix(corpus)),
        Ks = seq(2, 15, by = 1),
        perc.rare.thresh = 0.05,
        plot = TRUE,
        verbose = TRUE
        )
}


all_ldas <- parallel::mclapply(spatial_list, function(ob) {
    pos <- GetTissueCoordinates(ob)
    counts <- GetAssayData(ob, layer = "counts")
    # feature select
    corpus <- restrictCorpus(
        counts,
        removeAbove = 1.0,
        removeBelow = 0.05,
        alpha = 0.05,
        plot = FALSE,
        verbose = TRUE
    )
    fitLDA(
        t(as.matrix(corpus)),
        Ks = seq(2, 15, by = 1),
        perc.rare.thresh = 0.05,
        plot = TRUE
    )
    },
    mc.cores = parallelly::availableCores()
)

qs::qsave(all_ldas, "output/STdeconvolve/all_ldas.qs")
```

### Looking at OS1

```{r}
os1 <- spatial_list[[1]]
pos <- GetTissueCoordinates(os1)
colnames(pos) <- c("x", "y")

# using model from loop above
optLDA <- opt_ldas[["OS1_Seurat"]]

## extract deconvolved cell-type proportions (theta) and transcriptional profiles (beta)
results <- getBetaTheta(optLDA, perc.filt = 0.05, betaScale = 1000)
names(results)
dim(results[["theta"]])

theta <- results$theta
beta <- results$beta

#visualize deconvolved cell type props
vizAllTopics(theta, pos, r = 2) | SpatialFeaturePlot(os1, c("Tumor_Apoptosis", "Tumor_Fibrogenic", "Tumor_Interactive", "Tumor_Progenitor", "Tumor_Proliferative", "Tumor_Synthetic"), pt.size.factor = 1200, image.alpha = 0)
```

This only identified 3 topics in our spatial data, and it did a good job of separating the tumor from stroma. However, it only labelled 1 total stromal cell type, which is kinda low resolution. I wonder if allowing more topics would produce more distinct stromal populations.