## Loading in Spatial Data

This analysis will go along with the cellchat analysis. I'll weigh the interactions by the amount of cells in proximity to each other.

This will also serve as practice for me to get more familiar with analyzing single-spot spatial transcriptomics.

```{r load-spatial}
spatial_path <- "/home/gdrobertslab/lab/ExternalData/McEachron_lab/spatial_data/rdata/"
spatial_list <-
    sapply(paste0(spatial_path, list.files(spatial_path)), readr::read_rds)
names(spatial_list) <- str_remove(string = list.files(spatial_path), pattern = ".rds")

system("mkdir output/spatial_pathway_analysis")

#Remove pathway columns in metadata
for (ob_name in names(spatial_list)) {
    x <- spatial_list[[ob_name]]
    #first extract pathway scores from metadata
    pathway_metadata <- x@meta.data[, str_detect(colnames(x@meta.data),
                                    "^GOBP|^REACTOME|^HALLMARK")]
    # write.table(pathway_metadata,
    #             file = paste0("output/spatial_pathway_analysis/",
    #                           ob_name,
    #                           ".tsv"),
    #             sep = "\t")

    x@meta.data <- x@meta.data[, !str_detect(colnames(x@meta.data),
                                             "^GOBP|^REACTOME|^HALLMARK")]
    x$sample_name <- ob_name
    spatial_list[[ob_name]] <- x
}

#plot just the h&e slides
he_plts <- lapply(names(spatial_list), function(x) {
    p <- SpatialDimPlot(spatial_list[[x]], pt.size.factor=0) +
        NoLegend() +
        labs(title = x)
    png(paste0("output/figures/spatial/h_and_e_", x, ".png"))
    print(p)
    dev.off()
    return(p)
})

png("output/figures/spatial/h_and_e_all.png", width = 800, height = 500)
grid.arrange(grobs = he_plts, ncol = 4)
dev.off()

qs::qsave(spatial_list, "output/spatial_objects/spatial_list_unannotated.qs")
```

## Label Cell Types Using Spacexr

We'll be using RCTD on full mode to perform cell-type annotation 

### Create Reference Object

I need to create a reference object. This object is created using the RCTD constructor function, which requires a counts matrix, cell types, and nUMI

```{r}
yogi_path <- "/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/"

patient_mets <- qs::qread(paste0(yogi_path, "final_tumor_vs_stroma/patient_mets.qs"))

dimplot_better(patient_mets, group = "Ann_Level2", raster = FALSE)

cell_types <- unique(patient_mets$Ann_Level2)

#Ann_level3 was too granular, going to try using Ann_Level2
spacexr_reference <-
    spacexr::Reference(GetAssayData(patient_mets, layer = "counts"),
                       as.factor(patient_mets$Ann_Level2),
                       n_max_cells = 2000)

# Create level 1 reference too
spacexr_level1 <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level1),
        n_max_cells = 2000
    )
```

### Run RCTD on Spatial Data

#### Level 1

```{r}
spatial_list <- qs::qread("output/spatial_objects/spatial_list_unannotated.qs")
# do it at level 1
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(my_data,
                                     spacexr_level1,
                                     max_cores = 6,
                                     UMI_min = 3,
                                     counts_MIN = 0, 
                                     UMI_max = 900000000,
                                     CELL_MIN_INSTANCE = 0)
    rctd_out <- spacexr::run.RCTD(rctd_obj, doublet_mode = "full")
    qs::qsave(rctd_out, paste0("output/spacexr/rctd_level1_", ob_name, ".qs"))

    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level1_annotations.qs")
rm("spatial_list")
```

#### Level 2

```{r}
spatial_list <- qs::qread("output/spatial_objects/spatial_list_unannotated.qs")
#first I'm going to just use spacexr to add scores to each spot for the cell types in our reference
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(my_data,
                                     spacexr_reference,
                                     max_cores = 6,
                                     UMI_min = 3,
                                     counts_MIN = 0, 
                                     UMI_max = 900000000,
                                     CELL_MIN_INSTANCE = 0)
    rctd_out <- spacexr::run.RCTD(rctd_obj, doublet_mode = "full")
    qs::qsave(rctd_out, paste0("output/spacexr/rctd_level2_", ob_name, ".qs"))

    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level2_annotations.qs")
rm("spatial_list")
```

#### Level 3

```{r}
level3_ref <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level3),
        n_max_cells = 2000
    )

spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
# going to do it at level 3, specifying multi mode, though
spacexr_res <- parallel::mclapply(names(spatial_list), function(ob_name) {
    sp_ob <- spatial_list[[ob_name]]
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(
        my_data,                     
        level3_ref,
        max_cores = 1,
        UMI_min = 3,
        counts_MIN = 0, 
        UMI_max = 900000000,
        CELL_MIN_INSTANCE = 0
    )
    rctd_out <- spacexr::run.RCTD(
        rctd_obj,
        doublet_mode = "doublet"
    )
    qs::qsave(rctd_out, paste0("output/spacexr/rctd_level3_", ob_name, ".qs"))
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    return(AddMetaData(sp_ob, norm_weights))
    },
    mc.cores = parallelly::availableCores(),
    mc.preschedule = FALSE
    )
```

## Plot Tumor Cell Scores

The first sanity check we can perform is looking at how the tumor cell types' feature scores look compared to the H&E slides.

```{r plot-tumor-scores}
size.factors <- list("OS1_Seurat" = 1500,
                     "OS2_Seurat" = 1400,
                     "OS3_Seurat" = 2700,
                     "OS4_Seurat" = 1700,
                     "OS5_Seurat" = 650,
                     "OS6_Seurat" = 3000,
                     "OS7_Seurat" = 2500,
                     "OS8_Seurat" = 1300)

cell_types2 <- unique(patient_mets$Ann_Level2)
for (ob in names(spatial_list)) {
    tmp <- spatial_list[[ob]]
    tmp$Tumor_Cumulative <- tmp$Basal_Progenitor +
                             tmp$Fibrogenic +
                             tmp$Interactive +
                             tmp$MP_Progenitor +
                             tmp$Proliferative +
                             tmp$Stressed
    
    pdf(paste0("output/figures/spatial/spacexr/spacexr_", ob, "_level2.pdf"), height = 4, width = 4)
    print(
        SpatialDimPlot(
            tmp,
            pt.size.factor = 0) + NoLegend()
    )
    print(
        SpatialFeaturePlot(
            tmp,
            features = "Tumor_Cumulative",
            pt.size.factor = size.factors[[ob]],
            image.alpha = 0
        )
    )
    for (ct in cell_types2) {
        print(
            SpatialFeaturePlot(
                tmp,
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
        )
    }
    dev.off()
}
```

## Make Panel Plots

I want to make a figure where each column is a tumor type, and each row is a sample.

### Tumor Panel Plots

```{r}
tumor_types <- c(
    "Basal_Progenitor",
    "Fibrogenic",
    "Interactive",
    "MP_Progenitor",
    "Proliferative",
    "Stressed")

pdf("output/figures/spatial/spacexr/tumor_level_3.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()

spatial_2 <- qs::qread("output/spatial_objects/spatial_list_level2_annotations.qs")
pdf("output/figures/spatial/spacexr/tumor_level2.pdf", width = 35)
for (ob in names(spatial_2)) {
    hne <- SpatialDimPlot(spatial_2[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_2[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```


### TAM Panel Plots

```{r}
tam_types <- grep("TAM", colnames(spatial_list[[1]]@meta.data), value = TRUE)

pdf("output/figures/spatial/spacexr/tam_subpopulations.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (tam in tam_types) {
        plts[[tam]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = tam,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()


```

## STdeconvolve

Troy likes this method so I'm going to give it a go.

### Fit Models

```{r stdeconvolve}
library(STdeconvolve)

all_ldas <- list()
parallel::mclapply(names(spatial_list), function(sid) {
    ob <- spatial_list[[sid]]
    pos <- GetTissueCoordinates(ob)
    counts <- GetAssayData(ob, layer = "counts")
    # feature select
    corpus <- restrictCorpus(
        counts,
        removeAbove = 1.0,
        removeBelow = 0.05,
        alpha = 0.05,
        plot = FALSE,
        verbose = TRUE
    )
    lda_mod <- fitLDA(
        t(as.matrix(corpus)),
        Ks = seq(5, 20, by = 1),
        perc.rare.thresh = 0.05,
        plot = FALSE,
        ncores = 8
    )
    all_ldas[[sid]] <- lda_mod
    qs::qsave(
        lda_mod,
        paste0("output/STdeconvolve/", sid, "_lda.qs"))
    },
    mc.cores = 6
)

qs::qsave(all_ldas, "output/STdeconvolve/all_ldas.qs")
```

### Read back in Models

```{r}
all_ldas <- list()
for (ob in names(spatial_list)) {
    all_ldas[[ob]] <-
        qs::qread(
            paste0("output/STdeconvolve/", ob, "_lda.qs")
        )
}

for (ob in names(all_ldas)) {
    tmp_mod <- all_ldas[[ob]]
    png(paste0("output/figures/STdeconvolve/bias_variance_", ob, ".png"))
    perplexityPlot(tmp_mod)
    dev.off()
}
```

### Pick Optimal Models

I'm not sure which optimization procedure I should use, so I'm going to analyze using both methods.

```{r}
# minimizing perplexity
min_lda <- lapply(all_ldas, optimalModel, opt = "min")
min_lda

# knee point of perplexity and # of cell types w < 5% of all cells
# essentially point that minimizes bias-variance trade-off
kneed_lda <- lapply(all_ldas, optimalModel, opt = "kneed")
kneed_lda
```

As we can see, the kneed models have a lot more topics than the minimized_perplexity group.

### Visualize Topics

```{r}
# create different radii based on spatial object
r_vals <- list(
    "OS1_Seurat" = 2,
    "OS2_Seurat" = 2,
    "OS3_Seurat" = 1.5,
    "OS4_Seurat" = 2,
    "OS5_Seurat" = 1.5,
    "OS6_Seurat" = 1.5,
    "OS7_Seurat" = 1.5,
    "OS8_Seurat" = 2
)

# Following along with their vignette,using patient mets instead of mOB
patient_mets <- qs::qread("/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")

pdf("output/figures/spatial/STdeconvolve/all_sample_correlation.pdf")
for (ob in names(spatial_list)) {
    s_obj <- spatial_list[[ob]]
    cor_plt <- make_cor_plt(kneed_lda[[ob]], s_obj)
    print(cor_plt)
}
dev.off()

pdf("output/figures/spatial/STdeconvolve/all_sample_topics.pdf", height = 3, width = 4)
for (ob in names(spatial_list)) {
    s_obj <- spatial_list[[ob]]
    # get tissue coordinates and adjust so they match the h&e slide
    pos <- GetTissueCoordinates(s_obj)
    colnames(pos) <- c("y", "x")
    pos$y <- -pos$y
    # get beta and theta from model
    beta_theta <-
        getBetaTheta(kneed_lda[[ob]], perc.filt = 0.05, betaScale = 1000)
    print(
        vizAllTopics(
            beta_theta$theta,
            pos = pos,
            r = r_vals[[ob]]) +
            ggtitle(label = paste(ob, "Deconvolution Topics")) |
        SpatialDimPlot(s_obj, pt.size.factor = 0) +
            ggtitle(label = ob)
    )
}
dev.off()
```

### Topic-Based GSEA

I'm also going to try running GSEA on 

```{r}
Idents(patient_mets) <- patient_mets$Ann_Level2
ref_degs <- FindAllMarkers(
    patient_mets,
    only.pos = TRUE,
    min.pct = 0.25
)
write.table(
    ref_degs,
    "output/degs/ann_level2_degs.tsv",
    sep = "\t",
    row.names = TRUE)

# for fuse with STdeconvolve, I need a list of marker genes for each cell type
# We'll limit things to the top 200 genes for each cell type
ref_gene_set <- list()
for (ct in unique(ref_degs$cluster)) {
    tmp_degs <- subset(
        ref_degs,
        cluster == ct &
        p_val_adj < 0.05 &
        avg_log2FC > 1
        ) %>%
        arrange(desc(avg_log2FC))
    ref_gene_set[[ct]] <- rownames(tmp_degs)
}

# going to try this with the kneed-optimized models first
kneed_gsea <- list()
for (ob in names(spatial_list)) {
    mod_res <- getBetaTheta(
        kneed_lda[[ob]],
        perc.filt = 0.05,
        betaScale = 1000
        )
    kneed_gsea[[ob]] <-
        annotateCellTypesGSEA(
            beta = mod_res$beta,
            gset = ref_gene_set,
            qval = 0.05
        )
}

lapply(kneed_gsea, function(x) {
    print(x$predictions)
})
```

I really don't like this method of annotating. Perhaps it's an issue with the data type and the inherent heterogeneity of OS tumor samples, but very few topics get annotated as any particular cell type. Furthermore, I obtain different annotations when I restrict gene sets to the top 200 genes as determined by log2FC