## Loading in Spatial Data

This analysis will go along with the cellchat analysis. I'll weigh the interactions by the amount of cells in proximity to each other.

This will also serve as practice for me to get more familiar with analyzing single-spot spatial transcriptomics.

```{r load-spatial}
size.factors <- list("OS1_Seurat" = 1500,
                     "OS2_Seurat" = 1400,
                     "OS3_Seurat" = 2700,
                     "OS4_Seurat" = 1700,
                     "OS5_Seurat" = 650,
                     "OS6_Seurat" = 3000,
                     "OS7_Seurat" = 2500,
                     "OS8_Seurat" = 1300)

spatial_path <- "/home/gdrobertslab/lab/ExternalData/McEachron_lab/spatial_data/rdata/"
spatial_list <-
    sapply(paste0(spatial_path, list.files(spatial_path)), readr::read_rds)
names(spatial_list) <- str_remove(string = list.files(spatial_path), pattern = ".rds")

system("mkdir output/spatial_pathway_analysis")

#Remove pathway columns in metadata
for (ob_name in names(spatial_list)) {
    x <- spatial_list[[ob_name]]
    #first extract pathway scores from metadata
    pathway_metadata <- x@meta.data[, str_detect(colnames(x@meta.data),
                                    "^GOBP|^REACTOME|^HALLMARK")]

    x@meta.data <- x@meta.data[, !str_detect(colnames(x@meta.data),
                                             "^GOBP|^REACTOME|^HALLMARK")]
    x$sample_name <- ob_name
    spatial_list[[ob_name]] <- x
}

qs::qsave(spatial_list, "output/spatial_objects/spatial_list_unannotated.qs")
```

## Label Cell Types Using Spacexr

We'll be using RCTD on full mode to perform cell-type annotation 

### Read in Atlas Object Object

I need to create a reference object. This object is created using the RCTD constructor function, which requires a counts matrix, cell types, and nUMI

```{r}
yogi_path <- "/home/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/output/seurat_objects/"

patient_mets <- qs::qread(paste0(yogi_path, "final_tumor_vs_stroma/patient_mets.qs"))

dimplot_better(patient_mets, group = c(paste0("Ann_Level", 1:3)), raster = FALSE)
```

### Run RCTD on Spatial Data

#### Level 2

```{r}
level2_ref <- spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level2),
        n_max_cells = 2000
)

spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
#first I'm going to just use spacexr to add scores to each spot for the cell types in our reference
for (ob_name in names(spatial_list)) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = level2_ref)
    qs::qsave(rctd_out, paste0("output/spacexr/Ann_Level2/", ob_name, ".qs"))
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    spatial_list[[ob_name]] <- AddMetaData(sp_ob, norm_weights)
}
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level2_annotations.qs")

# make figures
# read in rctd results first
for (ob_name in names(spatial_list)) {
    tmp_rctd <- qs::qread(paste0("output/spacexr/Ann_Level2/rctd_level2_", ob_name, ".qs"))
    save_deconv_plots(
        ob = spatial_list[[ob_name]],
        ob_name = ob_name,
        rctd_res = tmp_rctd,
        fig_dir = "output/figures/spatial/spacexr/Ann_Level2"
    )
}

rm("spatial_list")
```

#### Level 3

```{r}
level3_ref <-
    spacexr::Reference(
        GetAssayData(patient_mets, layer = "counts"),
        as.factor(patient_mets$Ann_Level3),
        n_max_cells = 2000
    )

spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
# going to do it at level 3, specifying multi mode, though
spacexr_res <- parallel::mclapply(names(spatial_list), function(ob_name) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = level3_ref)
    qs::qsave(rctd_out, paste0("output/spacexr/Ann_Level3/rctd_level3_", ob_name, ".qs"))
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    return(AddMetaData(sp_ob, norm_weights))
    },
    mc.cores = parallelly::availableCores(),
    mc.preschedule = FALSE
    )
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_level3_annotations.qs")

for (ob_name in names(spatial_list)) {
    tmp_rctd <- qs::qread(paste0("output/spacexr/Ann_Level3/rctd_level3_", ob_name, ".qs"))
    save_deconv_plots(
        ob = spatial_list[[ob_name]],
        ob_name = ob_name,
        rctd_res = tmp_rctd,
        fig_dir = "output/figures/spatial/spacexr/Ann_Level3"
    )
}

# run doublet mode = "multi" for level3
parallel::mclapply(names(spatial_list), function(ob_name) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = level3_ref, doublet_mode = "multi")
    qs::qsave(paste0("output/spacexr/Ann_Level3/rctd_multi_", ob_name, ".qs"))
    },
    mc.cores = parallelly::availableCores(),
    mc.preschedule = FALSE
)

rm("spatial_list")
```

#### Myeloid and Tumor Focus

This may be cheating... but I'm wondering if we can perform deconvolution with a reference that only has level 3 granularity for the myeloid and tumor populations.

```{r}
table(patient_mets$Ann_Level1)
# we'll make a new column in our object called myeloid_tumor
patient_mets@meta.data <- patient_mets@meta.data %>%
    mutate(myeloid_tumor = recode(
        Ann_Level1,
        "Alv_Macrophages" = "Alv_Macrophages",
        "Epithelial_Endothelial" = "Epithelial_Endothelial",
        "Immune_Lymphoid" = "Immune_Lymphoid",
        "Mesenchymal" = "Mesenchymal",
        "Immune_Myeloid" = Ann_Level3,
        "Tumor" = Ann_Level3
    ))

myeloid_tumor_ref <- spacexr::Reference(
    GetAssayData(patient_mets, layer = "counts"),
    as.factor(patient_mets$myeloid_tumor),
    n_max_cells = 2000
)

spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")

spatial_list <- parallel::mclapply(names(spatial_list), function(ob_name) {
    sp_ob <- spatial_list[[ob_name]]
    rctd_out <- run_rctd(sp_ob, ref = myeloid_tumor_ref)
    qs::qsave(
        rctd_out,
        paste0("output/spacexr/myeloid_tumor/", ob_name, ".qs")
    )
    norm_weights <- spacexr::normalize_weights(rctd_out@results$weights)
    return(AddMetaData(sp_ob, norm_weights))
    },
    mc.cores = parallelly::availableCores(),
    mc.preschedule = FALSE
    )
qs::qsave(spatial_list, "output/spatial_objects/spatial_list_myeloid_tumor.qs")

ann_list <- list()
for (ob_name in names(spatial_list)) {
    tmp_rctd <- qs::qread(paste0("output/spacexr/myeloid_tumor/rctd_myeloid_tumor_", ob_name, ".qs"))
    save_deconv_plots(
        ob = spatial_list[[ob_name]],
        ob_name = ob_name,
        rctd_res = tmp_rctd,
        fig_dir = "output/figures/spatial/spacexr/myeloid_tumor"
    )
    ann_list[[ob_name]] <-
        as.data.frame(
            spacexr::normalize_weights(tmp_rctd@results$weights)
        )
}

full_ann_mat <- bind_rows(ann_list)

pdf(
    "output/figures/spatial/spacexr/myeloid_tumor/all_sample_heatmap.pdf",
    width = 18,
    height = 16
)
pheatmap::pheatmap(
    cor(full_ann_mat, method = "spearman"),
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = 0,
    angle_col = 45,
    fontsize = 16
)
dev.off()

rm("spatial_list")
```

#### Different Granularities

Inspired by the section above using the myeloid_tumor reference, I'm going to repeat this exercise, but keep Ann_Level2 instead of Ann_Level1. Likewise, I'm going to repeat it for each Ann_Level1 compartment.

I'm going to save off a table to use as input for an array job submission.

This table will have the name of the reference we are using (from the names of `output/spacexr/granular_references/ref_list.qs`)

```{r}
spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")

data.frame(obs = rep(names(spatial_list), 5), ref = rep(names(ref_list), 8)) %>%
    write.table("misc/rctd_input.txt", quote = FALSE, row.names = FALSE, col.names = FALSE)
# next I'm going to make the folders in which I'll keep the output
for (ct in names(ref_list)) {
    dir.create(paste0("output/figures/spatial/spacexr/granular_", ct))
    dir.create(paste0("output/spacexr/granular_references/", ct))
}

# make spacex reference objects
ref_list <- list()
for (ct in unique(patient_mets$Ann_Level1)) {
    tmp <- patient_mets
    tmp$new_anns <- ifelse(
        patient_mets$Ann_Level1 == ct,
        patient_mets$Ann_Level3,
        patient_mets$Ann_Level2
    )
    ref_list[[ct]] <- spacexr::Reference(
        GetAssayData(tmp, layer = "counts"),
        as.factor(tmp$new_anns),
        n_max_cells = 2000
    )
}
dir.create("output/spacexr/granular_references/")
qs::qsave(ref_list, "output/spacexr/granular_references/ref_list.qs")
```

Now I call the shell scripts to run RCTD on these objects.

```{bash}
sbatch rctd_scripts/rctd_array.sh
sbatch rctd_scripts/rctd_array_multi.sh
```

Now I create figures for these objects

```{r}
for (compartment in names(ref_list)) {
    for (ob_name in names(spatial_list)) {
        tmp_rctd <- qs::qread(
            paste0(
                "output/spacexr/granular_references/",
                compartment,
                "/",
                ob_name,
                ".qs"
            )
        )
        save_deconv_plots(
            ob = spatial_list[[ob_name]],
            ob_name = ob_name,
            rctd_res = tmp_rctd,
            fig_dir = paste0(
                "output/figures/spatial/spacexr/granular_", compartment)
        )
    }
}
rm(spatial_list)
```


#### TAM Level3, Else Level2

```{r}
tam_types <- unique(grep("TAM", patient_mets$Ann_Level3, value = TRUE))
patient_mets$tam_specific <- ifelse(
    patient_mets$Ann_Level3 %in% tam_types,
    patient_mets$Ann_Level3,
    patient_mets$Ann_Level2
)
tam_rctd_ref <- spacexr::Reference(
    GetAssayData(patient_mets, layer = "counts"),
    as.factor(patient_mets$tam_specific),
    n_max_cells = 2000
)

qs::qsave(tam_rctd_ref, "output/spacexr/tam_specific/rctd_ref.qs")

tam_rctd <- mclapply(
    spatial_list,
    run_rctd,
    ref = tam_rctd_ref,
    mc.cores = 8,
    mc.preschedule = FALSE)
qs::qsave(tam_rctd, "output/spacexr/tam_specific/rctd_res.qs")

# spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")

for (ob_name in names(spatial_list)) {
    save_deconv_plots(spatial_list[[ob_name]], ob_name, tam_rctd[[ob_name]], "output/figures/spatial/spacexr/tam_specific")
}

ann_list <- lapply(tam_rctd, function(x) {
    spacexr::normalize_weights(x@results$weights) %>%
        as.data.frame()
})
full_ann_mat <- bind_rows(ann_list)

pdf(
    "output/figures/spatial/spacexr/tam_specific/all_sample_heatmap.pdf",
    width = 18,
    height = 16
)
pheatmap::pheatmap(
    cor(full_ann_mat, method = "spearman"),
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = 0,
    angle_col = 45,
    fontsize = 16
)
dev.off()
```


## Make Panel Plots

### Tumor Panel Plots

I want to make a figure where each column is a tumor type, and each row is a sample.

```{r}
spatial_list <- qs::qread("output/spatial_objects/spatial_list_level3_annotations.qs")
tumor_types <- c(
    "Basal_Progenitor",
    "Fibrogenic",
    "Interactive",
    "MP_Progenitor",
    "Proliferative",
    "COMA")

pdf("output/figures/spatial/spacexr/tumor_level_3.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        max_score = max(spatial_list[[ob]]@meta.data[, ct])
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()


spatial_list <- qs::qread("output/spatial_objects/spatial_list_level2_annotations.qs")
pdf("output/figures/spatial/spacexr/tumor_level2.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()


spatial_list <- qs::qread("output/spatial_objects/spatial_list_myeloid_tumor.qs")
pdf("output/figures/spatial/spacexr/myeloid_tumor/tumor_panel.pdf", width = 35)
for (ob in names(spatial_list)) {
    spatial_list[[ob]]$COMA <- spatial_list[[ob]]$Stressed
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (ct in tumor_types) {
        plts[[ct]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = ct,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```


### TAM Panel Plots

#### Ann_Level3

```{r}
tam_types <- grep("TAM", colnames(spatial_list[[1]]@meta.data), value = TRUE)

pdf("output/figures/spatial/spacexr/tam_subpopulations.pdf", width = 35)
for (ob in names(spatial_list)) {
    hne <- SpatialDimPlot(spatial_list[[ob]], pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (tam in tam_types) {
        plts[[tam]] <-
            SpatialFeaturePlot(
                spatial_list[[ob]],
                features = tam,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```

#### myeloid_tumor

```{r}
spatial_list <- qs::qread("output/spatial_objects/unannotated_spatial_list.qs")
tam_types <- unique(grep("TAM", patient_mets$Ann_Level3, value = TRUE))

pdf("output/figures/spatial/spacexr/myeloid_tumor/tam_panel.pdf", width = 35)
for (ob in names(spatial_list)) {
    res <- qs::qread(paste0("output/spacexr/myeloid_tumor/rctd_myeloid_tumor_", ob, ".qs"))
    res <- spacexr::normalize_weights(res@results$weights)
    tmp <- AddMetaData(spatial_list[[ob]], res)
    hne <- SpatialDimPlot(tmp, pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (tam in tam_types) {
        plts[[tam]] <-
            SpatialFeaturePlot(
                tmp,
                features = tam,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```

#### tam_specific

```{r}
tam_rctd <- qs::qread("output/spacexr/tam_specific/rctd_res.qs")
pdf("output/figures/spatial/spacexr/tam_specific/tam_panel.pdf", width = 35)
for (ob in names(spatial_list)) {
    tmp_res <- spacexr::normalize_weights(tam_rctd[[ob]]@results$weights)
    tmp_ob <- AddMetaData(spatial_list[[ob]], tmp_res)
    hne <- SpatialDimPlot(tmp_ob, pt.size.factor = 0) +
        NoLegend()
    plts <- list("h_and_e" = hne)
    for (tam in tam_types) {
        plts[[tam]] <-
            SpatialFeaturePlot(
                tmp_ob,
                features = tam,
                pt.size.factor = size.factors[[ob]],
                image.alpha = 0
            )
    }
    grid.arrange(grobs = plts, nrow = 1)
}
dev.off()
```