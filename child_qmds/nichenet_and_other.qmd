

## Run Nichenet and other analyses

```{r cell_cell_communication}
object_list <-
    tribble(~group1,                         ~group2,                       ~group3,
            "xeno_prim_mouse",              "xeno_prim_human_cancer_cells", "xeno_prim_cancer_normal",
            "xeno_mets_mouse",              "xeno_mets_human_cancer_cells", "xeno_mets_cancer_normal"
            )

# conver the xeno mouse stroma into human symbols
for (i in 1:nrow(object_list)) {
    group1 <- object_list$group1[i]
    group2 <- object_list$group2[i]
    group3 <- object_list$group3[i]
    object1 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group1,
                        ".qs"))
    raw_counts <-
        GetAssayData(object1,
                     slot = "counts")

    human_genes <-
        object1 %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object1@meta.data)
    object1 <-
        new_seurat_object %>%
        process_seurat()

    object2 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group2,
                        ".qs"))
    combined_object <-
        merge(object1, object2) %>%
        JoinLayers() %>%
        process_seurat() %>%
        RunHarmony(group.by.vars = c("sample_name", "model"),
                    theta = c(12, 12),
                    lambda = c(0.1, 0.1)) %>%
        process_seurat(reduction = "harmony")

    combined_object$organism <- "human"
    combined_object$unique <- group3

    qs::qsave(combined_object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group3,
                    ".qs"))
}

# convert dog to human symbols
orthologs <-
    read_tsv("input/downloads/dog_human_gene_orthologs.txt")
for (group in c("dogs_prim",
                "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")

    number_of_ENSEMBL_genes <-
        sum(str_detect(rownames(raw_counts), "^ENSCAFG"))

    raw_counts_new <-
        raw_counts[rownames(raw_counts) %in% orthologs$dog_gene_name, ]
    rownames(raw_counts_new) <-
        orthologs$human_gene_ortholog[match(rownames(raw_counts_new), orthologs$dog_gene_name)]
    new_seurat_object <-
        CreateSeuratObject(counts = raw_counts_new) %>%
        AddMetaData(metadata = object@meta.data)
    newobject <-
        new_seurat_object %>%
        process_seurat()
    newobject$organism <- "human"
    qs::qsave(newobject,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

for (group in c("mm_prim",
                "mm_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")
    human_genes <-
        object %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object@meta.data)
    object <-
        new_seurat_object %>%
        process_seurat()
    
    object$organism <- "human"
    qs::qsave(object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

# function for cellchat function
suppressPackageStartupMessages({
  library(CellChat); library(patchwork)
})
run_cellchat <- function(sobject,
                        group.by="celltype",
                        species_db="human") {
    data.input <- GetAssayData(sobject, assay="RNA", slot="data")  # log-normalized
    meta <- data.frame(labels = sobject[[group.by]][,1], row.names=colnames(sobject))
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
    cellchat@DB <- if (species_db=="human") CellChatDB.human else CellChatDB.mouse
    future::plan("multisession", workers = 10) # do parallel
    cellchat <- 
        subsetData(cellchat) %>%
        identifyOverExpressedGenes() %>%
        identifyOverExpressedInteractions() %>%
        computeCommunProb() %>%
        filterCommunication(min.cells = 10) %>%
        computeCommunProbPathway() %>%
        aggregateNet() %>%
        netAnalysis_computeCentrality()
        # computeNetSimilarity(type = "functional") %>%
        # netEmbedding(type = "functional") %>%
        # netClustering(type = "functional", do.parallel = FALSE) %>%
        # computeNetSimilarity(type = "structural") %>%
        # netEmbedding(type = "structural") %>%
        # netClustering(type = "structural", do.parallel = FALSE)
  return(cellchat)
}

pathways_by_module <-
    CellChatDB.human$interaction %>%
    select(pathway_name, annotation) %>%
    group_by(annotation) %>%
        summarise(pathways = list(unique(pathway_name)))

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim",
                # "patient_mets"
                # "mm_prim",
                # "mm_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho"
                "mm_primhuman_ortho"
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects", "/", group))) {
                dir.create(str_c("output/cellchat_objects", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}



# cellchat at ann_level2 using all the pathways general identify the shared genes only
list_of_genes <- list()
samples_numbers <- list()
for (group in c(
                # "patient_prim",
                # "patient_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal",
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho",
                # "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    samples_numbers[[group]] <- length(unique(object$sample_name))

    genes <- rownames(object)
    list_of_genes[[group]] <- genes
}

# shared genes
shared_genes <-
    Reduce(intersect, list_of_genes) %>%
    as_tibble()

# save the shared genes
write_tsv(shared_genes,
          "input/shared_genes_across_groups_for_cellchat.txt")

# load the shared genes
shared_genes <-
    read_tsv("input/shared_genes_across_groups_for_cellchat.txt",
            col_names = "gene")  %>%
            as.data.frame()

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim"
                # "patient_mets"
                # "xeno_prim_cancer_normal"
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho"
                # "dogs_metshuman_ortho"
                "mm_primhuman_ortho"
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    object <-
        subset(object, features = shared_genes$gene) %>%
        process_seurat()

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects_sharedgenes", "/", group))) {
                dir.create(str_c("output/cellchat_objects_sharedgenes", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}




```

### Run cellchat in slurm job
```{bash cellchat_slurm_job}

sbatch --array=1-25 child_qmds/cellchat_run_shellscript.sh patient_prim 
sbatch --array=1-36 child_qmds/cellchat_run_shellscript.sh patient_mets
sbatch --array=1-14 child_qmds/cellchat_run_shellscript.sh  xeno_prim_cancer_normal
sbatch --array=1-12 child_qmds/cellchat_run_shellscript.sh xeno_mets_cancer_normal
sbatch --array=1-17 child_qmds/cellchat_run_shellscript.sh dogs_primhuman_ortho
sbatch --array=1-16 child_qmds/cellchat_run_shellscript.sh dogs_metshuman_ortho
sbatch --array=1-3 child_qmds/cellchat_run_shellscript.sh mm_primhuman_ortho
sbatch --array=1-8 child_qmds/cellchat_run_shellscript.sh mm_metshuman_ortho

```

### Plotting for cellchat
```{r cellchat_plots}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

    object_list[[group]] <- cellchat

    # 8. visualize the aggregated cell-cell communication network
    groupSize <- as.numeric(table(cellchat@idents))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
        dir.create(str_c("output/figures/cellchat/", group),
                    recursive = TRUE)
    }
    p1 <- netVisual_circle(cellchat@net$count,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Number of interactions")
    p2 <- netVisual_circle(cellchat@net$weight,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Interaction weights/strength")
    combined_plot <- 
        plot_grid(p1, p2, ncol = 1) +
        patchwork::plot_annotation(title = stringr::str_c(group," everything "))
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.pdf"),
        combined_plot,
        width = 15,
        height = 30
    )
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.png"),
        combined_plot,
        width = 15,
        height = 30
    )
    #  examine the signaling sent from each cell group
    mat <- cellchat@net$weight
    plot_list1 <- list()
    for (i in 1:nrow(mat)) {
        mat2 <- 
            matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
        mat2[i, ] <- mat[i, ]
        plot_list1[[i]] <-
            netVisual_circle(mat2, 
                                vertex.weight = groupSize,
                                weight.scale = F, 
                            edge.weight.max = max(mat),
                            title.name = rownames(mat)[i]) 
    }
    combined_plot1 <- 
        plot_grid(plotlist = plot_list1, ncol = 3) +
        patchwork::plot_annotation(title = stringr::str_c(group," ", subset_db))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "outgoing_signaling.png"),
        combined_plot1,
        width = 21,
        height = 7 * length(plot_list1)/3
    )

    future::plan("multisession", workers = 10) # do parallel
    # 9. Identify the signaling roles of cell
    cellchat@netP[["pathways"]]
    # rank the pathways 
    ranked_pathways <-
        rankNet(cellchat, mode="single")
    ggsave(str_c("output/figures/cellchat/", group, "/everything_ranked_pathways.png"),
        ranked_pathways,
        width = 10,
        height = 15
    )
    # reveal all the ligand-receptor pairs for a signaling pathway
    extractEnrichedLR(cellchat, signaling = c(cellchat@netP[["pathways"]]),
                    geneLR.return = TRUE)

    # visualize the contribution of each LR pairs to the communication network
    netAnalysis_contribution(cellchat, 
                            signaling = c(cellchat@netP[["pathways"]]), 
                            title = "Contribution of each LR pairs")
    # visualize the contribution of each LR pairs to the communication network top5
    top5_ligand_receptor_pairs <-
        netAnalysis_contribution(cellchat, 
                                signaling = c(cellchat@netP[["pathways"]][1]))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "top5_ligand_receptor_pairs.png"),
        top5_ligand_receptor_pairs,
        width = 10,
        height = 15
    )
    # 10. Visualize cell-cell communication mediated by specific signaling pathways
    extractEnrichedLR(cellchat, signaling = "COLLAGEN", geneLR.return = FALSE)
    netAnalysis_contribution(cellchat, signaling = "COLLAGEN")

    # Circle plot
    netVisual_aggregate(cellchat, signaling = "COLLAGEN", layout = "circle")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1")

    # Arrange so that tumor are on one side in the chord diagram
    # Define group.cellType so that tumor cell types are grouped together
    # Example: assign "Tumor" to tumor clusters, others as before
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive", "Stressed")
    other_clusters <- setdiff(levels(cellchat@idents), tumor_clusters)

    group.cellType <- c(
        rep("Tumor", length(tumor_clusters)),
        rep("Other", length(other_clusters)))
    names(group.cellType) <- c(tumor_clusters, other_clusters)

    chord_plot <-
        netVisual_chord_cell(cellchat, signaling = "COLLAGEN", 
            group = group.cellType, 
            title.name = paste0("COLLAGEN_", "signaling network"))

    # Chord diagram: define source and target cell types
    netVisual_chord_gene(cellchat, sources.use = 4, targets.use = c(5:6), 
                        lab.cex = 0.5,legend.pos.y = 30)

    netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4), targets.use = 8,
                        lab.cex = 0.5, legend.pos.x = 15)

    # Chord diagram: show LR pairs associated with certain signaling pathways
    netVisual_chord_gene(cellchat,
                         sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c("TAMs"),
                        signaling = c("COLLAGEN"),legend.pos.x = 8)

    # Hierarchy plot 
    # Define tumor clusters as vertex.receiver for hierarchy plot
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive")
    vertex.receiver <- which(levels(cellchat@idents) %in% tumor_clusters)

    netVisual_aggregate(cellchat, signaling = "COLLAGEN", 
                        vertex.receiver = vertex.receiver, layout = "hierarchy")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1", 
                        vertex.receiver = vertex.receiver, 
                        layout = "hierarchy")

    # Heatmap for sender receiver pairs for a specific signaling pathway
    netVisual_heatmap(cellchat, signaling = "COLLAGEN", color.heatmap = "Reds")

    # bubble plot 
    # bubble plot: show all LR pairs from source to target cell groups
    netVisual_bubble(cellchat, sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c(1:10), 
                    remove.isolate = FALSE) 

    # bubble plot: show LR pairs associated with certain signaling pathways
    netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:12), 
                    signaling = c("COLLAGEN"), remove.isolate = FALSE)
                
    # 1. Compute the network centrality scores
    cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP")

    # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- netAnalysis_signalingRole_scatter(cellchat) + coord_fixed()
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_aggregated_network.png"),
        aggregated_network,
        width = 7,
        height = 7
    )

    # Scatter plot to Visualize selected communication networks
    netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    # Heatmap to visualize dominant cell types for each signaling pathway
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing", height = 11)
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming", height = 11)

    # Visualize selected outgoing/incoming signals and contributing cell types
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing",
                                        signaling = c("COLLAGEN"))
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming",
                                        signaling = c("COLLAGEN"))

    # Heatmap to visualize major signaling roles of different cell groups
    netAnalysis_signalingRole_network(cellchat, signaling = "FN1", width = 10, 
                                    height = 5, font.size = 10)

    # 2. Identify global communication patterns to explore how multiple cell types 
    # and signaling pathways coordinate
    # Identify and visualize outgoing communication pattern of secreting cells
    selectK(cellchat, pattern = "outgoing") # infer the number of patterns, NMF
    nPatterns = 4 # a suitable number of patterns is the one begin to drop suddenly.
    cellchat <- identifyCommunicationPatterns(cellchat, pattern = "outgoing",
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "outgoing") # river plot
    netAnalysis_dot(cellchat, pattern = "outgoing") # dot plot

    ## Identify and visualize incoming communication pattern of target cells
    selectK(cellchat, pattern = "incoming")
    nPatterns = 4
    cellchat <- identifyCommunicationPatterns(cellchat,pattern = "incoming", 
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "incoming") # river plot
    netAnalysis_dot(cellchat, pattern = "incoming") # dot plot

    # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)

    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "functional", nCol = 2)

    # Identify signaling groups based on structure similarity
    # multimeric ligand-receptor complexes, soluble agonists and antagonists, 
    # stimulatory and inhibitory co-ligands and co-receptors
    cellchat <- computeNetSimilarity(cellchat, type = "structural")
    cellchat <- netEmbedding(cellchat, type = "structural")
    cellchat <- netClustering(cellchat, type = "structural",do.parallel = FALSE)

    # Visualization in 2D-space
    structural_gene_groups <-
        netVisual_embedding(cellchat, type = "structural", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_structural_gene_groups.png"),
        structural_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "structural", nCol = 2)
}



object_list <- list()
collagen_bubble <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

     # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- 
        netAnalysis_signalingRole_scatter(cellchat) +
        coord_fixed() +
        ggtitle(str_c(group," aggregated network"))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
    dir.create(str_c("output/figures/cellchat/", group),
                recursive = TRUE)
    }
    ggsave(str_c("output/figures/cellchat/", group, "/", "ann2_aggregated_network.png"),
        aggregated_network,
        width = 10,
        height = 10)

    # Visualize selected outgoing/incoming signals and contributing cell types
        # Scatter plot to Visualize selected communication networks
    collagen_bubble[[group]] <-
        netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    ggsave(str_c("output/figures/cellchat/", group, "/", "collagen_bubble.png"),
        collagen_bubble[[group]],
        width = 10,
        height = 10)
    
     # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)
    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5) +
        ggtitle(str_c(group," functional gene groups"))
    ggsave(str_c("output/figures/cellchat/", group, "/", "functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )

    png(filename = str_c("output/figures/cellchat/", group, "/", "collagen_network_heatmap.png"),
        width = 1000, height = 500, res = 300)
    netAnalysis_signalingRole_network(cellchat, signaling = "COLLAGEN", width = 10, height = 5, font.size = 10)

    dev.off()
}

```


## comparative cellchat analysis
```{r cellchat_comparative analysis}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))
    
    # qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs")) 

    object_list[[group]] <- cellchat
            }

# rank the pathways and compare across groups
rankNet(object_list$mm_metshuman_ortho, mode="single")
rankNet(mergeCellChat(list(object_list$patient_prim,
                            object_list$mm_primhuman_ortho),
        add.names=c("patient","xeno")),
        mode="comparison",
        stacked = TRUE)
rankNet(mergeCellChat(list(object_list$mm_primhuman_ortho,
                            object_list$mm_metshuman_ortho),
        add.names=c("patient","xeno", "dog")),
        mode="comparison",
        stacked = FALSE)

get_pathway_flow <- function(cc,
                             dataset_name) {
    flows <- 
        apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE))
    data.frame(pathway = names(flows),
            information_flow = as.numeric(flows),
            dataset = dataset_name,
            stringsAsFactors = FALSE)
}

# Collect all datasets and perform PCA for each dataset
df_list <- 
    Map(get_pathway_flow, object_list,
    names(object_list))
df_all <-
    do.call(rbind, df_list) %>%
    as_tibble() %>%
    as.data.frame()
# Pivot to wide format: rows = pathway, columns = dataset, values = information_flow
df_wide <- df_all %>%
    select(pathway, dataset, information_flow) %>%
    tidyr::pivot_wider(names_from = dataset,
                        values_from = information_flow,
                        values_fill = 0)
# Set rownames to pathway and remove pathway column
mat_t <- 
    as.data.frame(df_wide) %>%
    column_to_rownames("pathway") %>%
    t()

# Scale and run PCA
pca_res <- prcomp(mat_t, scale. = TRUE)

# PCA plot: one dot per group (dataset)
pca_df <- as.data.frame(pca_res$x)
pca_df$group <- rownames(pca_df)

library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, label = group)) +
    geom_point(size = 3) +
    geom_text(vjust = -0.5, size = 3) +
    labs(title = "PCA of Pathway Information Flow (one dot per group)",
            x = "PC1", y = "PC2") +
    theme_minimal()

# the pathways that drive the differences between groups
loading_scores_df <-
    pca_res$rotation %>%
    as.data.frame() %>%
    rownames_to_column("pathway")



# Function to compare pathways between two CellChat objects (e.g. primary vs. mets)
compare_pathways <- function(cc_primary,
                            cc_mets) {
                        
    info_primary <- 
        cc_primary@netP$pathways %>% 
        data.frame(pathway = .,
                flow = apply(cc_primary@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    info_mets <- 
        cc_mets@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc_mets@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))

    merged <- 
        merge(info_primary, info_mets, by="pathway", suffixes = c("_prim", "_mets"))
    merged$diff_mets_up <- merged$flow_mets - merged$flow_prim
    merged$diff_prim_up <- merged$flow_prim - merged$flow_mets

    merged
}

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    patient_diff <-
        compare_pathways(cc_primary = object_list[[group_prim]],
                        cc_mets = object_list[[group_mets]])

    # Sort and visualize
    # Top 10 pathways enriched in mets (mets > primary)
    top_diff_mets_up <-
        head(patient_diff[order(-patient_diff$diff_mets_up), ], 10)

    # Top 10 pathways enriched in primary (primary > mets)
    top_diff_prim_up <-
        head(patient_diff[order(-patient_diff$diff_prim_up), ], 10)

    # Barplot of top pathways enriched in mets (mets > primary)
    top_diff_mets_up$group <- "Metastasis"
    # Barplot of top pathways enriched in primary (primary > mets)
    top_diff_prim_up$group <- "Primary"

    # Combine top pathways for plotting
    top_diff_combined <- rbind(
        top_diff_mets_up %>% dplyr::select(pathway, flow_mets, flow_prim, group),
        top_diff_prim_up %>% dplyr::select(pathway,  flow_mets, flow_prim, group))

    # Reshape to long format for ggplot
    top_diff_long <-
        top_diff_combined %>%
        tidyr::pivot_longer(cols = c(flow_prim, flow_mets),
                            names_to = "condition",
                            values_to = "information_flow") %>%
        mutate(condition = ifelse(condition == "flow_prim", "Primary", "Metastasis")) %>%
        arrange(desc(group), information_flow) %>%
        mutate(pathway = factor(pathway, levels = unique(pathway)))

    ggplot(top_diff_long,
                    aes(x = information_flow, y = pathway,
                            fill = condition)) +
        geom_bar(stat = "identity", position = "dodge") +
        labs(title = "Top 10 Differential Pathways: Metastasis vs. Primary",
                x = "Information Flow", y = "Pathway") +
        scale_fill_manual(values = c("Metastasis" = "#E41A1C", "Primary" = "#377EB8")) +
        theme_minimal()

    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "_top_diff_pathways.png"),
        width = 10,
        height = 10,
        bg = "white"
    )
}



# look at top five pathways for everything
pathways_list <- list()

for (item in names(object_list)) {
    cc <- object_list[[item]]
    top_pathways <-
        cc@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    top5 <-
        head(top_pathways[order(-top_pathways$flow), ], 5) %>%
        mutate(group = item)

    pathways_list[[item]] <- top5
}

pathwys_df <-
    do.call(rbind, pathways_list) %>%
    as_tibble() %>%
    as.data.frame()

# Define plot_cols as a named vector, e.g.:
# plot_cols <- c("patient_prim"="#1f77b4", "patient_mets"="#ff7f0e", ...)
top5_all <-
    ggplot(pathwys_df,
    aes(x = flow, y = pathway, fill = group)) +
    geom_bar(stat = "identity",position = position_dodge(preserve = "single", width = 0.8), width = 0.7) +
    labs(title = "Top 5 Pathways per Group",
        x = "Information Flow", y = "Pathway") +
    scale_fill_manual(values = plot_cols) +
    theme_minimal()

ggsave("output/figures/cellchat/top5_pathways_all.png",
    top5_all,
    width = 10,
    height = 10,
    bg = "white"
)


### merge by cellchat function testing if the net number and weight of interaciton change by merging
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    object_list_sub <-
        list(object_list[[group_prim]],
             object_list[[group_mets]]) %>%
        setNames(c(group_prim, group_mets))
    cellchat <-
        mergeCellChat(object.list = object_list_sub,
                      add.names = names(object_list_sub),
                      merge.data = FALSE,
                      cell.prefix = FALSE)

    # comapre fropm merged
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "count")
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "weight")

    # 2. Compare the total number of interactions and interaction strength
    # Calculate total number of interactions for each group
    interaction_sums <- 
        sapply(object_list_sub, function(x) sum(x@net$count))
    interaction_sum_df <- 
        data.frame(
        group = names(interaction_sums),
        total_interactions = as.numeric(interaction_sums))

    # Barplot individually
    library(ggplot2)
    interaction_df$group <-
        factor(interaction_df$group,
                levels = c("patient_prim", setdiff(interaction_df$group, "patient_prim")))
    ggplot(interaction_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Number of Interactions per Group",
             x = "Group", y = "Total Interactions") +
        theme_minimal() +
        theme(legend.position = "none")
    
    # weight     
    interaction_weight <- 
        sapply(object_list_sub, function(x) sum(x@net$weight))
    interaction_weight_df <- 
        data.frame(
        group = names(interaction_weight),
        total_interactions = as.numeric(interaction_weight))
    interaction_weight_df$group <-
        factor(interaction_weight_df$group,
                levels = c("patient_prim", setdiff(interaction_weight_df$group, "patient_prim")))
    ggplot(interaction_weight_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Interaction Weights per Group",
             x = "Group", y = "Total Interaction Weights") +
        theme_minimal() +
        theme(legend.position = "none")

}


# merge everything
merged_all <-
    mergeCellChat(object.list = object_list,
                  add.names = names(object_list),
                  cell.prefix = TRUE)
# compare the total number of interactions and interaction strength
gg1<-
    compareInteractions(merged_all, show.legend = F, group = c(1:8)) +
        theme(axis.text.x = element_blank())
gg2 <-
    compareInteractions(merged_all, show.legend = F, group = c(1:8), measure = "weight") +
     theme(axis.text.x = element_text(angle = 45, hjust = 1))

combined <-
    patchwork::wrap_plots(gg1 + xlab(NULL), gg2, ncol = 1)

ggsave("output/figures/cellchat/merged_everything_compare_interactions.png",
    combined,
    width = 10,
    height = 10
)

```


### multi sample by sample per group
```{r multi_sample_cellchat_analysis}

average_pathways_allgenes <- list()
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "netP") %>%
            arrange(desc(prob))

        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% receiver_cells) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    #mean filter for probabilities
    mean_filter <- mean(pathways_LR_df$prob)

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        select(sample, pathway_name, prob) %>%
        group_by(pathway_name) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group)
    
    average_pathways_allgenes[[group]] <- pathway_average

    # Perform PCA on the pathways
    pca_input <- 
        pathways_LR_df %>%
        filter(str_starts(sample, "CCDI")) %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        column_to_rownames("sample_group")
    
    # make a heatmap
    heatmap_matrix <-
        pathways_LR_df %>%
        filter(str_starts(sample, "CCDI")) %>%
        filter(!pathway_name %in% c("COLLAGEN", "FN1", "LAMININ")) %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        { 
            mat <- .
            cols_to_keep <- names(mat)[-1][colSums(mat[,-1, drop=FALSE]) > mean_filter]
            mat <- mat[, c("sample_group", cols_to_keep), drop=FALSE]
            mat
        } %>%
        column_to_rownames("sample_group")

    # plot heatmap
    heatmap <-
        pheatmap::pheatmap(
            heatmap_matrix,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
            main = stringr::str_c("Pathway Probabilities Heatmap ", group),
            fontsize_row = 8,
            fontsize_col = 8
        )

    # Run PCA
    pca_res <- prcomp(pca_input, scale. = TRUE)
    # PCA plot: one dot per sample
    pca_df <- as.data.frame(pca_res$x)
    pca_df$sample <- rownames(pca_df) %>% sub("_.*", "", .) 
    pca_df$group <- sapply(strsplit(rownames(pca_df), "-"), `[`, 2)

    # K-means clustering (choose k=2 for example, adjust as needed)
    set.seed(123)
    k <- 3
    km_res <- kmeans(pca_df[, c("PC1", "PC2")], centers = k)
    pca_df$cluster <- as.factor(km_res$cluster)

    # Plot PCA with clusters
    ggplot(pca_df, aes(x = PC1, y = PC2, label = sample, color = cluster, shape = group)) +
        geom_point(size = 3) +
        geom_text(vjust = -0.5, size = 3) +
        labs(title = stringr::str_c(group, " PCA of Pathway Probabilities with Clustering"),
             x = "PC1", y = "PC2") +
        theme_minimal()

}
## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df_allgenes <-
    do.call(rbind, average_pathways_allgenes)
prob_filter <- mean(average_pathways_df_allgenes$mean_prob)
heatmap_matrix_allgenes <-
    average_pathways_df_allgenes %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    filter(rowSums(across(-pathway_name)) > prob_filter) %>%
    column_to_rownames("pathway_name") %>%
    select(patient_prim, patient_mets, mm_primhuman_ortho, mm_metshuman_ortho,
           xeno_prim_cancer_normal, xeno_mets_cancer_normal,
           dogs_primhuman_ortho, dogs_metshuman_ortho) %>%
    arrange(desc(patient_mets))
# Plot heatmap: group on x-axis, pathway on y-axis
heatmap_allgenes <-
    pheatmap::pheatmap(
        heatmap_matrix_allgenes,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix_allgenes, 2)
)
ggsave("output/figures/cellchat/aallgenes_average_pathway_heatmap_across_all.png",
    heatmap_allgenes,
    width = 10,
    height = 20,
    bg = "white"
)
```






```{r multi_sample_cellchat_analysis_sharedgenes_analysis}

average_pathways <- list()
module_pathways_list <- list()
tumor_sub <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob)) 
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(source,target, interaction_name, prob) #%>%
            # group_by(pathway_name) %>%
            # summarise(prob = sum(prob)) %>%
            # ungroup() %>%
            # mutate(sample = sample_name, group = group) %>%
            # arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    
    #mean filter for probabilities
    mean_filter <- mean(pathways_LR_df$prob)

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        select(sample, pathway_name, prob) %>%
        group_by(pathway_name) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group)
    
    average_pathways[[group]] <- pathway_average

}

## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df <-
    do.call(rbind, average_pathways)
heatmap_matrix <-
    average_pathways_df %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    column_to_rownames("pathway_name") %>%
    select(patient_prim, patient_mets, mm_primhuman_ortho, mm_metshuman_ortho,
           xeno_prim_cancer_normal, xeno_mets_cancer_normal,
           dogs_primhuman_ortho, dogs_metshuman_ortho) %>%
    arrange(desc(patient_mets))
# Plot heatmap: group on x-axis, pathway on y-axis
heatmap<-
    pheatmap::pheatmap(
        heatmap_matrix,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix, 2)
)
ggsave("output/figures/cellchat/sharedgenes_average_pathway_heatmap_across_all.png",
    heatmap,
    width = 10,
    height = 20,
    bg = "white"
)


# plots
for (site in c("prim", "mets")) {
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        column_to_rownames("pathway_name")

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()  
    heatmap_df <-
        site_specific %>%
        filter(rowSums(across(everything())) > mean_filter) %>%
        as.matrix()
    # Plot heatmap: group on x-axis, pathway on y-axis
    heatmap_per_site<-
        pheatmap::pheatmap(
            heatmap_df,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#ff6b6bff","#ff4a4aff","#ff2424ff", "#ff0e0eff"))(100),
            main = "Pathway Mean Probability (Shared Genes)",
            fontsize_row = 8,
            fontsize_col = 10,
            display_numbers = round(heatmap_df, 2)
        )
    ggsave(str_c("output/figures/cellchat/sharedgenes_", site, "_average_pathway_heatmap.png"),
        heatmap_per_site,
        width = 4,
        height = length(colnames(heatmap_df)) * 0.5 + 4,
        bg = "white"
    )

    # plot correlation heatmap
    # Correlation matrix heatmap (already present)
    cor_matrix <-
        cor(site_specific, use = "pairwise.complete.obs")
    pheatmap::pheatmap(
        cor_matrix,
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        color = colorRampPalette(c("#ffe0e0ff", "#fd3f3fff"))(100),
        main = str_c("Correlation Heatmap of Pathways - ", site, " Site"),
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(cor_matrix, 2),
        number_color = "black"
    )  # Alternative visualization: correlation network graph
    library(igraph)
    library(ggraph)

    # Convert correlation matrix to long format for graph
    cor_long <-
        as.data.frame(as.table(cor_matrix))
    colnames(cor_long) <- c("Var1", "Var2", "Correlation")
    cor_long <- cor_long %>% filter(Var1 != Var2 & abs(Correlation) > 0.7)

    # Create igraph object
    g <- graph_from_data_frame(cor_long, directed = FALSE)

    # Plot correlation network
    ggraph(g, layout = "fr") +
        geom_edge_link(aes(edge_alpha = abs(Correlation), edge_width = abs(Correlation), color = Correlation > 0), show.legend = TRUE) +
        geom_node_point(size = 5) +
        geom_node_text(aes(label = name), repel = TRUE) +
        scale_edge_color_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
        labs(title = str_c("Pathway Correlation Network - ", site, " Site")) +
        theme_void()

    # Alternative: pairwise scatterplots
    site_specific_GGPAIRS <-
        site_specific %>%
        rownames_to_column("pathways") %>%
        filter(pathways != "COLLAGEN") %>%
        column_to_rownames("pathways")
    library(GGally)
    GGally::ggpairs(
        site_specific_GGPAIRS,
        lower = list(continuous = wrap("points", alpha = 0.5)),
        upper = list(continuous = wrap("cor", size = 3)),
        diag = list(continuous = wrap("barDiag", fill = "lightblue")),
        title = str_c("Pairwise Pathway Correlations - ", site, " Site"),
        axisLabels = "show"
    )
}
# Fidelity by modules like ECM (compact spacing)
pathway_groups <- list(
    ECM = c("COLLAGEN","LAMININ","FN1","THBS","TENASCIN","AGRN","VWF",
            "ANNEXIN","GAP","PCDH","PTN"),
    Angiogenesis = c("VEGF","PDGF","ANGPT","ANGPTL","FGF","EDN","VWF",
                    "PECAM1","HGF","KIT"),
    ImmuneEvasion = c("MHC-II","CXCL","CCL","TNF","IL1","IL2","IL6",
                    "IL16","OSM","CSF","CD45","CD39",   "CD80","CD86",
                    "ICOS","APRIL","BAFF","CD30","TWEAK","RANKL","CX3C","CysLTs"),
    CellAdhesion = c("CADM","NCAM","PTPRM","CDH","CDH1","CDH5","ICAM",
                    "JAM","SELL","NECTIN","OCLN","CLDN","SEMA3","SEMA5",
                    "SEMA6","Netrin","UNC5","EPHB","EPHA","NRXN"),
    GrowthFactor = c("TGFb","BMP","IGF","NOTCH","WNT","ncWNT","GDF",
                    "RA","HGF","NRG"),
    Metabolic = c("Cholesterol","Desmosterol","DHEA","Estradiol",
                    "Prostaglandin","ENHO","RBP4","CALCR"),
    Other = c("APP","ADGRL","ADGRG","ADGRB","NEGR","FLRT","MPZ",
                "SEMA3","SEMA5","SEMA6","CysLTs")
)


# plots
site_specific_paths <- list()
for (site in c("prim", "mets")) {
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        column_to_rownames("pathway_name")

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()
    pathway_scores <-
        site_specific %>%
        filter(rowSums(across(everything())) > mean_filter) %>%
        as.data.frame() %>%
        rownames_to_column("Pathway") %>%
        rename_with(~ ifelse(str_detect(.x, "dog"), "Dog",
                        ifelse(str_detect(.x, "mm"), "Mouse",
                        ifelse(str_detect(.x, "xeno"), "PDX",
                        ifelse(str_detect(.x, "patient"), "Human", .x)))), .cols = everything()) #%>% 
        # filter(Pathway %in% unlist(pathway_groups))

    site_specific_paths[[site]] <- pathway_scores
    
    aggregate_module <- function(scores_df, groups){
        long <- scores_df %>%
            pivot_longer(-Pathway, names_to="Dataset", values_to="Score") %>%
            mutate(Group = sapply(Pathway, function(p) {
            g <- names(groups)[sapply(groups, function(v) p %in% v)]
            if(length(g)) g[1] else "Other"
            }))
        
        module_summary <- long %>%
            group_by(Group, Dataset) %>%
            summarise(MeanScore = mean(Score, na.rm=TRUE), .groups="drop")
        
        return(module_summary)
    }

    module_summary <- aggregate_module(pathway_scores, pathway_groups)

    # Spread to wide for correlations
    module_wide <- module_summary %>%
    pivot_wider(names_from=Dataset, values_from=MeanScore)

    # Spearman correlation of module patterns
    cor_dog   <- cor(module_wide$Human, module_wide$Dog, method="spearman")
    cor_mouse <- cor(module_wide$Human, module_wide$Mouse, method="spearman")
    cor_pdx   <- cor(module_wide$Human, module_wide$PDX, method="spearman")

    # plot
    ggplot(module_summary, aes(x=Group, y=MeanScore, fill=factor(Dataset, levels=c("Human", "Dog", "PDX", "Mouse")))) +
        geom_bar(stat="identity", position="dodge") +
        scale_fill_manual(
            values = c(
                Human = "#1f77b4",
                Dog = "#ff7f0e",
                PDX = "#d62728",
                Mouse = "#2ca02c"
            ),
            guide = guide_legend(title = NULL)
        ) +
        theme_minimal(base_size=14) +
        ylab("Mean pathway score (aggregated)") +
        xlab("Functional Module") +
        ggtitle("Module-level pathway fidelity across species") +
        theme(
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            axis.line.x = element_line(),
            axis.line.y = element_line()
        )
    }

```

## Statistical comparison for all primary across 
```{r statistical_comparison_pathways_primary_mets}
# > site_specific_paths$prim$Pathway
#  [1] "COLLAGEN"    "LAMININ"     "FN1"         "APP"         "MK"         
#  [6] "SLIT"        "THBS"        "CADM"        "NCAM"        "PTPRM"      
# [11] "TGFb"        "ADGRL"       "PDGF"        "VEGF"        "MPZ"        
# [16] "FLRT"        "PTN"         "Cholesterol" "TENASCIN"    "CDH"        
# [21] "MHC-II"      "UNC5"        "NRXN"        "CXCL"        "NRG"        
# [26] "EPHA"        "Glutamate"   "CCL"        
# > site_specific_paths$mets$Pathway
#  [1] "COLLAGEN"    "LAMININ"     "SLIT"        "FN1"         "ADGRL"      
#  [6] "CADM"        "NCAM"        "PTPRM"       "APP"         "VEGF"       
# [11] "THBS"        "Glutamate"   "UNC5"        "PDGF"        "CDH"        
# [16] "EPHA"        "TGFb"        "FLRT"        "MPZ"         "MK"         
# [21] "Cholesterol" "PTN"         "SEMA3"       "PECAM1"      "TENASCIN"   
# [26] "BMP"         "ADGRG"       "ICAM"        "CCL"         "ANNEXIN"    

average_pathways <- list()
tumor_sub <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "netP") %>%
            arrange(desc(prob))
        
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            # filter(!source %in% tumor_sub) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    average_pathways[[group]] <- pathways_LR_df
}

# perform stats
ttest_results <- list()
comparisons <- list(
    c("patient_prim", "xeno_prim_cancer_normal"),
    c("patient_prim", "dogs_primhuman_ortho"),
    c("patient_prim", "mm_primhuman_ortho"),
    c("patient_mets", "xeno_mets_cancer_normal"),
    c("patient_mets", "dogs_metshuman_ortho"),
    c("patient_mets", "mm_metshuman_ortho")
)


for (comp in comparisons) {
    group1 <- comp[1]
    group2 <- comp[2]

    data_sub <- 
        do.call(rbind, list(average_pathways[[group1]], average_pathways[[group2]])) %>%
        as_tibble() %>%
        as.data.frame()

    # fill up the missing pathways with 0 prob for each sample
    human_vs_another <-
        data_sub %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the total number of samples in each group
    total_number_human <- 
        n_distinct(human_vs_another$sample[human_vs_another$group == group1])
    total_number_another <- 
        n_distinct(human_vs_another$sample[human_vs_another$group == group2]) 
    
    # will use human average to calculate the fold change
    mean_per_pathway_in_human <-
        data_sub %>%
        filter(group == group1) %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob_human = sum(prob)/total_number_human) %>%  
        arrange(desc(mean_prob_human))

    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        human_vs_another %>%
        filter(pathway_name %in% mean_per_pathway_in_human$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway_in_human, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob_human) %>%
        select(sample, group, pathway_name, prob, mean_prob_human, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    # choose top pathways based on primary
    if (str_detect(group1, "prim")) {
        chosen_pathways <- site_specific_paths$prim$Pathway
    } else {
        chosen_pathways <- site_specific_paths$mets$Pathway
    }

    plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% chosen_pathways) %>%
            mutate(group = case_when(
                str_detect(group, "patient") ~ "Human",
                str_detect(group, "dogs") ~ "Dog",
                str_detect(group, "xeno") ~ "PDX",
                str_detect(group, "mm") ~ "Mouse",
                TRUE ~ group
            ))
    plot_pathways$site <-
        ifelse(str_detect(group1, "prim"), "Primary", "Metastatic")
 
    ttest_results[[str_c(group1, "_vs_", group2)]] <- plot_pathways
}

# modules used to arrange the order
pathway_modules <- list(
  ECM_Remodeling = c("COLLAGEN","LAMININ","FN1","THBS","TENASCIN","ANNEXIN","BMP","TGFb"),
  Cell_Adhesion = c("ADGRL","ADGRG","CADM","NCAM","CDH","ICAM","PECAM1"),
  Angiogenic_GrowthFactor = c("VEGF","PDGF","PTN","MK"),
  Immune_Modulation = c("CCL","CXCL","MHC-II","SEMA3"),
  Neural_AxonGuidance = c("SLIT","UNC5","EPHA","FLRT","NRXN","NRG"),
  Metabolic_Signaling = c("Glutamate","Cholesterol","MPZ"),
  Cell_Signaling_Receptors = c("PTPRM","APP")
) %>%
    unlist() %>%
    unique()
# now plot the results all together side by side for each pathway, for each site (Primary and Metastatic)

for (site in c("Primary", "Metastatic")) {
    ttest_results_df_site <-
        do.call(rbind, ttest_results) %>%
        as_tibble() %>%
        as.data.frame() %>%
        filter(site == !!site) %>%
        mutate(comparison = case_when(
            str_detect(group, "PDX") ~ "Human vs PDX",
            str_detect(group, "Dog") ~ "Human vs Dog",
            str_detect(group, "Mouse") ~ "Human vs Mouse"
        )) %>%
        mutate(significance = case_when(
            padj < 0.001 ~ "***",
            padj < 0.05 ~ "**",
            padj < 0.1 ~ "*",
            TRUE ~ "ns"
        ))

    ttest_results_df_site$group <- factor(ttest_results_df_site$group,
        levels = c("Human", "Dog", "PDX", "Mouse"))
    ttest_results_df_site$comparison <- factor(ttest_results_df_site$comparison,
        levels = c("Human vs Dog", "Human vs PDX", "Human vs Mouse"))

    plot <-
        ggplot(
            ttest_results_df_site %>%
                filter(group != "Human", pathway_name %in% pathway_modules) %>%
                mutate(pathway_name = factor(pathway_name, levels = pathway_modules)),
            aes(x = pathway_name, y = log10(norm_prob + 0.0001), fill = group)
        ) +
            geom_boxplot(outlier.shape = NA, width = 0.6, position = position_dodge(width = 0.8)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Dog" = "#ff7f0e", "PDX" = "#d62728", "Mouse" = "#2ca02c")) +
            scale_color_manual(values = c("Dog" = "#ff7f0e", "PDX" = "#d62728", "Mouse" = "#2ca02c")) +
            theme_minimal(base_size = 14) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            labs(
                title = str_c("Pathway Probability Comparison Across Species (", site, ", Excluding Human)"),
                x = "Pathway", y = "Normalized Probability log10"
            ) +
            geom_text(
                data = ttest_results_df_site %>%
                    filter(group != "Human", pathway_name %in% pathway_modules) %>%
                    mutate(pathway_name = factor(pathway_name, levels = pathway_modules)) %>%
                    group_by(pathway_name, group, comparison) %>%
                    summarise(
                        y_pos = min(max(log10(norm_prob + 0.0001), na.rm = TRUE) + 0.1, 22),
                        significance = first(significance),
                        .groups = "drop"
                    ),
                aes(x = pathway_name, y = y_pos, label = significance, group = group),
                inherit.aes = FALSE,
                position = position_dodge(width = 0.8),
                vjust = 0,
                fontface = "bold",
                size = 3
            ) 
            
        ggsave(str_c("output/figures/cellchat/statistical_comparison_pathways_", site, "_across_species.png"),
        plot,
        width = 20,
        height = 5,
        bg = "white"
    )
}


```


## Dig Deepeer into the pathways that are interesting
```{r dig_deeper_pathways}

interesting_pathways <- c("TGFb", "FN1", "LAMININ", "VEGF")
average_pathways <- list()
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        pathways_present <- 
            intersect(interesting_pathways, unique(cellchat@netP$pathways))
        if (length(pathways_present) > 0) {
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                    signaling = pathways_present,
                                    slot.name = "net") %>%
                arrange(desc(prob))

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                select(pathway_name, prob, source, target, interaction_name)
        } else {
            message(str_c("No interesting pathways found in ", sample_name, " of group ", group))
        }
    }
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame()

    pathways_present_all <- 
        unique(pathways_LR_df$pathway_name)
    # help me plot this using ggplot2 source in y axis target in x axis for each intersaction name
    for (pathway in pathways_present_all) {
        pathway_df <-
            pathways_LR_df %>%
            filter(pathway_name == pathway) %>%
            arrange(desc(prob))
    
        # plot fr each pathway for each group
        pathway_df_plot <-
            pathway_df %>%
            group_by(source, target) %>%
            summarise(
                prob = sum(prob, na.rm = TRUE),
                count = n(),
                .groups = "drop"
            )
        # overall plot for the pathway
        plot_path <-
            ggplot(pathway_df_plot, aes(x = target, y = source, size = count, color = prob)) +
                geom_point(alpha = 0.7) +
                scale_color_gradientn(colours = c("#fdeaeaff", "#f8bfbfff",
                                                "#fe9090ff","#ff3737ff", "#ff0d00ff"),
                                        name = "Strength") +  
                theme_minimal(base_size = 14) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                labs(title = str_c("Pathway: ", pathway, " (", group, ")"),x = "Receiver Cell Type", y = "Sender Cell Type")
        if (!dir.exists(str_c("output/figures/cellchat/", group))) {
            dir.create(str_c("output/figures/cellchat/", group), recursive = TRUE)
        }
        ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_overall_plot.png"),
            plot_path,
            width = length(unique(pathway_df_plot$target)) * 0.3 + 3,
            height = length(unique(pathway_df_plot$source)) * 0.3 + 2,
            bg = "white"
        )

        # plot for each interaction
        for (interaction in unique(pathway_df$interaction_name)) {
            interaction_df <-
                pathway_df %>%
                filter(interaction_name == interaction) %>%
                group_by(source, target) %>%
                summarise(
                    prob = sum(prob, na.rm = TRUE),
                    count = n(),
                    .groups = "drop"
                )

            plot_lr <-
                ggplot(interaction_df, aes(x = target, y = source, size = count, color = prob)) +
                    geom_point(alpha = 0.7) +
                    scale_size_continuous(range = range(interaction_df$count, na.rm = TRUE), name = "Count") + 
                    scale_color_gradientn(colours = c("#fdeaeaff", "#f8bfbfff",
                                                    "#fe9090ff","#ff3737ff", "#ff0d00ff"),
                                            name = "Strength") +  
                    theme_minimal(base_size = 14) +
                    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                    labs(title = str_c("Interaction LR: ", interaction, " (Pathway:", pathway, " - ", group, ")"),x = "Receiver Cell Type", y = "Sender Cell Type") 

            if (!dir.exists(str_c("output/figures/cellchat/", group))) {
                dir.create(str_c("output/figures/cellchat/", group), recursive = TRUE)
            }
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_", interaction, "_interaction_plot.png"),
                plot_lr,
                width = length(unique(interaction_df$target)) * 0.3 + 3,
                height = length(unique(interaction_df$source)) * 0.3 + 2,
                bg = "white"
            )
        }
    }
}

# from the plots in TGFb, the alv macroiphages and TAMs seems interesting

# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary

# ligand_target_long <- 
#     as.data.frame(as.matrix(ligand_target_matrix_mouse)) %>%
#     rownames_to_column("ligand") %>%
#     pivot_longer(-ligand, names_to = "target", values_to = "value")

# ggplot(ligand_target_long, aes(x = value)) +
#     geom_histogram(bins = 200, fill = "skyblue", color = "black") +
#     geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
#     labs(title = "Histogram of Ligand-Target Matrix Values",
#             x = "Values", y = "Frequency") +
#     theme_minimal() +
#     xlim(c(0, 0.1))

ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
# mouse 
ligand_target_matrix_mouse <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final_mouse.rds")


for (group in c(
                "patient_prim", "patient_mets",
                "xeno_prim_cancer_normal", "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho", "dogs_metshuman_ortho",
                "mm_primhuman_ortho", "mm_metshuman_ortho",
                "mm_prim", "mm_mets"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    if (object$organism[1] == "human") {
        ligand_target_matrix_use <- ligand_target_matrix
    } else {
        ligand_target_matrix_use <- ligand_target_matrix_mouse
    }
    # Use parallel::mclapply to process ligands in parallel
    ligand_results <- parallel::mclapply(
        c("TGFB1","TGFB2", "FN1", "LAMA1", "LAMB1", "LAMC1", "VEGFA", "VEGFB", "VEGFC"),
        function(ligands) {
            # check if the ligand is expressed in the object
            if (ligands %in% rownames(object)) {
                message(str_c("Processing ligand ", ligands, " in group ", group))
                if (object$organism[1] == "human") {
                    lig <- ligands
                } else {
                    lig <- nichenetr::convert_human_to_mouse_symbols(ligands) %>%
                        as.character()
                }
                if (lig %in% rownames(ligand_target_matrix_use)) {
                    targets <-
                        ligand_target_matrix_use[lig, ] %>%
                        as.data.frame() %>%
                        rownames_to_column("target") %>%
                        rename(score = 2) %>%
                        arrange(desc(score)) %>%
                        filter(score > 0.02) %>%
                        mutate(ligand = lig)
                    #make a expression name with ligands_ligand
                    ligand_display_name <- str_c(ligands, "_ligand")
                    object[[ligand_display_name]] <- GetAssayData(object, slot = "data")[ligands, ]

                    downstream_genes <-
                        targets %>%
                        filter(target %in% rownames(object)) %>%
                        # filter(target != lig) %>%
                        pull(target)
                    if (length(downstream_genes) > 50) {
                        downstream_genes <- downstream_genes[1:50]
                    }
                    # run Aucell with the downstream genes
                    entire_matrix <- object@assays$RNA$counts
                    genelist <- downstream_genes
                    cell_ranks <-
                        AUCell::AUCell_run(exprMat = entire_matrix,
                                           geneSets = genelist)
                    object[[str_c(ligands,"_dwnstrm")]] <- AUCell::getAUC(cell_ranks)[1,]

                    dotplot_everything <-
                        DotPlot(object,
                            #cols = "RdBu",
                            features =  c(ligand_display_name, str_c(ligands,"_dwnstrm"), downstream_genes),
                            group.by = "Ann_Level2",
                            scale = T) +
                            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                            ggtitle(str_c("Ligand: ", ligands, " and Downstream Targets (", group, ")"))
                
                    ggsave(str_c("output/figures/cellchat/", group, "/", ligands, "_ligand_and_downstream_targets.png"),
                            dotplot_everything,
                            width = length(downstream_genes) * 0.3 + 5,
                            height = length(unique(object$Ann_Level2)) * 0.3 + 3,
                            bg = "white")
                    return(TRUE)
                } else {
                    message(str_c("Ligand ", ligands, " not found in ligand-target matrix for ", group))
                    return(FALSE)
                }
            }
            return(FALSE)
        },
        mc.cores = 5 # adjust the number of cores as needed
    )
}






lig <- "Tgfb1"
rownames(ligand_target_matrix_mouse)[str_detect(rownames(ligand_target_matrix_mouse), "Tgfb")]

targets <-
    ligand_target_matrix_mouse[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    filter(score > cutoff) %>%
    mutate(ligand = lig)


downstream_genes <- targets$target

prim <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_prim.qs") %>%
    subset(Ann_Level2 == "TAMs")

# run AUCell score using the downstream genes

entire_matrix <- prim@assays$RNA$counts

genelist <- downstream_genes

cell_ranks <-
    AUCell::AUCell_run(exprMat = entire_matrix,
                    geneSets = genelist)
prim$LAMB1 <- AUCell::getAUC(cell_ranks)[1,]

FeaturePlot(prim,
            features = "LAMB1",
            cols = c("#EEEEEE", "#ae0600"),
            min.cutoff = 0.15,
            pt.size = 1,
            order = TRUE) +
    coord_fixed()


mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/mm_mets.qs")

DotPlot(mets,
        features = downstream_genes[1:20],
        group.by = "Ann_Level2") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
VlnPlot(mets,
        group.by = "Ann_Level2",
        features = downstream_genes[1:10],
        pt.size = 0.1,
        ncol = 5)


combine <-
    merge(prim, mets) %>%
    JoinLayers() %>%
    process_seurat()
dimplot_better(combine, group_by = "unique")
VlnPlot(combine,
        group.by = "unique",
        #split.by = "Ann_Level3",
        ncol = 7,
        features = downstream_genes,
        pt.size = 0.1)




```
















## compare primary vs mets by pathways as a whole
```{r compare_pathways_primary_mets_as_whole}

## compare_pathway networks between primary and mets for clustering using PCA
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## PCA analysis for each sample within primary and mets
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame()

    # fill up the missing pathways with 0 prob for each sample
    df_wide <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        column_to_rownames("sample_group")  

    # perform PCA
    pca_res <- prcomp(df_wide, scale. = TRUE)
    pca_df <- as.data.frame(pca_res$x)
    pca_df$site <-
        rownames(pca_df) %>%
        str_split("-") %>%
        map_chr(2)
    pca_df$sample_group <-
        rownames(pca_df) %>% 
            str_remove("_AnnL2.*$")

    # get the loadings for PC1
    loadings_pc1 <-
        pca_res$rotation %>%
        as.data.frame() %>%
        select(PC2) %>%
        rownames_to_column("pathways") %>%
        arrange(desc(abs(PC2)))

    # plot PCA
    library(ggrepel)
    pca_plot<-
        ggplot(pca_df, aes(x = PC1, y = PC2, label = sample_group)) +
        geom_point(aes(color = site), size = 3) +
        geom_text_repel(size = 3, max.overlaps = Inf) +
        labs(title = str_c("PCA - ", group_prim, " vs ", group_mets),
             x = "PC1", y = "PC2") +
        theme_minimal() 
    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_mets_pathway_probabilities_PCA.png"),
        pca_plot,
        width = 15,
        height = 10,
        bg = "white"
    )
}


sig_pathways <- list()
## Analysis for the pathway and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # fill up the missing pathways with 0 prob for each sample
    fill_prob_prim_mets <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the mean prob for each pathway in both primary and mets separately
    total_number_primary <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
    total_number_mets <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

    mean_per_pathway_in_mets <-
        pathways_prob_df %>%
        filter(group == "Metastatic") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_mets) %>%  
        arrange(desc(mean_prob))
    mean_per_pathway_in_primary <-
        pathways_prob_df %>%
        filter(group == "Primary") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_primary) %>%  
        arrange(desc(mean_prob))
    
    # jopin the two means and keep the higher one
    mean_per_pathway <-
        full_join(x = mean_per_pathway_in_primary,
                  y = mean_per_pathway_in_mets,
                  by = "pathway_name",
                  suffix = c("_prim", "_mets")) %>%
        mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
        select(pathway_name, mean_prob) %>%
        arrange(desc(mean_prob))
    
    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        fill_prob_prim_mets %>%
        filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob) %>%
        select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        group_by(pathway_name, group) %>%
        mutate(fold_change = mean(prob) / max(mean_prob)) %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    prob_filter <- median(pathways_prob_df$prob)
    chosen_pathways <- 
        pathways_prob_df_filtered %>%
        #filter(mean_prob > prob_filter & fold_change < 0.5) %>%
        filter(fold_change < 0.7) %>%
        filter(padj < 0.1) %>%
        arrange(desc(prob)) %>%
        select(pathway_name, fold_change) %>%
        distinct()

    # finally plot the chosen pathways
    if (nrow(chosen_pathways) != 0) {
            # save the chosen pathways
        sig_pathways[[str_c(group_prim, "_vs_", group_mets)]] <-
            chosen_pathways$pathway_name
        
        plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% chosen_pathways$pathway_name) %>%
            mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
            ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = log10(norm_prob+0.0001), fill = group)) +
            geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
            scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
            labs(title = str_c("Top Pathways in ", group_prim, " vs ", group_mets),
                x = "Pathway",
                y = "Normalized Probability (by mean)") +
            theme_minimal() +
                        theme(
                            axis.text.x = element_text(angle = 45, hjust = 1),
                            panel.grid = element_blank(),
                            axis.line.x = element_line(),
                            axis.line.y = element_line())

        ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_pathways_boxplot.png"),
        plot_pathways,
        width = length(chosen_pathways$pathway_name) * 0.6 + 1,
        height = 6,
        limitsize = FALSE,
        bg = "white")
    }
}


```











## Compare prim vs mets pathways tumor as sender and specific celltype as receiver
```{r compare_pathways_primary_mets_specific_receiver}

## compare_pathway networks between primary and mets
# but this time set tumor as sending and normal as receiving

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")

receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

sig_pathways_list <- list()
## Analysis for the pathway and probabilities leve
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # loop for the receiver celltypes
    for (receiver_cell in receiver_celltypes) {
        # list for both primary and mets
        cellchat_list <- list()
        pathways_prob <- list()
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            
            target_cells <- receiver_cell
            
            # filter to LR and pathways and prob
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }
        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            target_cells <- receiver_cell
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
        # this is for the specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_prob) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))
        
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(pathway_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "pathway_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(pathway_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "pathway_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                    group_by(pathway_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(pathway_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(pathway_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(pathway_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(pathway_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "pathway_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(pathway_name, fold_change) %>%
                    distinct()
                # save the significant pathways to a list
                sig_pathways_list[[str_c(receiver_cell, "_in_", group_prim, "_vs_", group_mets)]] <- chosen_pathways

                # finally plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Pathways in ", receiver_cell, " in ",  group_prim, " vs ", group_mets),
                            x = "Pathway",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())
                                    
                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                            dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                            recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_pathways_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant pathway found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    }
}





```





### I want tumor to be the sender and stroma to be the receiver
### look at the top pathways
```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

pathway_of_interest <- c("VEGF", "FN1", "TGFb")


## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob))
        
        target_cells <-
            setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% target_cells) %>% 
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        target_cells <-
            setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
        # target_cells <- receiver_cell

        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% target_cells) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }

    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # only continue if there are both primary and mets samples
    if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
        # fill up the missing pathways with 0 prob for each sample
        fill_prob_prim_mets <-
            pathways_prob_df %>%
            mutate(sample_group = paste(sample, group, sep = "-")) %>%
            select(pathway_name, sample_group, prob) %>%
            pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
            pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
            separate(sample_group, into = c("sample", "group"), sep = "-")

        # calculate the mean prob for each pathway in both primary and mets separately
        total_number_primary <- 
            n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
        total_number_mets <- 
            n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
        
        # only proceed if total number of primary and mets samples are both > 1
        if (total_number_primary > 1 & total_number_mets > 1) {
            mean_per_pathway_in_mets <-
                pathways_prob_df %>%
                filter(group == "Metastatic") %>%
                group_by(pathway_name) %>%
                arrange(desc(prob)) %>%
                summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                arrange(desc(mean_prob))
            mean_per_pathway_in_primary <-
                pathways_prob_df %>%
                filter(group == "Primary") %>%
                group_by(pathway_name) %>%
                arrange(desc(prob)) %>%
                summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                arrange(desc(mean_prob))
            
            # jopin the two means and keep the higher one
            mean_per_pathway <-
                full_join(x = mean_per_pathway_in_primary,
                        y = mean_per_pathway_in_mets,
                        by = "pathway_name",
                        suffix = c("_prim", "_mets")) %>%
                mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                select(pathway_name, mean_prob) %>%
                arrange(desc(mean_prob))
            
            # to calculate the pvalue
            myfun <- function(x) {
                x$pvalue <-
                    t.test(prob ~ group, data = x)$p.value
                return(x)
            }

            # now filter pathways for primary
            pathways_prob_df_filtered <- 
                fill_prob_prim_mets %>%
                filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                arrange(desc(prob)) %>%
                left_join(mean_per_pathway, by = "pathway_name") %>%
                mutate(norm_prob = prob / mean_prob) %>%
                select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                group_by(pathway_name) %>%
                group_split() %>%
                map(~ myfun(.x)) %>%
                bind_rows() %>%
                group_by(pathway_name, group) %>%
                mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                arrange(pathway_name) %>%
                ungroup()

            pull_path_pval <-
                pathways_prob_df_filtered %>%
                select(pathway_name, pvalue) %>%
                distinct() %>%
                mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                select(pathway_name, padj)

            # put the padj baclk to the pathways_prob_df_filtered
            pathways_prob_df_filtered <-
                pathways_prob_df_filtered %>%
                left_join(pull_path_pval, by = "pathway_name")

            prob_filter <- median(pathways_prob_df$prob)
            chosen_pathways <- 
                pathways_prob_df_filtered %>%
                filter(mean_prob > prob_filter & fold_change < 0.75) %>%
                filter(padj < 0.1) %>%
                arrange(desc(prob)) %>%
                select(pathway_name, fold_change) %>%
                distinct()

            # plot the chosen pathways
            if (nrow(chosen_pathways) != 0) {
                plot_pathways <-
                    pathways_prob_df_filtered %>%
                    filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                    mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                    ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                    geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                    geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                    scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                    scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                    labs(title = str_c("Top overall sharedgenes pathways in" , group_prim, " vs ", group_mets),
                        x = "Interaction",
                        y = "Normalized Probability (by mean)") +
                    theme_minimal() +
                                theme(
                                    axis.text.x = element_text(angle = 45, hjust = 1),
                                    panel.grid = element_blank(),
                                    axis.line.x = element_line(),
                                    axis.line.y = element_line())

                if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                    dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                    recursive = TRUE)
                }
                ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/sharedgenes_all_pathways_boxplot.png"),
                plot_pathways,
                width = max(length(chosen_pathways$pathway_name) * 0.75 + 1, 6),
                height = 6,
                bg = "white")
            } else {
                message("No significant interactions found for ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough samples in either primary or metastatic group for  ", group_prim, " vs ", group_mets)
        }
    } else {
        message("Not enough groups or interactions for ", group_prim, " vs ", group_mets)
    }
} 



## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```










### I want tumor to be the sender and stroma to be the receiver but only for significant pathways
## for each celltypes shown by analysis above where I look at tumor as sender and specific celltype as receiver

```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor", "Proliferative", "COMA", "MP_Progenitor")


receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

# celltype by signigicant patways from previous analysis


## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    for (receiver_cell in receiver_celltypes) {
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))

            target_cells <- receiver_cell

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                filter(pathway_name == "LAMININ") %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }

        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))
            # target_cells <-
            #     setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
            target_cells <- receiver_cell

            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                filter(pathway_name == "LAMININ") %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
    
        # this is for the specific interactions across primary and mets
        # specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_LR) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))

        # only continue if there are both primary and mets samples
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {

            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(interaction_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-interaction_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
            
            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "interaction_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(interaction_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(interaction_name %in% mean_per_pathway$interaction_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "interaction_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, interaction_name, prob, mean_prob, norm_prob) %>%
                    group_by(interaction_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(interaction_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(interaction_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(interaction_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(interaction_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "interaction_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(interaction_name, fold_change) %>%
                    distinct()

                # plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(interaction_name %in% chosen_pathways$interaction_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(interaction_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Interactions from Tumor to ", receiver_cell," in ",group_prim, " vs ", group_mets),
                            x = "Interaction",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())

                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                        dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                        recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_LR_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant interactions found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    } 
}


## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```


































## Leverage Nichenet to identify dowstream
```{r nichenet_downstream_analysis}

# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary
ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
    # Convert the ligand_target_matrix to a long data frame for ggplot

ligand_target_long <- 
    as.data.frame(as.matrix(ligand_target_matrix)) %>%
    rownames_to_column("ligand") %>%
    pivot_longer(-ligand, names_to = "target", values_to = "value")

ggplot(ligand_target_long, aes(x = value)) +
    geom_histogram(bins = 200, fill = "skyblue", color = "black") +
    geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
    labs(title = "Histogram of Ligand-Target Matrix Values",
            x = "Values", y = "Frequency") +
    theme_minimal() +
    xlim(c(0, 0.1))
cutoff <- 0.01

lig <- "LAMB1"
targets <-
    ligand_target_matrix[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    filter(score > cutoff) %>%
    mutate(ligand = lig)
downstream_genes <- targets$target

prim <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_prim.qs") %>%
    subset(Ann_Level2 == "TAMs")

# run AUCell score using the downstream genes

entire_matrix <- prim@assays$RNA$counts

genelist <- downstream_genes

cell_ranks <-
    AUCell::AUCell_run(exprMat = entire_matrix,
                    geneSets = genelist)
prim$LAMB1 <- AUCell::getAUC(cell_ranks)[1,]

FeaturePlot(prim,
            features = "LAMB1",
            cols = c("#EEEEEE", "#ae0600"),
            min.cutoff = 0.15,
            pt.size = 1,
            order = TRUE) +
    coord_fixed()


mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs") %>%
    subset(Ann_Level2 == "TAMs")


combine <-
    merge(prim, mets) %>%
    JoinLayers() %>%
    process_seurat()
dimplot_better(combine, group_by = "unique")
VlnPlot(combine,
        group.by = "unique",
        #split.by = "Ann_Level3",
        ncol = 7,
        features = downstream_genes,
        pt.size = 0.1)

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
           pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))  
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))  
    
    }
    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # filter the pathways interested
    interested_pathways <-
        c("FN1", "LAMININ")

    pathways_LR_df_interested <-
        pathways_LR_df %>%
        filter(pathway_name %in% interested_pathways) %>%
        arrange(desc(prob))

    # identify the top downstream activated genes for each top ligand using nichenet
    top_ligands <-
        pathways_LR_df_interested %>%
        distinct(interaction_name) %>%
        separate(interaction_name, into = c("ligand", "receptor"), sep = "_") %>%
        distinct(ligand) %>%
        pull(ligand)

    top_targets <- list()
    for (lig in top_ligands) {
        if (lig %in% rownames(ligand_target_matrix)) {
            targets <-
                ligand_target_matrix[lig, ] %>%
                as.data.frame() %>%
                rownames_to_column("target") %>%
                rename(score = 2) %>%
                arrange(desc(score)) %>%
                head(20) %>%
                mutate(ligand = lig)
            top_targets[[lig]] <- targets

        }



}













```



















## spatial nichenet

```{r spatial_nichenet_analysis}

average_spatial_leestat <- 
    read_tsv("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/spacexr/granular_references/lee_perms/average_lee_stats.tsv") 

not_correlated <-
    average_spatial_leestat %>%
    filter(group != "Correlated")

ggplot(data.frame(value = correlated$lee_stat), aes(x = value)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black") +
    ggtitle("Histogram of Correlated Lee Stat Values") +
    xlab("Lee Stat")


df_pairs <-
    average_spatial_leestat %>%
    rownames_to_column("Cell1") %>%
    pivot_longer(-Cell1, names_to = "Cell2", values_to = "LeeStat") %>%
    filter(Cell1 != Cell2)

# Select top 10% values
threshold <- quantile(df_pairs$LeeStat, 0.95)

top_pairs <- df_pairs %>% filter(LeeStat >= threshold)
high_cells <- top_pairs %>%
  gather(CellRole, Cell, Cell1:Cell2) %>%
  group_by(Cell) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))

# Option 1: Use a fixed LeeStat threshold (e.g., 0.1)
fixed_threshold <- 0.2
top_pairs_fixed <- df_pairs %>% filter(LeeStat >= fixed_threshold)
high_cells_fixed <- 
    top_pairs_fixed %>%
    gather(CellRole, Cell, Cell1:Cell2) %>%
    group_by(Cell) %>%
    summarise(Count = n()) %>%
    arrange(desc(Count))








# Example grouping (you can expand/modify)
pathway_groups <- list(
  ECM = c("COLLAGEN","FN1","LAMININ","TENASCIN","THBS","CADM","NCAM"),
  Angiogenesis = c("VEGF","PDGF","EPHA","PECAM1","NRG","FLRT","ANGPTL"),
  Immune = c("TGFb","MIF","APP","TWEAK","SEMA3","IGF","CXCL","CCL","IL1","TNF"),
  CellAdhesion = c("PTPRM","ICAM","JAM","NECTIN","UNC5","Netrin"),
  GrowthMetabolic = c("Cholesterol","Glutamate","DHEA","PTN","MK")
)

pathway_scores <- data.frame(
  Pathway = c("COLLAGEN","FN1","VEGF","TGFb","Cholesterol"),
  Human = c(0.8,0.7,0.9,0.6,0.3),
  Dog   = c(0.75,0.6,0.2,0.5,0.1),
  Mouse = c(0.5,0.4,0.1,0.2,0.05),
  PDX   = c(0.85,0.65,0.8,0.55,0.2)
)

library(dplyr)
library(tidyr)

aggregate_module <- function(scores_df, groups){
  long <- scores_df %>%
    pivot_longer(-Pathway, names_to="Dataset", values_to="Score") %>%
    mutate(Group = sapply(Pathway, function(p) {
      g <- names(groups)[sapply(groups, function(v) p %in% v)]
      if(length(g)) g[1] else "Other"
    }))
  
  module_summary <- long %>%
    group_by(Group, Dataset) %>%
    summarise(MeanScore = mean(Score, na.rm=TRUE), .groups="drop")
  
  return(module_summary)
}

module_summary <- aggregate_module(pathway_scores, pathway_groups)
print(module_summary)

# Spread to wide for correlations
module_wide <- module_summary %>%
  pivot_wider(names_from=Dataset, values_from=MeanScore)

# Spearman correlation of module patterns
cor_dog   <- cor(module_wide$Human, module_wide$Dog, method="spearman")
cor_mouse <- cor(module_wide$Human, module_wide$Mouse, method="spearman")
cor_pdx   <- cor(module_wide$Human, module_wide$PDX, method="spearman")

print(cor_dog); print(cor_mouse); print(cor_pdx)

library(ggplot2)

ggplot(module_summary, aes(x=Group, y=MeanScore, fill=Dataset)) +
  geom_bar(stat="identity", position="dodge") +
  theme_minimal(base_size=14) +
  ylab("Mean pathway score (aggregated)") +
  xlab("Functional Module") +
  ggtitle("Module-level pathway fidelity across species")


```





```{r multi_sample_cellchat_analysis_sharedgenes_analysis}

average_pathways <- list()
module_pathways_list <- list()
tumor_sub <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob)) 
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            mutate(target_LR =
                    paste(target, interaction_name, sep="-")) %>%
            select(target_LR, prob) %>%
            group_by(target_LR) %>%
            summarise(prob = sum(prob)) %>%
            ungroup()
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        group_by(target_LR) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group) %>%
        ungroup()
    
    average_pathways[[group]] <- pathway_average

}

## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df <-
    do.call(rbind, average_pathways)
heatmap_matrix <-
    average_pathways_df %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    column_to_rownames("target_LR")

# Plot heatmap: group on x-axis, pathway on y-axis
heatmap<-
    pheatmap::pheatmap(
        heatmap_matrix,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix, 2)
)
ggsave("output/figures/cellchat/sharedgenes_average_pathway_heatmap_across_all.png",
    heatmap,
    width = 10,
    height = 20,
    bg = "white"
)

patientprimt <-
    average_pathways_df %>%
    filter(str_detect(group, "patient_prim")) %>%
    as.data.frame()

hist(patientprimt$mean_prob, n=100)
# plots
for (site in c("prim", "mets")) {
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        column_to_rownames("target_LR")

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()  
    heatmap_df <-
        site_specific %>%
        filter(rowSums(across(everything())) > mean_filter) %>%
        as.matrix()
    # Plot heatmap: group on x-axis, pathway on y-axis
    heatmap_per_site<-
        pheatmap::pheatmap(
            heatmap_df,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#ff6b6bff","#ff4a4aff","#ff2424ff", "#ff0e0eff"))(100),
            main = "Pathway Mean Probability (Shared Genes)",
            fontsize_row = 8,
            fontsize_col = 10,
            display_numbers = round(heatmap_df, 2)
        )
    ggsave(str_c("output/figures/cellchat/sharedgenes_", site, "_average_pathway_heatmap.png"),
        heatmap_per_site,
        width = 4,
        height = length(colnames(heatmap_df)) * 0.5 + 4,
        bg = "white"
    )

    # plot correlation heatmap
    # Correlation matrix heatmap (already present)
    cor_matrix <-
        cor(site_specific, use = "everything", method = "spearman")
    pheatmap::pheatmap(
        cor_matrix,
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        color = colorRampPalette(c("#ffe0e0ff", "#fd3f3fff"))(100),
        main = str_c("Correlation Heatmap of Pathways - ", site, " Site"),
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(cor_matrix, 2),
        number_color = "black"
    )  # Alternative visualization: correlation network graph
    library(igraph)
    library(ggraph)

    # Convert correlation matrix to long format for graph
    cor_long <-
        as.data.frame(as.table(cor_matrix))
    colnames(cor_long) <- c("Var1", "Var2", "Correlation")
    cor_long <- cor_long %>% filter(Var1 != Var2 & abs(Correlation) > 0.7)

    # Create igraph object
    g <- graph_from_data_frame(cor_long, directed = FALSE)

    # Plot correlation network
    ggraph(g, layout = "fr") +
        geom_edge_link(aes(edge_alpha = abs(Correlation), edge_width = abs(Correlation), color = Correlation > 0), show.legend = TRUE) +
        geom_node_point(size = 5) +
        geom_node_text(aes(label = name), repel = TRUE) +
        scale_edge_color_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
        labs(title = str_c("Pathway Correlation Network - ", site, " Site")) +
        theme_void()

    # Alternative: pairwise scatterplots
    site_specific_GGPAIRS <-
        site_specific %>%
        rownames_to_column("pathways") %>%
        filter(pathways != "COLLAGEN") %>%
        column_to_rownames("pathways")
    library(GGally)
    GGally::ggpairs(
        site_specific_GGPAIRS,
        lower = list(continuous = wrap("points", alpha = 0.5)),
        upper = list(continuous = wrap("cor", size = 3)),
        diag = list(continuous = wrap("barDiag", fill = "lightblue")),
        title = str_c("Pairwise Pathway Correlations - ", site, " Site"),
        axisLabels = "show"
    )
}