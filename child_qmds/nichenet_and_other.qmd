

## Run Nichenet and other analyses
This section is to convert the genes into human orthologs and run cell-cell communication analysis using CellChat package.
```{r cell_cell_communication}
object_list <-
    tribble(~group1,                         ~group2,                       ~group3,
            "xeno_prim_mouse",              "xeno_prim_human_cancer_cells", "xeno_prim_cancer_normal",
            "xeno_mets_mouse",              "xeno_mets_human_cancer_cells", "xeno_mets_cancer_normal"
            )

# conver the xeno mouse stroma into human symbols
for (i in 1:nrow(object_list)) {
    group1 <- object_list$group1[i]
    group2 <- object_list$group2[i]
    group3 <- object_list$group3[i]
    object1 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group1,
                        ".qs"))
    raw_counts <-
        GetAssayData(object1,
                     slot = "counts")

    human_genes <-
        object1 %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object1@meta.data)
    object1 <-
        new_seurat_object %>%
        process_seurat()

    object2 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group2,
                        ".qs"))
    combined_object <-
        merge(object1, object2) %>%
        JoinLayers() %>%
        process_seurat() %>%
        RunHarmony(group.by.vars = c("sample_name", "model"),
                    theta = c(12, 12),
                    lambda = c(0.1, 0.1)) %>%
        process_seurat(reduction = "harmony")

    combined_object$organism <- "human"
    combined_object$unique <- group3

    qs::qsave(combined_object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group3,
                    ".qs"))
}

# convert dog to human symbols
orthologs <-
    read_tsv("input/downloads/dog_human_gene_orthologs.txt")
for (group in c("dogs_prim",
                "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")

    number_of_ENSEMBL_genes <-
        sum(str_detect(rownames(raw_counts), "^ENSCAFG"))

    raw_counts_new <-
        raw_counts[rownames(raw_counts) %in% orthologs$dog_gene_name, ]
    rownames(raw_counts_new) <-
        orthologs$human_gene_ortholog[match(rownames(raw_counts_new), orthologs$dog_gene_name)]
    new_seurat_object <-
        CreateSeuratObject(counts = raw_counts_new) %>%
        AddMetaData(metadata = object@meta.data)
    newobject <-
        new_seurat_object %>%
        process_seurat()
    newobject$organism <- "human"
    qs::qsave(newobject,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

for (group in c("mm_prim",
                "mm_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")
    human_genes <-
        object %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object@meta.data)
    object <-
        new_seurat_object %>%
        process_seurat()
    
    object$organism <- "human"
    qs::qsave(object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

# function for cellchat function
suppressPackageStartupMessages({
  library(CellChat); library(patchwork)
})
run_cellchat <- function(sobject,
                        group.by="celltype",
                        species_db="human") {
    data.input <- GetAssayData(sobject, assay="RNA", slot="data")  # log-normalized
    meta <- data.frame(labels = sobject[[group.by]][,1], row.names=colnames(sobject))
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
    cellchat@DB <- if (species_db=="human") CellChatDB.human else CellChatDB.mouse
    future::plan("multisession", workers = 10) # do parallel
    cellchat <- 
        subsetData(cellchat) %>%
        identifyOverExpressedGenes() %>%
        identifyOverExpressedInteractions() %>%
        computeCommunProb() %>%
        filterCommunication(min.cells = 10) %>%
        computeCommunProbPathway() %>%
        aggregateNet() %>%
        netAnalysis_computeCentrality()
        # computeNetSimilarity(type = "functional") %>%
        # netEmbedding(type = "functional") %>%
        # netClustering(type = "functional", do.parallel = FALSE) %>%
        # computeNetSimilarity(type = "structural") %>%
        # netEmbedding(type = "structural") %>%
        # netClustering(type = "structural", do.parallel = FALSE)
  return(cellchat)
}

pathways_by_module <-
    CellChatDB.human$interaction %>%
    select(pathway_name, annotation) %>%
    group_by(annotation) %>%
        summarise(pathways = list(unique(pathway_name)))

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim",
                # "patient_mets"
                # "mm_prim",
                # "mm_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho"
                "mm_primhuman_ortho"
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects", "/", group))) {
                dir.create(str_c("output/cellchat_objects", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}



# cellchat at ann_level2 using all the pathways general identify the shared genes only
list_of_genes <- list()
samples_numbers <- list()
for (group in c(
                # "patient_prim",
                # "patient_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal",
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho",
                # "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    samples_numbers[[group]] <- length(unique(object$sample_name))

    genes <- rownames(object)
    list_of_genes[[group]] <- genes
}

# shared genes
shared_genes <-
    Reduce(intersect, list_of_genes) %>%
    as_tibble()

# save the shared genes
write_tsv(shared_genes,
          "input/shared_genes_across_groups_for_cellchat.txt")

# load the shared genes
shared_genes <-
    read_tsv("input/shared_genes_across_groups_for_cellchat.txt",
            col_names = "gene")  %>%
            as.data.frame()

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim"
                # "patient_mets"
                # "xeno_prim_cancer_normal"
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho"
                # "dogs_metshuman_ortho"
                "mm_primhuman_ortho"
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    object <-
        subset(object, features = shared_genes$gene) %>%
        process_seurat()

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects_sharedgenes", "/", group))) {
                dir.create(str_c("output/cellchat_objects_sharedgenes", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}




```

### Plotting for cellchat
```{r cellchat_plots}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

    object_list[[group]] <- cellchat

    # 8. visualize the aggregated cell-cell communication network
    groupSize <- as.numeric(table(cellchat@idents))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
        dir.create(str_c("output/figures/cellchat/", group),
                    recursive = TRUE)
    }
    p1 <- netVisual_circle(cellchat@net$count,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Number of interactions")
    p2 <- netVisual_circle(cellchat@net$weight,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Interaction weights/strength")
    combined_plot <- 
        plot_grid(p1, p2, ncol = 1) +
        patchwork::plot_annotation(title = stringr::str_c(group," everything "))
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.pdf"),
        combined_plot,
        width = 15,
        height = 30
    )
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.png"),
        combined_plot,
        width = 15,
        height = 30
    )
    #  examine the signaling sent from each cell group
    mat <- cellchat@net$weight
    plot_list1 <- list()
    for (i in 1:nrow(mat)) {
        mat2 <- 
            matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
        mat2[i, ] <- mat[i, ]
        plot_list1[[i]] <-
            netVisual_circle(mat2, 
                                vertex.weight = groupSize,
                                weight.scale = F, 
                            edge.weight.max = max(mat),
                            title.name = rownames(mat)[i]) 
    }
    combined_plot1 <- 
        plot_grid(plotlist = plot_list1, ncol = 3) +
        patchwork::plot_annotation(title = stringr::str_c(group," ", subset_db))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "outgoing_signaling.png"),
        combined_plot1,
        width = 21,
        height = 7 * length(plot_list1)/3
    )

    future::plan("multisession", workers = 10) # do parallel
    # 9. Identify the signaling roles of cell
    cellchat@netP[["pathways"]]
    # rank the pathways 
    ranked_pathways <-
        rankNet(cellchat, mode="single")
    ggsave(str_c("output/figures/cellchat/", group, "/everything_ranked_pathways.png"),
        ranked_pathways,
        width = 10,
        height = 15
    )
    # reveal all the ligand-receptor pairs for a signaling pathway
    extractEnrichedLR(cellchat, signaling = c(cellchat@netP[["pathways"]]),
                    geneLR.return = TRUE)

    # visualize the contribution of each LR pairs to the communication network
    netAnalysis_contribution(cellchat, 
                            signaling = c(cellchat@netP[["pathways"]]), 
                            title = "Contribution of each LR pairs")
    # visualize the contribution of each LR pairs to the communication network top5
    top5_ligand_receptor_pairs <-
        netAnalysis_contribution(cellchat, 
                                signaling = c(cellchat@netP[["pathways"]][1]))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "top5_ligand_receptor_pairs.png"),
        top5_ligand_receptor_pairs,
        width = 10,
        height = 15
    )
    # 10. Visualize cell-cell communication mediated by specific signaling pathways
    extractEnrichedLR(cellchat, signaling = "COLLAGEN", geneLR.return = FALSE)
    netAnalysis_contribution(cellchat, signaling = "COLLAGEN")

    # Circle plot
    netVisual_aggregate(cellchat, signaling = "COLLAGEN", layout = "circle")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1")

    # Arrange so that tumor are on one side in the chord diagram
    # Define group.cellType so that tumor cell types are grouped together
    # Example: assign "Tumor" to tumor clusters, others as before
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive", "Stressed")
    other_clusters <- setdiff(levels(cellchat@idents), tumor_clusters)

    group.cellType <- c(
        rep("Tumor", length(tumor_clusters)),
        rep("Other", length(other_clusters)))
    names(group.cellType) <- c(tumor_clusters, other_clusters)

    chord_plot <-
        netVisual_chord_cell(cellchat, signaling = "COLLAGEN", 
            group = group.cellType, 
            title.name = paste0("COLLAGEN_", "signaling network"))

    # Chord diagram: define source and target cell types
    netVisual_chord_gene(cellchat, sources.use = 4, targets.use = c(5:6), 
                        lab.cex = 0.5,legend.pos.y = 30)

    netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4), targets.use = 8,
                        lab.cex = 0.5, legend.pos.x = 15)

    # Chord diagram: show LR pairs associated with certain signaling pathways
    netVisual_chord_gene(cellchat,
                         sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c("TAMs"),
                        signaling = c("COLLAGEN"),legend.pos.x = 8)

    # Hierarchy plot 
    # Define tumor clusters as vertex.receiver for hierarchy plot
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive")
    vertex.receiver <- which(levels(cellchat@idents) %in% tumor_clusters)

    netVisual_aggregate(cellchat, signaling = "COLLAGEN", 
                        vertex.receiver = vertex.receiver, layout = "hierarchy")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1", 
                        vertex.receiver = vertex.receiver, 
                        layout = "hierarchy")

    # Heatmap for sender receiver pairs for a specific signaling pathway
    netVisual_heatmap(cellchat, signaling = "COLLAGEN", color.heatmap = "Reds")

    # bubble plot 
    # bubble plot: show all LR pairs from source to target cell groups
    netVisual_bubble(cellchat, sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c(1:10), 
                    remove.isolate = FALSE) 

    # bubble plot: show LR pairs associated with certain signaling pathways
    netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:12), 
                    signaling = c("COLLAGEN"), remove.isolate = FALSE)
                
    # 1. Compute the network centrality scores
    cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP")

    # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- netAnalysis_signalingRole_scatter(cellchat) + coord_fixed()
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_aggregated_network.png"),
        aggregated_network,
        width = 7,
        height = 7
    )

    # Scatter plot to Visualize selected communication networks
    netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    # Heatmap to visualize dominant cell types for each signaling pathway
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing", height = 11)
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming", height = 11)

    # Visualize selected outgoing/incoming signals and contributing cell types
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing",
                                        signaling = c("COLLAGEN"))
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming",
                                        signaling = c("COLLAGEN"))

    # Heatmap to visualize major signaling roles of different cell groups
    netAnalysis_signalingRole_network(cellchat, signaling = "FN1", width = 10, 
                                    height = 5, font.size = 10)

    # 2. Identify global communication patterns to explore how multiple cell types 
    # and signaling pathways coordinate
    # Identify and visualize outgoing communication pattern of secreting cells
    selectK(cellchat, pattern = "outgoing") # infer the number of patterns, NMF
    nPatterns = 4 # a suitable number of patterns is the one begin to drop suddenly.
    cellchat <- identifyCommunicationPatterns(cellchat, pattern = "outgoing",
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "outgoing") # river plot
    netAnalysis_dot(cellchat, pattern = "outgoing") # dot plot

    ## Identify and visualize incoming communication pattern of target cells
    selectK(cellchat, pattern = "incoming")
    nPatterns = 4
    cellchat <- identifyCommunicationPatterns(cellchat,pattern = "incoming", 
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "incoming") # river plot
    netAnalysis_dot(cellchat, pattern = "incoming") # dot plot

    # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)

    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "functional", nCol = 2)

    # Identify signaling groups based on structure similarity
    # multimeric ligand-receptor complexes, soluble agonists and antagonists, 
    # stimulatory and inhibitory co-ligands and co-receptors
    cellchat <- computeNetSimilarity(cellchat, type = "structural")
    cellchat <- netEmbedding(cellchat, type = "structural")
    cellchat <- netClustering(cellchat, type = "structural",do.parallel = FALSE)

    # Visualization in 2D-space
    structural_gene_groups <-
        netVisual_embedding(cellchat, type = "structural", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_structural_gene_groups.png"),
        structural_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "structural", nCol = 2)
}



object_list <- list()
collagen_bubble <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

     # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- 
        netAnalysis_signalingRole_scatter(cellchat) +
        coord_fixed() +
        ggtitle(str_c(group," aggregated network"))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
    dir.create(str_c("output/figures/cellchat/", group),
                recursive = TRUE)
    }
    ggsave(str_c("output/figures/cellchat/", group, "/", "ann2_aggregated_network.png"),
        aggregated_network,
        width = 10,
        height = 10)

    # Visualize selected outgoing/incoming signals and contributing cell types
        # Scatter plot to Visualize selected communication networks
    collagen_bubble[[group]] <-
        netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    ggsave(str_c("output/figures/cellchat/", group, "/", "collagen_bubble.png"),
        collagen_bubble[[group]],
        width = 10,
        height = 10)
    
     # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)
    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5) +
        ggtitle(str_c(group," functional gene groups"))
    ggsave(str_c("output/figures/cellchat/", group, "/", "functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )

    png(filename = str_c("output/figures/cellchat/", group, "/", "collagen_network_heatmap.png"),
        width = 1000, height = 500, res = 300)
    netAnalysis_signalingRole_network(cellchat, signaling = "COLLAGEN", width = 10, height = 5, font.size = 10)

    dev.off()
}

```


## comparative cellchat analysis
```{r cellchat_comparative analysis}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))
    
    # qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs")) 

    object_list[[group]] <- cellchat
            }

# rank the pathways and compare across groups
rankNet(object_list$mm_metshuman_ortho, mode="single")
rankNet(mergeCellChat(list(object_list$patient_prim,
                            object_list$mm_primhuman_ortho),
        add.names=c("patient","xeno")),
        mode="comparison",
        stacked = TRUE)
rankNet(mergeCellChat(list(object_list$mm_primhuman_ortho,
                            object_list$mm_metshuman_ortho),
        add.names=c("patient","xeno", "dog")),
        mode="comparison",
        stacked = FALSE)

get_pathway_flow <- function(cc,
                             dataset_name) {
    flows <- 
        apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE))
    data.frame(pathway = names(flows),
            information_flow = as.numeric(flows),
            dataset = dataset_name,
            stringsAsFactors = FALSE)
}

# Collect all datasets and perform PCA for each dataset
df_list <- 
    Map(get_pathway_flow, object_list,
    names(object_list))
df_all <-
    do.call(rbind, df_list) %>%
    as_tibble() %>%
    as.data.frame()
# Pivot to wide format: rows = pathway, columns = dataset, values = information_flow
df_wide <- df_all %>%
    select(pathway, dataset, information_flow) %>%
    tidyr::pivot_wider(names_from = dataset,
                        values_from = information_flow,
                        values_fill = 0)
# Set rownames to pathway and remove pathway column
mat_t <- 
    as.data.frame(df_wide) %>%
    column_to_rownames("pathway") %>%
    t()

# Scale and run PCA
pca_res <- prcomp(mat_t, scale. = TRUE)

# PCA plot: one dot per group (dataset)
pca_df <- as.data.frame(pca_res$x)
pca_df$group <- rownames(pca_df)

library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, label = group)) +
    geom_point(size = 3) +
    geom_text(vjust = -0.5, size = 3) +
    labs(title = "PCA of Pathway Information Flow (one dot per group)",
            x = "PC1", y = "PC2") +
    theme_minimal()

# the pathways that drive the differences between groups
loading_scores_df <-
    pca_res$rotation %>%
    as.data.frame() %>%
    rownames_to_column("pathway")



# Function to compare pathways between two CellChat objects (e.g. primary vs. mets)
compare_pathways <- function(cc_primary,
                            cc_mets) {
                        
    info_primary <- 
        cc_primary@netP$pathways %>% 
        data.frame(pathway = .,
                flow = apply(cc_primary@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    info_mets <- 
        cc_mets@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc_mets@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))

    merged <- 
        merge(info_primary, info_mets, by="pathway", suffixes = c("_prim", "_mets"))
    merged$diff_mets_up <- merged$flow_mets - merged$flow_prim
    merged$diff_prim_up <- merged$flow_prim - merged$flow_mets

    merged
}

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    patient_diff <-
        compare_pathways(cc_primary = object_list[[group_prim]],
                        cc_mets = object_list[[group_mets]])

    # Sort and visualize
    # Top 10 pathways enriched in mets (mets > primary)
    top_diff_mets_up <-
        head(patient_diff[order(-patient_diff$diff_mets_up), ], 10)

    # Top 10 pathways enriched in primary (primary > mets)
    top_diff_prim_up <-
        head(patient_diff[order(-patient_diff$diff_prim_up), ], 10)

    # Barplot of top pathways enriched in mets (mets > primary)
    top_diff_mets_up$group <- "Metastasis"
    # Barplot of top pathways enriched in primary (primary > mets)
    top_diff_prim_up$group <- "Primary"

    # Combine top pathways for plotting
    top_diff_combined <- rbind(
        top_diff_mets_up %>% dplyr::select(pathway, flow_mets, flow_prim, group),
        top_diff_prim_up %>% dplyr::select(pathway,  flow_mets, flow_prim, group))

    # Reshape to long format for ggplot
    top_diff_long <-
        top_diff_combined %>%
        tidyr::pivot_longer(cols = c(flow_prim, flow_mets),
                            names_to = "condition",
                            values_to = "information_flow") %>%
        mutate(condition = ifelse(condition == "flow_prim", "Primary", "Metastasis")) %>%
        arrange(desc(group), information_flow) %>%
        mutate(pathway = factor(pathway, levels = unique(pathway)))

    ggplot(top_diff_long,
                    aes(x = information_flow, y = pathway,
                            fill = condition)) +
        geom_bar(stat = "identity", position = "dodge") +
        labs(title = "Top 10 Differential Pathways: Metastasis vs. Primary",
                x = "Information Flow", y = "Pathway") +
        scale_fill_manual(values = c("Metastasis" = "#E41A1C", "Primary" = "#377EB8")) +
        theme_minimal()

    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "_top_diff_pathways.png"),
        width = 10,
        height = 10,
        bg = "white"
    )
}



# look at top five pathways for everything
pathways_list <- list()

for (item in names(object_list)) {
    cc <- object_list[[item]]
    top_pathways <-
        cc@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    top5 <-
        head(top_pathways[order(-top_pathways$flow), ], 5) %>%
        mutate(group = item)

    pathways_list[[item]] <- top5
}

pathwys_df <-
    do.call(rbind, pathways_list) %>%
    as_tibble() %>%
    as.data.frame()

# Define plot_cols as a named vector, e.g.:
# plot_cols <- c("patient_prim"="#1f77b4", "patient_mets"="#ff7f0e", ...)
top5_all <-
    ggplot(pathwys_df,
    aes(x = flow, y = pathway, fill = group)) +
    geom_bar(stat = "identity",position = position_dodge(preserve = "single", width = 0.8), width = 0.7) +
    labs(title = "Top 5 Pathways per Group",
        x = "Information Flow", y = "Pathway") +
    scale_fill_manual(values = plot_cols) +
    theme_minimal()

ggsave("output/figures/cellchat/top5_pathways_all.png",
    top5_all,
    width = 10,
    height = 10,
    bg = "white"
)


### merge by cellchat function testing if the net number and weight of interaciton change by merging
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    object_list_sub <-
        list(object_list[[group_prim]],
             object_list[[group_mets]]) %>%
        setNames(c(group_prim, group_mets))
    cellchat <-
        mergeCellChat(object.list = object_list_sub,
                      add.names = names(object_list_sub),
                      merge.data = FALSE,
                      cell.prefix = FALSE)

    # comapre fropm merged
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "count")
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "weight")

    # 2. Compare the total number of interactions and interaction strength
    # Calculate total number of interactions for each group
    interaction_sums <- 
        sapply(object_list_sub, function(x) sum(x@net$count))
    interaction_sum_df <- 
        data.frame(
        group = names(interaction_sums),
        total_interactions = as.numeric(interaction_sums))

    # Barplot individually
    library(ggplot2)
    interaction_df$group <-
        factor(interaction_df$group,
                levels = c("patient_prim", setdiff(interaction_df$group, "patient_prim")))
    ggplot(interaction_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Number of Interactions per Group",
             x = "Group", y = "Total Interactions") +
        theme_minimal() +
        theme(legend.position = "none")
    
    # weight     
    interaction_weight <- 
        sapply(object_list_sub, function(x) sum(x@net$weight))
    interaction_weight_df <- 
        data.frame(
        group = names(interaction_weight),
        total_interactions = as.numeric(interaction_weight))
    interaction_weight_df$group <-
        factor(interaction_weight_df$group,
                levels = c("patient_prim", setdiff(interaction_weight_df$group, "patient_prim")))
    ggplot(interaction_weight_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Interaction Weights per Group",
             x = "Group", y = "Total Interaction Weights") +
        theme_minimal() +
        theme(legend.position = "none")

}


# merge everything
merged_all <-
    mergeCellChat(object.list = object_list,
                  add.names = names(object_list),
                  cell.prefix = TRUE)
# compare the total number of interactions and interaction strength
gg1<-
    compareInteractions(merged_all, show.legend = F, group = c(1:8)) +
        theme(axis.text.x = element_blank())
gg2 <-
    compareInteractions(merged_all, show.legend = F, group = c(1:8), measure = "weight") +
     theme(axis.text.x = element_text(angle = 45, hjust = 1))

combined <-
    patchwork::wrap_plots(gg1 + xlab(NULL), gg2, ncol = 1)

ggsave("output/figures/cellchat/merged_everything_compare_interactions.png",
    combined,
    width = 10,
    height = 10
)

```


### multi sample by sample per group
```{r multi_sample_cellchat_analysis}

average_pathways_allgenes <- list()
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "netP") %>%
            arrange(desc(prob))

        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% receiver_cells) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    #mean filter for probabilities
    mean_filter <- mean(pathways_LR_df$prob)

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        select(sample, pathway_name, prob) %>%
        group_by(pathway_name) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group)
    
    average_pathways_allgenes[[group]] <- pathway_average

    # Perform PCA on the pathways
    pca_input <- 
        pathways_LR_df %>%
        filter(str_starts(sample, "CCDI")) %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        column_to_rownames("sample_group")
    
    # make a heatmap
    heatmap_matrix <-
        pathways_LR_df %>%
        filter(str_starts(sample, "CCDI")) %>%
        filter(!pathway_name %in% c("COLLAGEN", "FN1", "LAMININ")) %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        { 
            mat <- .
            cols_to_keep <- names(mat)[-1][colSums(mat[,-1, drop=FALSE]) > mean_filter]
            mat <- mat[, c("sample_group", cols_to_keep), drop=FALSE]
            mat
        } %>%
        column_to_rownames("sample_group")

    # plot heatmap
    heatmap <-
        pheatmap::pheatmap(
            heatmap_matrix,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
            main = stringr::str_c("Pathway Probabilities Heatmap ", group),
            fontsize_row = 8,
            fontsize_col = 8
        )

    # Run PCA
    pca_res <- prcomp(pca_input, scale. = TRUE)
    # PCA plot: one dot per sample
    pca_df <- as.data.frame(pca_res$x)
    pca_df$sample <- rownames(pca_df) %>% sub("_.*", "", .) 
    pca_df$group <- sapply(strsplit(rownames(pca_df), "-"), `[`, 2)

    # K-means clustering (choose k=2 for example, adjust as needed)
    set.seed(123)
    k <- 3
    km_res <- kmeans(pca_df[, c("PC1", "PC2")], centers = k)
    pca_df$cluster <- as.factor(km_res$cluster)

    # Plot PCA with clusters
    ggplot(pca_df, aes(x = PC1, y = PC2, label = sample, color = cluster, shape = group)) +
        geom_point(size = 3) +
        geom_text(vjust = -0.5, size = 3) +
        labs(title = stringr::str_c(group, " PCA of Pathway Probabilities with Clustering"),
             x = "PC1", y = "PC2") +
        theme_minimal()

}
## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df_allgenes <-
    do.call(rbind, average_pathways_allgenes)
prob_filter <- mean(average_pathways_df_allgenes$mean_prob)
heatmap_matrix_allgenes <-
    average_pathways_df_allgenes %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    filter(rowSums(across(-pathway_name)) > prob_filter) %>%
    column_to_rownames("pathway_name") %>%
    select(patient_prim, patient_mets, mm_primhuman_ortho, mm_metshuman_ortho,
           xeno_prim_cancer_normal, xeno_mets_cancer_normal,
           dogs_primhuman_ortho, dogs_metshuman_ortho) %>%
    arrange(desc(patient_mets))
# Plot heatmap: group on x-axis, pathway on y-axis
heatmap_allgenes <-
    pheatmap::pheatmap(
        heatmap_matrix_allgenes,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix_allgenes, 2)
)
ggsave("output/figures/cellchat/aallgenes_average_pathway_heatmap_across_all.png",
    heatmap_allgenes,
    width = 10,
    height = 20,
    bg = "white"
)
```


### multi sample by sample per group - shared genes only
```{r multi_sample_cellchat_analysis_sharedgenes_analysis}

average_pathways <- list()
module_pathways_list <- list()
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob)) 
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(source,target, pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    
    #mean filter for probabilities
    mean_filter <- mean(pathways_LR_df$prob)

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        select(sample, pathway_name, prob) %>%
        group_by(pathway_name) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group)
    
    average_pathways[[group]] <- pathway_average

}

## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df <-
    do.call(rbind, average_pathways)

heatmap_matrix <-
    average_pathways_df %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    column_to_rownames("pathway_name") %>% 
    select(patient_prim, patient_mets, mm_primhuman_ortho, mm_metshuman_ortho,
           xeno_prim_cancer_normal, xeno_mets_cancer_normal,
           dogs_primhuman_ortho, dogs_metshuman_ortho) %>%
    arrange(desc(patient_mets))
# Plot heatmap: group on x-axis, pathway on y-axis
heatmap<-
    pheatmap::pheatmap(
        heatmap_matrix,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix, 2)
)
ggsave("output/figures/cellchat/sharedgenes_average_pathway_heatmap_across_all.png",
    heatmap,
    width = 10,
    height = 20,
    bg = "white"
)


# plots
for (site in c("prim", "mets")) {
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        column_to_rownames("pathway_name")

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()  
    heatmap_df <-
        site_specific %>%
        filter(rowSums(across(everything())) > mean_filter) %>%
        as.matrix()
    # Plot heatmap: group on x-axis, pathway on y-axis
    heatmap_per_site<-
        pheatmap::pheatmap(
            heatmap_df,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#ff6b6bff","#ff4a4aff","#ff2424ff", "#ff0e0eff"))(100),
            main = "Pathway Mean Probability (Shared Genes)",
            fontsize_row = 8,
            fontsize_col = 10,
            display_numbers = round(heatmap_df, 2)
        )
    ggsave(str_c("output/figures/cellchat/sharedgenes_", site, "_average_pathway_heatmap.png"),
        heatmap_per_site,
        width = 4,
        height = length(colnames(heatmap_df)) * 0.5 + 4,
        bg = "white"
    )

    # plot correlation heatmap
    # Correlation matrix heatmap (already present)
    cor_matrix <-
        cor(site_specific, use = "pairwise.complete.obs")
    pheatmap::pheatmap(
        cor_matrix,
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        color = colorRampPalette(c("#ffe0e0ff", "#fd3f3fff"))(100),
        main = str_c("Correlation Heatmap of Pathways - ", site, " Site"),
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(cor_matrix, 2),
        number_color = "black"
    )  # Alternative visualization: correlation network graph
    library(igraph)
    library(ggraph)
    # Convert correlation matrix to long format for graph
    cor_long <-
        as.data.frame(as.table(cor_matrix))
    colnames(cor_long) <- c("Var1", "Var2", "Correlation")
    cor_long <- cor_long %>% filter(Var1 != Var2 & abs(Correlation) > 0.7)

    # Create igraph object
    g <- graph_from_data_frame(cor_long, directed = FALSE)

    # Plot correlation network
    ggraph(g, layout = "fr") +
        geom_edge_link(aes(edge_alpha = abs(Correlation), edge_width = abs(Correlation), color = Correlation > 0), show.legend = TRUE) +
        geom_node_point(size = 5) +
        geom_node_text(aes(label = name), repel = TRUE) +
        scale_edge_color_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
        labs(title = str_c("Pathway Correlation Network - ", site, " Site")) +
        theme_void()

    # Alternative: pairwise scatterplots
    site_specific_GGPAIRS <-
        site_specific %>%
        rownames_to_column("pathways") %>%
        filter(pathways != "COLLAGEN") %>%
        column_to_rownames("pathways")
    library(GGally)
    GGally::ggpairs(
        site_specific_GGPAIRS,
        lower = list(continuous = wrap("points", alpha = 0.5)),
        upper = list(continuous = wrap("cor", size = 3)),
        diag = list(continuous = wrap("barDiag", fill = "lightblue")),
        title = str_c("Pairwise Pathway Correlations - ", site, " Site"),
        axisLabels = "show"
    )
}
# Fidelity by modules like ECM (compact spacing)
pathway_groups <- list(
    ECM = c("COLLAGEN","LAMININ","FN1","THBS","TENASCIN","AGRN","VWF",
            "ANNEXIN","GAP","PCDH","PTN"),
    Angiogenesis = c("VEGF","PDGF","ANGPT","ANGPTL","FGF","EDN","VWF",
                    "PECAM1","HGF","KIT"),
    ImmuneEvasion = c("MHC-II","CXCL","CCL","TNF","IL1","IL2","IL6",
                    "IL16","OSM","CSF","CD45","CD39", "CD80","CD86",
                    "ICOS","APRIL","BAFF","CD30","TWEAK","RANKL","CX3C","CysLTs"),
    CellAdhesion = c("CADM","NCAM","PTPRM","CDH","CDH1","CDH5","ICAM",
                    "JAM","SELL","NECTIN","OCLN","CLDN","SEMA3","SEMA5",
                    "SEMA6","Netrin","UNC5","EPHB","EPHA","NRXN"),
    GrowthFactor = c("TGFb","BMP","IGF","NOTCH","WNT","ncWNT","GDF",
                    "RA","HGF","NRG"),
    Metabolic = c("Cholesterol","Desmosterol","DHEA","Estradiol",
                    "Prostaglandin","ENHO","RBP4","CALCR"),
    Other = c("APP","ADGRL","ADGRG","ADGRB","NEGR","FLRT","MPZ",
                "SEMA3","SEMA5","SEMA6","CysLTs")
)
pathway_groups <- list(
  ECM_Remodelling = c("COLLAGEN","LAMININ","FN1","THBS","TENASCIN","AGRN",
                      "VWF","ANNEXIN","GAP","PCDH","PTN","TGFb"),
  
  Cell_Adhesion = c("APP","CADM","PTPRM","NCAM","ADGRL","ADGRG","CDH",
                    "CDH1","CDH5","ICAM","JAM","SELL","NECTIN","OCLN",
                    "CLDN","Netrin","UNC5","EPHB","EPHA"),
  
  Angiogenesis = c("VEGF","PDGF","ANGPT","ANGPTL","FGF","EDN",
                   "PECAM1","HGF","KIT","PTN","MK"),
  
  Immune_Signalling = c("MHC-II","CXCL","CCL","TNF","IL1","IL2","IL6",
                        "IL16","OSM","CSF","CD45","CD39","CD80","CD86",
                        "ICOS","APRIL","BAFF","CD30","TWEAK","RANKL",
                        "CX3C","CysLTs"),
  
  Stemness = c("BMP","RA","NRG","NOTCH","WNT","ncWNT","GDF","IGF"),
  
  Neuronal = c("SLIT","FLRT","MPZ","EPHA","NRXN","NEGR","SEMA3",
               "SEMA5","SEMA6","UNC5","PLXNA","PLXNB","PLXNC","PLXND"),
  
  Metabolic = c("Cholesterol","Desmosterol","DHEA","Estradiol",
                "Prostaglandin","ENHO","RBP4","CALCR")
)


# plots
site_specific_paths <- list()
for (site in c("prim", "mets")) {
    patient_site_name <-
        ifelse(site == "prim", "patient_prim", "patient_mets")
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        filter(.data[[patient_site_name]] > 0) %>% 
        column_to_rownames("pathway_name") %>%
        mutate(row_sum = rowSums(across(everything()))) %>%
        arrange(desc(row_sum)) %>%
        select(-row_sum) %>%
        slice_head(n=40)

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()
    pathway_scores <-
        site_specific %>%
        filter(rowSums(across(everything())) > mean_filter) %>%
        as.data.frame() %>%
        rownames_to_column("Pathway") %>%
        rename_with(~ ifelse(str_detect(.x, "dog"), "Dog",
                        ifelse(str_detect(.x, "mm"), "Mouse",
                        ifelse(str_detect(.x, "xeno"), "PDX",
                        ifelse(str_detect(.x, "patient"), "Human", .x)))), .cols = everything()) #%>% 
        # filter(Pathway %in% unlist(pathway_groups))

    site_specific_paths[[site]] <- pathway_scores
    
    aggregate_module <- function(scores_df, groups){
        long <- scores_df %>%
            pivot_longer(-Pathway, names_to="Dataset", values_to="Score") %>%
            mutate(Group = sapply(Pathway, function(p) {
            g <- names(groups)[sapply(groups, function(v) p %in% v)]
            if(length(g)) g[1] else "Other"
            }))
        
        module_summary <- long %>%
            group_by(Group, Dataset) %>%
            summarise(MeanScore = mean(Score, na.rm=TRUE), .groups="drop")
        
        return(module_summary)
    }

    module_summary <- aggregate_module(pathway_scores, pathway_groups)

    # Spread to wide for correlations
    module_wide <- module_summary %>%
    pivot_wider(names_from=Dataset, values_from=MeanScore)

    # Spearman correlation of module patterns
    cor_dog   <- cor(module_wide$Human, module_wide$Dog, method="spearman")
    cor_mouse <- cor(module_wide$Human, module_wide$Mouse, method="spearman")
    cor_pdx   <- cor(module_wide$Human, module_wide$PDX, method="spearman")

    # plot
    ggplot(module_summary, aes(x=Group, y=MeanScore, fill=factor(Dataset, levels=c("Human", "Dog", "PDX", "Mouse")))) +
        geom_bar(stat="identity", position="dodge") +
        scale_fill_manual(
            values = c(
                Human = "#D43F3AFF",
                Dog = "#EEA236FF",
                PDX = "#357EBDFF",
                Mouse = "#5CB85CFF"
            ),
            guide = guide_legend(title = NULL)
        ) +
        theme_minimal(base_size=14) +
        ylab("Mean pathway score (aggregated)") +
        xlab("Functional Module") +
        ggtitle("Module-level pathway fidelity across species") +
        theme(
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            axis.line.x = element_line(),
            axis.line.y = element_line()
        )
    }

```

## Statistical comparison for all primary across 
```{r statistical_comparison_pathways_primary_mets}
# > site_specific_paths$prim$Pathway
#  [1] "COLLAGEN"    "LAMININ"     "FN1"         "APP"         "MK"         
#  [6] "SLIT"        "THBS"        "CADM"        "NCAM"        "PTPRM"      
# [11] "TGFb"        "ADGRL"       "PDGF"        "VEGF"        "MPZ"        
# [16] "FLRT"        "PTN"         "Cholesterol" "TENASCIN"    "CDH"        
# [21] "MHC-II"      "UNC5"        "NRXN"        "CXCL"        "NRG"        
# [26] "EPHA"        "Glutamate"   "CCL"        
# > site_specific_paths$mets$Pathway
#  [1] "COLLAGEN"    "LAMININ"     "SLIT"        "FN1"         "ADGRL"      
#  [6] "CADM"        "NCAM"        "PTPRM"       "APP"         "VEGF"       
# [11] "THBS"        "Glutamate"   "UNC5"        "PDGF"        "CDH"        
# [16] "EPHA"        "TGFb"        "FLRT"        "MPZ"         "MK"         
# [21] "Cholesterol" "PTN"         "SEMA3"       "PECAM1"      "TENASCIN"   
# [26] "BMP"         "ADGRG"       "ICAM"        "CCL"         "ANNEXIN"    

average_pathways <- list()
tumor_sub <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "netP") %>%
            arrange(desc(prob))
        
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            # filter(!source %in% tumor_sub) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    average_pathways[[group]] <- pathways_LR_df
}

# perform stats
ttest_results <- list()
comparisons <- list(
    c("patient_prim", "xeno_prim_cancer_normal"),
    c("patient_prim", "dogs_primhuman_ortho"),
    c("patient_prim", "mm_primhuman_ortho"),
    c("patient_mets", "xeno_mets_cancer_normal"),
    c("patient_mets", "dogs_metshuman_ortho"),
    c("patient_mets", "mm_metshuman_ortho")
)


for (comp in comparisons) {
    group1 <- comp[1]
    group2 <- comp[2]

    data_sub <- 
        do.call(rbind, list(average_pathways[[group1]], average_pathways[[group2]])) %>%
        as_tibble() %>%
        as.data.frame()

    # fill up the missing pathways with 0 prob for each sample
    human_vs_another <-
        data_sub %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the total number of samples in each group
    total_number_human <- 
        n_distinct(human_vs_another$sample[human_vs_another$group == group1])
    total_number_another <- 
        n_distinct(human_vs_another$sample[human_vs_another$group == group2]) 
    
    # will use human average to calculate the fold change
    mean_per_pathway_in_human <-
        data_sub %>%
        filter(group == group1) %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob_human = sum(prob)/total_number_human) %>%  
        arrange(desc(mean_prob_human))

    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        human_vs_another %>%
        #filter(pathway_name %in% mean_per_pathway_in_human$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway_in_human, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob_human) %>%
        select(sample, group, pathway_name, prob, mean_prob_human, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    # choose top pathways based on primary
    if (str_detect(group1, "prim")) {
        chosen_pathways <- site_specific_paths$prim$Pathway
    } else {
        chosen_pathways <- site_specific_paths$mets$Pathway
    }

    plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% chosen_pathways) %>%
            mutate(group = case_when(
                str_detect(group, "patient") ~ "Human",
                str_detect(group, "dogs") ~ "Dog",
                str_detect(group, "xeno") ~ "PDX",
                str_detect(group, "mm") ~ "Mouse",
                TRUE ~ group
            ))
    plot_pathways$site <-
        ifelse(str_detect(group1, "prim"), "Primary", "Metastatic")
 
    ttest_results[[str_c(group1, "_vs_", group2)]] <- plot_pathways
}


# with 50 pathways, we can group them into functional modules
prim_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH",
                            "PECAM1", "ICAM", "SELL", "JAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "ANGPT"),
    Immune_Signalling = c("CXCL", "CCL", "IL1", "MHC-II"),
    Stemness          = c("BMP", "RA", "NRG"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate")
) %>%
unlist() %>%
unique()

# Metastatic
mets_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH", "PECAM1", "ICAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "FGF", "ANGPT"),
    Immune_Signalling = c("CXCL", "CCL", "IL1", "TNF", "CD80"),
    Stemness          = c("BMP", "RA"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate", "DHEA")
)%>%
unlist() %>%
unique()

# now plot the results all together side by side for each pathway, for each site (Primary and Metastatic)
for (site in c("Primary", "Metastatic")) {
    ttest_results_df_site <-
        do.call(rbind, ttest_results) %>%
        as_tibble() %>%
        as.data.frame() %>%
        filter(site == !!site) %>%
        mutate(comparison = case_when(
            str_detect(group, "PDX") ~ "Human vs PDX",
            str_detect(group, "Dog") ~ "Human vs Dog",
            str_detect(group, "Mouse") ~ "Human vs Mouse"
        )) %>%
        mutate(significance = case_when(
            padj < 0.001 ~ "***",
            padj < 0.05 ~ "**",
            padj < 0.1 ~ "*",
            TRUE ~ "ns"
        ))

    ttest_results_df_site$group <- factor(ttest_results_df_site$group,
        levels = c("Human", "Dog", "PDX", "Mouse"))
    ttest_results_df_site$comparison <- factor(ttest_results_df_site$comparison,
        levels = c("Human vs Dog", "Human vs PDX", "Human vs Mouse"))

    # Split pathways into two halves
    if (site == "Primary") {
        pathway_modules <- prim_modules
    } else {
        pathway_modules <- mets_modules
    }
    half_n <- ceiling(length(pathway_modules) / 2)
    pathways1 <- pathway_modules[1:half_n]
    pathways2 <- pathway_modules[(half_n + 1):length(pathway_modules)]

    plot1 <-
        ggplot(
            ttest_results_df_site %>%
                filter(group != "Human", pathway_name %in% pathways1) %>%
                mutate(pathway_name = factor(pathway_name, levels = pathways1)),
            aes(x = pathway_name, y = log10(norm_prob + 0.0001), fill = group)
        ) +
            geom_boxplot(outlier.shape = NA, width = 0.6, position = position_dodge(width = 0.8)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            scale_color_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            theme_minimal(base_size = 14) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            labs(
                title = str_c("Pathway Probability Comparison Across Species (", site, ", Excluding Human)"),
                x = "Pathway", y = "Normalized Probability log10"
            ) +
            geom_text(
                data = ttest_results_df_site %>%
                    filter(group != "Human", pathway_name %in% pathways1) %>%
                    mutate(pathway_name = factor(pathway_name, levels = pathways1)) %>%
                    group_by(pathway_name, group, comparison) %>%
                    summarise(
                        y_pos = min(max(log10(norm_prob + 0.0001), na.rm = TRUE) + 0.1, 22),
                        significance = first(significance),
                        .groups = "drop"
                    ),
                aes(x = pathway_name, y = y_pos, label = significance, group = group),
                inherit.aes = FALSE,
                position = position_dodge(width = 0.8),
                vjust = 0,
                fontface = "bold",
                size = 3
            )

    plot2 <-
        ggplot(
            ttest_results_df_site %>%
                filter(group != "Human", pathway_name %in% pathways2) %>%
                mutate(pathway_name = factor(pathway_name, levels = pathways2)),
            aes(x = pathway_name, y = log10(norm_prob + 0.0001), fill = group)
        ) +
            geom_boxplot(outlier.shape = NA, width = 0.6, position = position_dodge(width = 0.8)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            scale_color_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            theme_minimal(base_size = 14) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            labs(
                title = NULL,
                x = "Pathway", y = "Normalized Probability log10"
            ) +
            geom_text(
                data = ttest_results_df_site %>%
                    filter(group != "Human", pathway_name %in% pathways2) %>%
                    mutate(pathway_name = factor(pathway_name, levels = pathways2)) %>%
                    group_by(pathway_name, group, comparison) %>%
                    summarise(
                        y_pos = min(max(log10(norm_prob + 0.0001), na.rm = TRUE) + 0.1, 22),
                        significance = first(significance),
                        .groups = "drop"
                    ),
                aes(x = pathway_name, y = y_pos, label = significance, group = group),
                inherit.aes = FALSE,
                position = position_dodge(width = 0.8),
                vjust = 0,
                fontface = "bold",
                size = 3
            )

    combined_plot <- plot1 / plot2 + plot_layout(heights = c(1, 1))

    ggsave(str_c("output/figures/cellchat/statistical_comparison_pathways_", site, "_across_species.png"),
        combined_plot,
        width = 20,
        height = 10,
        bg = "white"
    )
}


```


## Dig Deepeer into the pathways that are interesting
```{r dig_deeper_pathways}

interesting_pathways <- c(
                    "TGFb"
                    #"FN1"
                    # "LAMININ", "VEGF", "CXCL",
                    # "IL1",
                    # "CCL",
                    # "THBS",
                    # "CADM",
                    # "APP",
                    # "SLIT",
                    # "NCAM"
                    )
average_pathways <- list()
interaction_names <- list()
# load the objects
for (group in c(
                #"patient_prim",
                "patient_mets",
                #"xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                #"dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                #"mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        pathways_present <- 
            intersect(interesting_pathways, unique(cellchat@netP$pathways))
        if (length(pathways_present) > 0) {
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                    signaling = pathways_present,
                                    slot.name = "net") %>%
                arrange(desc(prob))

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                select(pathway_name, prob, source, target, interaction_name)
        } else {
            message(str_c("No interesting pathways found in ", sample_name, " of group ", group))
        }
    }
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame()

    pathways_present_all <- 
        unique(pathways_LR_df$pathway_name)
    # help me plot this using ggplot2 source in y axis target in x axis for each intersaction name
    for (pathway in pathways_present_all) {
        pathway_df <-
            pathways_LR_df %>%
            filter(pathway_name == pathway) %>%
            arrange(desc(prob))
    
        # plot fr each pathway for each group
        pathway_df_plot <-
            pathway_df %>%
            group_by(source, target) %>%
            summarise(
                prob = sum(prob, na.rm = TRUE),
                count = n(),
                .groups = "drop"
            )
        # overall plot for the pathway
        plot_path <-
            ggplot(pathway_df_plot, aes(x = target, y = source, size = count, color = prob)) +
                geom_point(alpha = 0.7) +
                scale_color_gradientn(colours = c("#fcf4f4ff", "#e90000ff"),
                                      name = "Strength") +  
                theme_minimal(base_size = 14) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                labs(
                    title = str_c("Pathway: ", pathway, " (", group, ")"),
                    x = "Receiver Cell Type",
                    y = "Sender Cell Type"
                ) +
                scale_x_discrete(labels = function(x) gsub("_", " ", x)) +
                scale_y_discrete(labels = function(y) gsub("_", " ", y)) +
                theme(
                    plot.title = element_text(size = 10),
                    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
                    axis.title.x = element_text(size = 10),
                    axis.title.y = element_text(size = 10),
                    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
                    axis.text.y = element_text(size = 9)
                ) 
                
        if (!dir.exists(str_c("output/figures/cellchat/", group))) {
            dir.create(str_c("output/figures/cellchat/", group), recursive = TRUE)
        }
        ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_overall_plot.png"),
            plot_path,
            width = length(unique(pathway_df_plot$target)) * 0.3 + 3,
            height = length(unique(pathway_df_plot$source)) * 0.3 + 1,
            bg = "white"
        )
        
        interaction_names[[str_c(group, "_", pathway)]] <- unique(pathway_df$interaction_name)
        # plot for each interaction
      
        for (interaction in unique(pathway_df$interaction_name)) {
            interaction_df <-
                pathway_df %>%
                filter(interaction_name == interaction) %>%
                group_by(source, target) %>%
                summarise(
                    prob = sum(prob, na.rm = TRUE),
                    count = n(),
                    .groups = "drop"
                )

            plot_lr <-
                ggplot(interaction_df, aes(x = target, y = source, size = count, color = prob)) +
                    geom_point(alpha = 0.7) +
                    # scale_size_continuous(range = range(interaction_df$count, na.rm = TRUE), name = "Count") + 
                    scale_color_gradientn(colours = c("#fcf4f4ff", "#e90000ff"),
                                            name = "Strength") +  
                    theme_minimal(base_size = 14) +
                    labs(
                        title = str_c("LR: ", interaction, " (Pathway:", pathway, " - ", group, ")"),
                        x = "Receiver Cell Type",
                        y = "Sender Cell Type") +
                    theme(plot.title = element_text(size = 10),
                        axis.title.x = element_text(size = 10),
                        axis.title.y = element_text(size = 10),
                        axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
                        axis.text.y = element_text(size = 9))

            if (!dir.exists(str_c("output/figures/cellchat/", group))) {
                dir.create(str_c("output/figures/cellchat/", group), recursive = TRUE)
            }
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_", interaction, "_interaction_plot.png"),
                plot_lr,
                width = length(unique(interaction_df$target)) * 0.3 + 3,
                height = length(unique(interaction_df$source)) * 0.3 + 2,
                bg = "white"
            )
        }
        # make receiver as epithelial cells only
        epithelial_interactions <- list()
        for (interaction in unique(pathway_df$interaction_name)) {
            interaction_df <-
                pathway_df %>%
                filter(interaction_name == interaction, target == "Epithelial_cells") %>%
                group_by(source, target) %>%
                summarise(
                    prob = sum(prob, na.rm = TRUE),
                    count = n(),
                    .groups = "drop"
                )
            if (nrow(interaction_df) > 0) {
                epithelial_interactions[[interaction]] <- interaction_df
            }
        }
        merge_epithelial_interactions <-
            bind_rows(
                lapply(names(epithelial_interactions), function(nm) {
                    df <- epithelial_interactions[[nm]]
                    df$interaction_name <- nm
                    df
                })
            ) %>%
            as_tibble() %>%
            as.data.frame() #%>%
            #filter(interaction_name %in% c("FN1_ITGA3_ITGB1", "FN1_SDC1", "FN1_CD44"))
 
            plot_tile_interaction <-
                ggplot(merge_epithelial_interactions,
                        aes(x = interaction_name, y = source, size = count, color = prob)) +
                    geom_point(alpha = 0.8) +
                    scale_color_gradientn(colours = c("#fcf4f4ff", "#e90000ff"),
                                          name = "Strength") +
                    scale_size_continuous(name = "Count") +
                    theme_minimal(base_size = 14) +
                    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                    labs(
                        title = str_c("Pathway: ", pathway, " (", group, ") - Epithelial cells as Receiver"),
                        x = "Interaction Name", y = "Sender Cell Type"
                    ) +
                #scale_x_discrete(labels = function(x) gsub("_", " ", x)) +
                scale_y_discrete(labels = function(y) gsub("_", " ", y)) +
                theme(
                    plot.title = element_text(size = 10),
                    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
                    axis.title.x = element_text(size = 10),
                    axis.title.y = element_text(size = 10),
                    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
                    axis.text.y = element_text(size = 9)
                )
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_epithelial_receiver_interaction_plot.png"),
                plot_tile_interaction,
                width = length(unique(merge_epithelial_interactions$interaction_name)) * 0.3 + 3,
                height = length(unique(merge_epithelial_interactions$source)) * 0.3 + 1,
                bg = "white"
            )
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_epithelial_receiver_interaction_plot.pdf"),
                plot_tile_interaction,
                width = length(unique(merge_epithelial_interactions$interaction_name)) * 0.3 + 3,
                height = length(unique(merge_epithelial_interactions$source)) * 0.3 + 1,
                bg = "white"
            )
    }
}


# whole object reference for rctd
for (sobj in c("patient_mets", "dogs_mets",
                "mm_mets", "xeno_mets_cancer_normal")) {
    sobj_path <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/", sobj, ".qs"))
    
    features <-
        c("SDC1", "SDC4", "ITGA3", "ITGB1", "CD44")
    if (sobj == "mm_mets") {
        features <- 
            nichenetr::convert_human_to_mouse_symbols(features)
    }
    dotplot <-
        DotPlot(sobj_path,
                features = features,
                cols = "RdBu",
                group.by = "Ann_Level2",
                scale = T) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            ggtitle(str_c("Expression in All Cells - ", sobj))
    if (!dir.exists(str_c("output/figures/cellchat/", sobj))) {
        dir.create(str_c("output/figures/cellchat/", sobj), recursive = TRUE)
    }
    ggsave(str_c("output/figures/cellchat/", sobj, "/FN1_receptor_exp.png"),
        dotplot,
        width = 6,
        height = 9,
        bg = "white"
    )
    ggsave(str_c("output/figures/cellchat/", sobj, "/FN1_receptor_exp.pdf"),
        dotplot,
        width = 6,
        height = 9,
        bg = "white"
    )
}


# from the plots in TGFb, the alv macroiphages and TAMs seems interesting

# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary

# ligand_target_long <- 
#     as.data.frame(as.matrix(ligand_target_matrix_mouse)) %>%
#     rownames_to_column("ligand") %>%
#     pivot_longer(-ligand, names_to = "target", values_to = "value")

# ggplot(ligand_target_long, aes(x = value)) +
#     geom_histogram(bins = 200, fill = "skyblue", color = "black") +
#     geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
#     labs(title = "Histogram of Ligand-Target Matrix Values",
#             x = "Values", y = "Frequency") +
#     theme_minimal() +
#     xlim(c(0, 0.1))

ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")

# mouse 
ligand_target_matrix_mouse <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final_mouse.rds")

#pathways by celltype interested list
pathways_by_celltype <-
    list(
        TGFB1 = c("Endothelial_cells",  "TAMs", "Epithelial_cells"),
        TGFB2 = c("Endothelial_cells", "TAMs", "Epithelial_cells"),
        TGFB3 = c("Endothelial_cells", "TAMs"),
        FN1 = c("Epithelial_cells"
            #, "TAMs", "Endothelial_cells", "Monocytes"
            ),
        COL1A1 = c("Epithelial_cells"),
        LAMA4 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive", "Epithelial_cells", "Endothelial_cells"),
        LAMB1 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive","TAMs", "Epithelial_cells", "Endothelial_cells"),
        CXCL12 = c("CAFs", "TAMs", "B_cells", "Alv_Macrophages", "Neutrophils",
                    "DC", "NK_cells", "Monocytes"),
        VEGFA = c("Endothelial_cells"),
        VEGFB = c("Endothelial_cells"),
        VEGFC = c("Endothelial_cells"),
        CADM1 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive", "Epithelial_cells"),
        NCAM1 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive", "Epithelial_cells")
    )

# find the unique ligand_receptor names from all
unique_LR_names <- 
    unique(unlist(interaction_names)) %>%
    as.character()

# ligand_by_receptor
ligand_receptor_list <- list(
    FN1 = c("CD44", "ITGA3", "ITGB1","ITGA2B", "ITGB3", "SDC1", "SDC4"),
    # LAMA4 = c("CD44", "ITGA1", "ITGB1", "ITGA2", "ITGA3", "ITGA7", "SV2A", "SV2C", "DAG1"),
    # LAMB1 = c("CD44", "ITGA1", "ITGB1", "ITGA2", "ITGA3", "ITGA7", "SV2A", "SV2C", "DAG1"),
    #LAMC1 = c("CD44", "ITGA1", "ITGB1", "ITGA2", "ITGA3", "ITGA7", "SV2A", "SV2C", "DAG1"),
    TGFB1 = c("TGFBR1", "TGFBR2", "ACVR1"),
    TGFB2 = c("TGFBR1", "TGFBR2", "ACVR1"),
    TGFB3 = c("TGFBR1", "TGFBR2", "ACVR1"),
    VEGFA = c("VEGFR1", "VEGFR2"),
    VEGFB = c("VEGFR1"),
    VEGFC = c("VEGFR2"),
    CXCL12 = c("CXCR4", "ACKR3"),
    CADM1 = c("CADM1"),
    NCAM1 = c("NCAM1"),
    COL1A1 = c("CD44", "ITGA1", "ITGB1", "ITGA3")
)

# make downstream plots for each ligand in each group
for (group in c(
                # "patient_prim",
                "patient_mets",
                # "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                # "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                # "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    if (object$organism[1] == "human") {
        ligand_target_matrix_use <- ligand_target_matrix
    } else {
        ligand_target_matrix_use <- ligand_target_matrix_mouse
    }
    # Use parallel::mclapply to process ligands in parallel
    ligand_results <- parallel::mclapply(
        c(
            #"TGFB1","TGFB2", "TGFB3", "FN1",
        "COL1A1"
        # "LAMA4", "LAMB1", "VEGFA", "VEGFB",
        #   "VEGFC", "CXCL12", "CADM1", "NCAM1"
          ),
        function(ligands) {
            # check if the ligand is expressed in the object
            if (ligands %in% rownames(object)) {
                message(str_c("Processing ligand ", ligands, " in group ", group))
                if (object$organism[1] == "human") {
                    lig <- ligands
                } else {
                    lig <- nichenetr::convert_human_to_mouse_symbols(ligands) %>%
                        as.character()
                }
                if (lig %in% rownames(ligand_target_matrix_use)) {
                    targets <-
                        ligand_target_matrix_use[lig, ] %>%
                        as.data.frame() %>%
                        rownames_to_column("target") %>%
                        rename(score = 2) %>%
                        arrange(desc(score)) %>%
                        filter(score > 0.01) %>%
                        mutate(ligand = lig)
                    #make a expression name with ligands_ligand
                    ligand_display_name <- str_c(ligands, "_ligand")
                    object[[ligand_display_name]] <- GetAssayData(object, slot = "data")[ligands, ]

                    downstream_genes <-
                        targets %>%
                        filter(target %in% rownames(object)) %>%
                        # filter(target != lig) %>%
                        pull(target)
                    if (length(downstream_genes) > 100) {
                        downstream_genes <- downstream_genes[1:100]
                    }
                    # run Aucell with the downstream genes
                    entire_matrix <- object@assays$RNA$counts
                    genelist <- downstream_genes
                    cell_ranks <-
                        AUCell::AUCell_run(exprMat = entire_matrix,
                                           geneSets = genelist)
                    object[[str_c(ligands,"_dwnstrm")]] <- AUCell::getAUC(cell_ranks)[1,]

                    Idents(object) <- "Ann_Level2"
                    dotplot_everything <-
                        DotPlot(object,
                            #cols = "RdBu",
                            features =  c(ligand_display_name,
                                         ligand_receptor_list[[ligands]],
                                         str_c(ligands,"_dwnstrm"),
                                         downstream_genes),
                            group.by = "Ann_Level2",
                            idents = pathways_by_celltype[[ligands]],
                            scale = F) +
                            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                            ggtitle(str_c("Ligand: ", ligands, " and Downstream Targets (", group, ")"))
                    
                
                    ggsave(str_c("output/figures/cellchat/", group, "/", ligands, "_ligand_and_downstream_targets.png"),
                            dotplot_everything,
                            width = length(downstream_genes) * 0.3 + 5,
                            height = length(unique(object$Ann_Level2)) * 0.3 + 3,
                            bg = "white")
                    # return(TRUE)
                } else {
                    message(str_c("Ligand ", ligands, " not found in ligand-target matrix for ", group))
                    # return(FALSE)
                }
            }
            # return(FALSE)
        },
        mc.cores = 3,
        mc.preschedule = F # adjust the number of cores as needed
    )
}

# TGFB plts
tgfb<- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    dotplot_tgfb <-
        DotPlot(object,
                features =  c("TGFB1", "TGFB2", "ACVR1", "TGFBR1", "TGFBR2"),
                group.by = "Ann_Level2",
                scale = F) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            ggtitle(group)
    tgfb[[group]] <- dotplot_tgfb
}

panel_prim <-
    wrap_plots(tgfb$patient_prim,
                tgfb$dogs_primhuman_ortho,
                tgfb$mm_primhuman_ortho,
                tgfb$xeno_prim_cancer_normal,
                ncol = 4) +
    plot_annotation(title = "TGFB Expression in Primary",
                    theme = theme(plot.title = element_text(size = 16, hjust = 0.5)))

panel_mets <-
    wrap_plots(tgfb$patient_mets,
                tgfb$dogs_metshuman_ortho,
                tgfb$mm_metshuman_ortho,
                tgfb$xeno_mets_cancer_normal,
                ncol = 4) +
    plot_annotation(title = "TGFB Expression in Mets",
                    theme = theme(plot.title = element_text(size = 16, hjust = 0.5)))

#compare the expression in normal lung vs tumor associated macrophages
normal_lung <-
    qs::qread("input/downloads/ds_human_lung_atlas.qs")

dimplot_better(normal_lung, group_by = "ann_level_3")
cell_types <- c(
    "Macrophages",
    "AT2",
    "EC venous",
    "EC arterial",
    "AT1",
    "Monocytes",
    "EC capillary",
    "Lymphatic EC mature",
    "Lymphatic EC differentiating",
    "Lymphatic EC proliferating"
)
normal_lung_sub <-
    normal_lung %>%
    subset(ann_level_3 %in% cell_types)
normal_lung_sub$unique <- "normal"
dimplot_better(normal_lung_sub, group_by = "ann_level_3")
FeaturePlot(normal_lung_sub, features = c("TGFB1"))
normal_lung_sub$compare_label <-
    str_replace_all(normal_lung_sub$ann_level_3, c("^EC venous$" = "Endothelial_cells",
                                                "^EC arterial$" = "Endothelial_cells",
                                                "^EC capillary$" = "Endothelial_cells",
                                                "^Lymphatic EC mature$" = "Endothelial_cells",
                                                "^Lymphatic EC differentiating$" = "Endothelial_cells",
                                                "^Lymphatic EC proliferating$" = "Endothelial_cells",
                                                "^AT2$" = "Epithelial_cells",
                                                "^AT1$" = "Epithelial_cells"))

tumor_lung <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
tumor_lung_sub <-
    tumor_lung %>%
    subset(Ann_Level2 %in% c("TAMs", "Monocytes", "Endothelial_cells", "Epithelial_cells"))
tumor_lung_sub$unique <- "tumor"
tumor_lung_sub$compare_label <-
    str_replace_all(tumor_lung_sub$Ann_Level2, c("^Alv_Macrophages$" = "Macrophages",
                                                "^TAMs$" = "Macrophages"))
# combine the two datasets
combine_tumor_normal <-
    merge(tumor_lung_sub, normal_lung_sub) %>%
    JoinLayers() %>%
    process_seurat()

qs::qsave(combine_tumor_normal,
        "output/seurat_objects/combined_normal_tumor_lung.qs")

# calculate average expression of TGFB1, HMGB1, CMTM8, GLG1, VEGFA, VEGFB, VEGFC in normal vs tumor
genes_of_interest <- c(
    "TGFB1", "IL18", "IL15", "TGFB2", "HMGB1", "CMTM8", "GAS6", "GLG1", "IL32", 
    "IGFBP7", "MIF", "NAMPT", "ALCAM", "CCN1", "VEGFA", "TNF", "TNFSF10", "IL1B"
)

combine_tumor_normal <-
    qs::qread("output/seurat_objects/combined_normal_tumor_lung.qs")

# Calculate average expression for each gene and cell type in tumor and normal
avg_expr_list <- list()
for (gene in genes_of_interest) {
    for (celltype in unique(combine_tumor_normal$compare_label)) {
        avg_normal <- mean(GetAssayData(combine_tumor_normal, slot = "data")[gene, 
            combine_tumor_normal$unique == "normal" & combine_tumor_normal$compare_label == celltype], na.rm = TRUE)
        avg_tumor <- mean(GetAssayData(combine_tumor_normal, slot = "data")[gene, 
            combine_tumor_normal$unique == "tumor" & combine_tumor_normal$compare_label == celltype], na.rm = TRUE)
        log2FC <- log2((avg_tumor + 0.001) / (avg_normal + 0.001))
        avg_expr_list[[paste(gene, celltype, sep = "_")]] <- data.frame(
            Gene = gene,
            CellType = celltype,
            Tumor = avg_tumor,
            Normal = avg_normal,
            log2FC = log2FC
        )
    }
}

Anerage_exp <-
    do.call(rbind, avg_expr_list) %>%
    arrange(log2FC) %>%
    filter(str_detect(CellType, "Epithelial_cells"))
pheatmap::pheatmap(
    Anerage_exp %>% 
        select(Tumor, Normal, log2FC) %>% 
        as.matrix(),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    color = colorRampPalette(c("#ceddf3ff", "#facbcbff", "#D43F3AFF"))(100),
    main = "Average Expression Heatmap (Tumor/Normal/log2FC)",
    fontsize_row = 10,
    fontsize_col = 10,
    display_numbers = T
)

# whats different about this TGFB1 and TGFB2 activated vs not activated epithelial cells in tumor
Epithelial_cells_tumor <-
    combine_tumor_normal %>%
    subset(compare_label == "Epithelial_cells" & unique == "tumor") %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = c("sample_name", "method", "data_source"),
             theta = c(12, 12, 12)) %>%
    process_seurat(reduction = "harmony")
Epithelial_cells_tumor <-
    FindClusters(Epithelial_cells_tumor, resolution = 0.2)

# what are the top 30 target genes of FN1 that activate TGFB1
up_of_fn1_that_acitivate_tgfb <-
    ligand_target_matrix[, "TGFB1"] %>%
    sort(decreasing = TRUE) %>%
    head(30) %>%
    names() %>%
    as.vector()


cell_chat_objs <-
    list.files(str_c("output/cellchat_objects_sharedgenes/", "patient_mets"),
            pattern = "*.qs",
            full.names = TRUE)
cellchat_list <- list()
pathways_LR <- list()

for (file_path in cell_chat_objs) {
    sample_name <- str_replace(basename(file_path), ".qs", "")
    cellchat <- qs::qread(file_path)
    cellchat_list[[sample_name]] <- cellchat
    
    pathways_and_lr_prob <-
        subsetCommunication(cellchat,
                            slot.name = "net") %>%
        arrange(desc(prob)) %>%
        filter(target %in% c("Epithelial_cells")) %>%
        filter(ligand %in% up_of_fn1_that_acitivate_tgfb) %>%
        filter(source %in% c("Basal_Progenitor", "Proliferative", "Fibrogenic",
                        "COMA", "Interactive", "MP_Progenitor")) %>%
        arrange(desc(prob)) %>%
}


```



## Run RCTD for spatial mapping of TAECs
see if the TAECs are spatially located near the tumor edge compared to normal epithelial cells
```{r rctd_input_files_for_epithelial}
# whats different about this TGFB1 and TGFB2 activated vs not activated epithelial cells in tumor
combine_tumor_normal <-
    qs::qread("output/seurat_objects/combined_normal_tumor_lung.qs")

combine_tumor_normal$sample_name <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$sample_name,
           combine_tumor_normal$study)
combine_tumor_normal$method <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$method,
           "single_cell")
combine_tumor_normal$data_source <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$data_source,
           "human_lung_atlas")
combine_tumor_normal$Ann_Level3 <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$Ann_Level3,
           combine_tumor_normal$ann_level_3)

Epithelial_cells_all <-
    combine_tumor_normal %>%
    subset(Ann_Level3 %in% c("AT1", "AT2")) %>%
    process_seurat() 

optimize_harmony(s_obj = Epithelial_cells_all, 
                group_by = c("sample_name", "method", "data_source"),
                theta_combo = c(4, 7, 12),
                lambda_combo = c(0.1, 0.4),
                dimplot_col = "unique",
                output_dir = "output/figures/harmony_optimization",
                output_folder = "epithelial_analysis")

Epithelial_cells_all <-
    Epithelial_cells_all %>%
    RunHarmony(group.by.vars = c("sample_name", "method", "data_source", "unique"),
             theta = c(4, 4, 12, 12),
             lambda = c(0.1, 0.1, 0.1, 0.1),
             dims.use = 1:30) %>%
    RunUMAP(dims = 1:30, reduction = "harmony") %>%
    FindNeighbors(reduction = "harmony") %>%
    FindClusters(resolution = 0.05)

if(!dir.exists("output/seurat_objects/epithelial_cells_all")){
    dir.create("output/seurat_objects/epithelial_cells_all", recursive = TRUE)
}

# qs::qsave(Epithelial_cells_all,
#         "output/seurat_objects/epithelial_cells_all/final_epi_analysis.qs")

# load the object
Epithelial_cells_all <-
    qs::qread("output/seurat_objects/epithelial_cells_all/final_epi_analysis.qs")


# check if there is enrichment of epithelial clusters in tumor vs normal
enrichment_cluster <-
    table(Epithelial_cells_all$seurat_clusters, Epithelial_cells_all$unique) %>%
        as.data.frame() %>%
        group_by(Var2) %>%
        mutate(Proportion = Freq / sum(Freq)) %>%
        ungroup() %>%
        ggplot(aes(x = Var2, y = Var1, fill = Proportion)) +
        geom_tile(color = "white") +
        scale_fill_gradient(low = "#ffcbcbff", high = "#ff615cff", name = "Proportion") +
        geom_text(aes(label = scales::percent(Proportion, accuracy = 0.1)), color = "black", size = 3) +
        theme_minimal() +
        labs(title = "Proportion of Epithelial Cell Clusters in Tumor vs Normal",
             x = "Sample Type",
             y = "Epithelial Cell Cluster") +
        theme(plot.title = element_text(hjust = 0.5),
              panel.grid = element_blank())

if(!dir.exists("output/figures/epithelial_analysis")){
    dir.create("output/figures/epithelial_analysis", recursive = TRUE)
}

ggsave("output/figures/epithelial_analysis/enrichment_of_epithelial_clusters_in_tumor_vs_normal.png",
    enrichment_cluster,
    width = 5,
    height = 5,
    bg = "white"
)

# dimplot of epithelial clusters and tumor vs normal
dimplot1 <-
    DimPlot(Epithelial_cells_all,
            group.by = "seurat_clusters",
            label.box = T,
            label = T,
            repel = T,
            cols = plot_cols[1:5],
            raster = F,
            label.size = 5) +
    coord_fixed() +
    theme_void() +
    NoLegend() +
    theme(aspect.ratio=1)+
    theme(plot.title = element_text(hjust = 0.5, size = 14))


ggsave("output/figures/epithelial_analysis/dimplot_epithelial_clusters.png",
    dimplot1,
    width = 5,
    height = 5,
    bg = "white"
)

dimplot2 <-
    DimPlot(Epithelial_cells_all,
            group.by = "unique",
            label.box = T,
            label = T,
            repel = T,
            cols = c(tumor = "#D43F3AFF", normal = "#EEA236FF"),
            raster = F,
            label.size = 5) +
    coord_fixed() +
    theme_void() +
    NoLegend() +
    theme(aspect.ratio=1)+
    theme(plot.title = element_text(hjust = 0.5, size = 14))

ggsave("output/figures/epithelial_analysis/dimplot_epithelial_tumor_vs_normal.png",
    dimplot2,
    width = 5,
    height = 5,
    bg = "white"
)


ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
    # Convert the ligand_target_matrix to a long data frame for ggplot

ligand_target_long <- 
    as.data.frame(as.matrix(ligand_target_matrix)) %>%
    rownames_to_column("ligand") %>%
    pivot_longer(-ligand, names_to = "target", values_to = "value")

ggplot(ligand_target_long, aes(x = value)) +
    geom_histogram(bins = 200, fill = "skyblue", color = "black") +
    geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
    labs(title = "Histogram of Ligand-Target Matrix Values",
            x = "Values", y = "Frequency") +
    theme_minimal() +
    xlim(c(0, 0.1))
cutoff <- 0.05

lig <- "FN1"
targets <-
    ligand_target_matrix[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    #filter(score > cutoff) %>%
    mutate(ligand = lig) %>%
    select(target) %>%
    slice_head(n = 80)
targets_clean <-
    c("TGFB1", "INHBA", "CSF1", "VEGFC", "DLL4",
      "HGF", "PLAU", "FGF7", "ELFN1", "RARRES1")

fn1_downstream_mainfig <-
    DotPlot(Epithelial_cells_all %>%
            subset(unique == "tumor"),
            features = targets_clean,
            group.by = "seurat_clusters",
            cols = "RdBu",
            dot.scale = 8,
            scale = T) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
         coord_flip()

ggsave("output/figures/epithelial_analysis/FN1_downstream_targets_in_tumor_epithelial_cells.pdf",
    fn1_downstream_mainfig,
    width = 5,
    height = 5,
    bg = "white"
)
# make supp figure
fn1_downstream_suppfig <-
    DotPlot(Epithelial_cells_all %>%
            subset(unique == "tumor"),
            features = targets,
            group.by = "seurat_clusters",
            cols = "RdBu",
            dot.scale = 8,
            scale = T) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("output/figures/epithelial_analysis/FN1_downstream_targets_in_tumor_epithelial_cells_supp.pdf",
    fn1_downstream_suppfig,
    width = 10,
    height = 4,
    bg = "white"
)

dimplot_better(Epithelial_cells_all,
        group_by = "Ann_Level3") + NoLegend()
Epithelial_cells_all$Annotation_detailed <-
    str_replace_all(Epithelial_cells_all$seurat_clusters,
                    c("^0$" = "AT1",
                    "^1$" = "AT2",
                    "^2" = "Basaloids"),
    Epithelial_cells_all$Ann_Level3)

ryans_dimplots <-
    (DimPlot(Epithelial_cells_all %>% subset(unique == "tumor"),
                group.by = "Annotation_detailed",
                label.box = T,
                pt.size = 0.5,
                label = T,
                repel = T,
                cols = plot_cols[1:5],
                raster = F,
                label.size = 5) +
        coord_fixed() +
        theme_void() +
        NoLegend() +
        theme(aspect.ratio=1)+
        ggtitle("Tumor Associated AT")+
        theme(plot.title = element_text(hjust = 0.5, size = 14)))+
    (DimPlot(Epithelial_cells_all %>% subset(unique == "normal"),
                group.by = "Annotation_detailed",
                label.box = T,
                pt.size = 0.5,
                label = T,
                repel = T,
                cols = plot_cols[1:5],
                raster = F,
                label.size = 5) +
        coord_fixed() +
        theme_void() +
        NoLegend() +
        theme(aspect.ratio=1)+
        ggtitle("Healthy AT")+
        theme(plot.title = element_text(hjust = 0.5, size = 14)))

ggsave("output/figures/epithelial_analysis/dimplot_epithelial_annotation_detailed_tumor_vs_normal.png",
    ryans_dimplots,
    width = 10,
    height = 5,
    bg = "white"
)

plot_color <-
    c(Mesenchymal_like = "#357EBDFF",
    #   TGFB1_Activated = "#357EBDFF",
    #   Tumor_Interacting = "#357EBDFF",
      AT1 = "#D43F3AFF",
      AT2 = "#EEA236FF")

dimplot3 <-
    DimPlot(Epithelial_cells_all,
            group.by = "Annotation_detailed",
            label.box = T,
            label = T,
            repel = T,
            label.size = 5,
            raster = F,
            cols = unlist(plot_color)) +
    coord_fixed() +
    theme_void() +
    NoLegend() +
    theme(aspect.ratio=1)+
    theme(plot.title = element_text(hjust = 0.5, size = 14))

ggsave("output/figures/epithelial_analysis/dimplot_epithelial_annotation_detailed.png",
    dimplot3,
    width = 5,
    height = 5,
    bg = "white"
)


enrichment_mesenchymal <-
    table(Epithelial_cells_all$seurat_clusters, Epithelial_cells_all$unique) %>%
        as.data.frame() %>%
        group_by(Var2) %>%
        mutate(Proportion = Freq / sum(Freq)) %>%
        ungroup() %>%
        ggplot(aes(x = Var1, y = Proportion, fill = Var2)) +
        geom_bar(stat = "identity", position = "dodge") +
        theme_minimal() +
        labs(title = "Proportion of Epithelial Cell Clusters in Tumor vs Normal",
             x = "Epithelial Cell Clusters",
             y = "Proportion") +
        theme(plot.title = element_text(hjust = 0.5),
              panel.grid = element_blank()) +
        scale_fill_manual(values = c(tumor = "#90302DFF", normal = "#A66D04FF")) +
        geom_text(aes(label = scales::percent(Proportion, accuracy = 0.1)), 
                  position = position_dodge(width = 0.9), vjust = -0.5, size = 3)

ggsave("output/figures/epithelial_analysis/enrichment_of_mesenc_sc_in_tumor_vs_normal_barplot.pdf",
    enrichment_mesenchymal,
    width = 5,
    height = 5,
    bg = "white"
)

# perform gsea between the mesenchymal like vs AT1 and AT2
Epithelial_cells_all$organism <- "human"
Epithelial_cells_tumor <-
    Epithelial_cells_all %>%
    subset(unique == "tumor")
Epithelial_cells_tumor$gsea_group <-
    ifelse(Epithelial_cells_tumor$Annotation_detailed == "Mesenchymal_like",
           "Mesenchymal_like",
           "AT1_AT2")
make_panel_plot(sobj = Epithelial_cells_tumor,
                comparison_col = "Annotation_detailed",
                label = "Annotation_detailed",
                group = "mesenchymal_vs_AT1AT2",
                aggregate_by = c("sample_name", "Annotation_detailed"),
                organism_col = "organism",
                subset = FALSE,
                batch_var = "data_source")
# perform enrichment analysis on the degs
Idents(Epithelial_cells_tumor) <- "gsea_group"
degs_mesenchymal_vs_AT1AT2 <-
    FindMarkers(object = Epithelial_cells_tumor,
                ident.1 = "Mesenchymal_like",
                ident.2 = "AT1_AT2")

degs_i_want <-
    degs_mesenchymal_vs_AT1AT2 %>%
    rownames_to_column("gene") %>%
    filter(p_val_adj < 0.05 & avg_log2FC > 0.25) %>%
    mutate(pct_diff = pct.1 - pct.2) %>%
    arrange(desc(pct_diff)) %>%
    filter(pct_diff > 0.10) %>%
    arrange(desc(avg_log2FC))

# perform gsea on the degs
gene_list <- degs_i_want$avg_log2FC
names(gene_list) <- degs_i_want$gene
gene_list <- sort(gene_list, decreasing = TRUE)
# Load MSigDB hallmark gene sets (adjust the path as needed)
#GSEA Miltilevel
cat_tib <- dplyr::tribble(
    ~category, ~subcategory,   ~cat_expl,
    "H",        "NA",          "Hallmark_paths",
    "C2",       "CP:REACTOME", "Reactome"
    )

all_gsea_results <- list()
for (i in 1:nrow(cat_tib)) {
    cat <- cat_tib$category[i]
    subcat <- cat_tib$subcategory[i]
    expl <- cat_tib$cat_expl[i]

    if (subcat == "NA") {
        gsea_ref <- 
            msigdbr::msigdbr(species = "Homo sapiens",
                            category = cat,
                            subcategory = NA) %>%
            split(x = .$gene_symbol, f = .$gs_name)
        } else {
        gsea_ref <- 
            msigdbr::msigdbr(species = "Homo sapiens",
                            category = cat,
                            subcategory = subcat) %>%
            split(x = .$gene_symbol, f = .$gs_name)
        }
    output <-
        fgsea::fgseaMultilevel(gsea_ref,
                                gene_list,
                                minSize = 10,
                                maxSize = 500,
                                nPermSimple = 10000)
    gsea_output <-
        output %>%
        dplyr::arrange(desc(NES)) %>%
        filter(padj < 0.05) %>%
        group_by(pathway) %>%
        mutate(leadingEdge = unlist(leadingEdge) %>%
                    str_c(collapse = ", ")) %>%
        ungroup() %>%
        na.omit() %>%
        filter(NES > 0)
    # save to the list
    all_gsea_results[[cat]] <- gsea_output
}

All_pathways <-
    bind_rows(all_gsea_results, .id = "category") %>%
    as.data.frame()

# make a dotplot of the top 5 up and down regulated pathways in each comparison
All_pathways$sample <- "mesenchymal_vs_AT1AT2"
All_pathways_for_plot <-
    All_pathways %>%
    dplyr::select(pathway,
                NES,
                size,
                padj) %>%
    arrange(desc(NES)) %>%
    mutate(pathway = as.factor(pathway) %>%
                str_replace_all("_", " ") %>%
                str_wrap(80) %>%
                fct_reorder(NES),
            sample = "Mesenchymal vs AT1/AT2",
            order = seq_len(n()),
            justify_y = dplyr::if_else(NES > 0, 1, 0),
            y_pos = dplyr::if_else(NES > 0, -0.1, 0.1))

# make a plot
gsea_plot <- 
    gsea_dotplot(data = All_pathways_for_plot, x_col = "NES")

ggsave("output/figures/epithelial_analysis/gsea_mesenchymal_vs_AT1AT2.png",
    gsea_plot,
    width = 5,
    height = 4,
    bg = "white"
)

# select the emt and ECM pathways leading edge from All_pathways
EMT <-
    All_pathways %>%
    filter(str_detect(pathway, "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION")) %>%
    pull(leadingEdge) %>%
    str_split(", ") %>%
    unlist() %>%
    unique()

ECM <-
    All_pathways %>%
    filter(str_detect(pathway, "REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION")) %>%
    pull(leadingEdge) %>%
    str_split(", ") %>%
    unlist() %>%
    unique()

# markers of mesenchymal from the literature
TAEC_markers <- c(
    "ZEB1",      # EMT transcription factor
    "VWF",
    "ITGA5",     # activates tgfb1
    "POSTN",
    "LAMA2",
    "SERPINE1",       # Vimentin, mesenchymal marker
    "TNC",
    "TGFB1",
    "SFTPC",
    "SFTPB",
    "AGER",
    "CAV1"
)

# Combined list
final_dotplot <-
    DotPlot(Epithelial_cells_all,
            features = TAEC_markers,
            group.by = "Annotation_detailed",
            split.by = "unique",
            cols = "RdBu",
            dot.scale = 8,
            scale = T) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        ggtitle("Expression in Epithelial Cells (Normal vs Tumor)")

ggsave("output/figures/epithelial_analysis/final_dotplot_epithelial_markers_tumor_vs_normal.pdf",
    final_dotplot,
    width = 8,
    height = 4,
    bg = "white"
)


patient_mets_ref <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
patient_mets_ref$tissue_type <- "TME"
ds_pmets <-
    patient_mets_ref %>%
    subset(cells = sample(colnames(patient_mets_ref), 41086))

ds_pmets$Compare <-
    str_replace_all(ds_pmets$Ann_Level2,
        c(
            "^TAMs$" = "Macrophages",
            "^Alv_Macrophages$" = "Macrophages",
            "^Pericytes$" = "SMC_Pericytes",
            "^Endothelial_cells$" = "Endothelial_cells",
            "^Epithelial_cells$" = "Epithelial_cells",
            "^CAFs$" = "Fibroblasts"
        )
    )
healthy_lung <-
    qs::qread("input/downloads/ds_human_lung_atlas.qs")

healthy_lung$Compare <-
    str_replace_all(healthy_lung$ann_level_3,
        c(
            "^T cell lineage$" = "T_cells",
            "^EC arterial$" = "Endothelial_cells",
            "^SM activated stress response$" = "",
            "^Monocytes$" = "Monocytes",
            "^Innate lymphoid cell NK$" = "NK_cells",
            "^AT2$" = "Epithelial_cells",
            "^Lymphatic EC mature$" = "Endothelial_cells",
            "^Smooth muscle$" = "SMC_Pericytes",
            "^Multiciliated lineage$" = "",
            #"^Rare$" = "",
            "^Lymphatic EC differentiating$" = "Endothelial_cells",
            "^Dendritic cells$" = "DC",
            "^Secretory$" = "Epithelial_cells",
            "^Myofibroblasts$" = "Fibroblasts",
            "^B cell lineage$" = "B_cells",
            "^Submucosal Secretory$" = "Epithelial_cells",
            "^Mast cells$" = "Mast",
            #"^Basal$" = "",
            "^EC capillary$" = "Endothelial_cells",
            "^EC venous$" = "Endothelial_cells",
            "^AT1$" = "Epithelial_cells",
            "^Macrophages$" = "Macrophages",
            #"^Mesothelium$" = "",
            "^Smooth muscle FAM83D\\+$" = "SMC_Pericytes",
            "^Fibroblasts$" = "Fibroblasts",
            #"^Hematopoietic stem cells$" = "",
            "^Lymphatic EC proliferating$" = "Endothelial_cells"
        )
    )

healthy_lung <- 
    healthy_lung %>%
    subset(Compare %in% unique(ds_pmets$Compare))

healthy_lung$tissue_type <- "Healthy"
healthy_lung$sample_name <- healthy_lung$study

ds_pmets <-
    ds_pmets %>%
    subset(Compare != "Neuronal")
combine <-
    merge(ds_pmets, healthy_lung) %>%
    JoinLayers() %>%
    process_seurat()
combine$Ann_Level0 <-
    ifelse(combine$tissue_type == "Healthy", "Healthy", combine$Ann_Level0)

avg_expr <- 
    AverageExpression(combine,
                        features = c("FN1"),
                        group.by = c("Compare", "sample_name", "tissue_type"))$RNA %>%
    as.data.frame()

# make a boxplot of FN1 expression in healthy vs TME and perform t test
avg_expr_long <-
    avg_expr %>%
    rownames_to_column("gene") %>%
    pivot_longer(-gene, names_to = "tissue_sample", values_to = "expression") %>%
    separate(tissue_sample, into = c("Compare", "sample_name", "tissue_type"), sep = "_", extra = "merge")

arrange_names <- c(
    "B-cells", "T-cells", "Macrophages", "Mast", "Monocytes", "NK-cells",
    "DC", "Endothelial-cells", "Epithelial-cells", "SMC-Pericytes", "Fibroblasts",
    "Fibrogenic", "Interactive", "MP-Progenitor", "Proliferative", "Basal-Progenitor", "COMA"
)

avg_expr_long$Compare <-
    factor(avg_expr_long$Compare, levels = arrange_names)

average_FN1_plot <-
    ggplot(avg_expr_long %>% filter(gene == "FN1"),
        aes(x = Compare, y = expression, fill = tissue_type)) +
        geom_boxplot(outlier.shape = NA, alpha = 0.7, position = position_dodge(width = 0.8), width = 0.6) +
        geom_jitter(aes(color = tissue_type),
                    size = 1, alpha = 0.7, show.legend = FALSE,
                    position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75)) +
        scale_fill_manual(values = c(Healthy = "#f0ac4eff", TME = "#eb5752ff")) +
        scale_color_manual(values = c(Healthy = "#ff9500ff", TME = "#f70b03ff")) +
        theme_minimal() +
        labs(title = "Average FN1 Expression by Cell Type and Tissue Type",
            x = "Cell Type",
            y = "Average FN1 Expression",
            fill = "Tissue Type") +
        theme(plot.title = element_text(hjust = 0.5),
            panel.grid = element_blank(),
            axis.text.x = element_text(angle = 45, hjust = 1),
            axis.text = element_text(size = 12),
            axis.title = element_text(size = 14)
        ) +
        ggpubr::stat_compare_means(
            aes(group = tissue_type),
            method = "t.test",
            label = "p.signif",
            comparisons = NULL,
            label.y = max(avg_expr_long$expression, na.rm = TRUE) + 0.2
        )

ggsave("output/figures/epithelial_analysis/FN1_expression_healthy_vs_TME.pdf",
        average_FN1_plot,
        width = 10,
        height = 10,
        bg = "white")



# whole object reference for rctd
Epithelial_cells_tumor <-
    qs::qread("output/seurat_objects/epithelial_cells_all/final_epi_analysis.qs") %>%
    subset(unique == "tumor")

patient_mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
Metadata_TECS <-
    Epithelial_cells_tumor@meta.data %>%
    rownames_to_column("cell_id") %>%
    select(cell_id, Annotation_detailed)

whole_metadata <-
    patient_mets@meta.data %>%
    rownames_to_column("cell_id") %>%
    select(cell_id, Ann_Level2) %>%
    left_join(Metadata_TECS, by = "cell_id") %>%
    mutate(rctd_ann_col = ifelse(is.na(Annotation_detailed), Ann_Level2, Annotation_detailed)) %>%
    select(cell_id, rctd_ann_col)

patient_mets_ref <-
    AddMetaData(patient_mets,
                whole_metadata %>% column_to_rownames("cell_id"))
dimplot_better(patient_mets_ref, group_by = "rctd_ann_col") + NoLegend()

# make the reference object for rctd
reference <- 
    spacexr::Reference(GetAssayData(patient_mets_ref, layer = "counts"),
                        as.factor(patient_mets_ref$rctd_ann_col),
                        n_max_cells = 2000)

spatial_list <-
    qs::qread("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/spatial_objects/spatial_list_level3_annotations.qs")

# functions
run_rctd <- function(sp_ob, ref) {
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(
        my_data,
        ref,
        max_cores = 4,
        UMI_min = 3,
        counts_MIN = 0,
        UMI_max = 900000000,
        CELL_MIN_INSTANCE = 0
    )
    rctd_out <- spacexr::run.RCTD(
        rctd_obj,
        doublet_mode = "doublet"
    )
    return(rctd_out)
}

# read in object list and select correct reference
for (ob_name in names(spatial_list)) {
    sp_object <- spatial_list[[ob_name]]
    rctd_annots <- run_rctd(sp_ob = sp_object,
                             ref = reference)
    norm_weights <-
            spacexr::normalize_weights(rctd_annots@results$weights) %>%
            as.data.frame()

    spatial_list[[ob_name]] <-
        AddMetaData(spatial_list[[ob_name]], norm_weights)
    # qs::qsave(spatial_list[[ob_name]],
    #     str_c("output/spatial_objects/", ob_name, "_rctd.qs")
    # )
}

# qs::qsave(
#     spatial_list,
#     "output/spatial_objects/spatial_list_with_TAECs.qs"
# )

# plot the rctd results
spatial_list <-
    qs::qread("output/spatial_objects/spatial_list_with_TAECs.qs")
for (ob_name in names(spatial_list)) {
    spatial_list[[ob_name]]$tumor_cumulative <-
        spatial_list[[ob_name]]$Basal_Progenitor +
        spatial_list[[ob_name]]$Fibrogenic +
        spatial_list[[ob_name]]$Interactive +
        spatial_list[[ob_name]]$MP_Progenitor +
        spatial_list[[ob_name]]$Proliferative +
        spatial_list[[ob_name]]$COMA
}

pt_size_factors <- c(
    OS1_Seurat = 1.5,
    OS2_Seurat = 1.4,
    OS3_Seurat = 1.8,
    OS4_Seurat = 1.4,
    OS5_Seurat = 2.5,
    OS6_Seurat = 2.5,
    OS7_Seurat = 1.7,
    OS8_Seurat = 1.2
)

SpatialFeaturePlot(spatial_list$OS2_Seurat,
                                features = "Fibrogenic_TAMs",
                                image.alpha = 0,
                                stroke = NA,
                                pt.size.factor = pt_size_factors[[ob_name]])

# Plot FN1 spatial expression
all_plots <- list()
for (ob_name in names(spatial_list)) {
    plot_list <- list()
    for (gene in c("tumor_cumulative", "FN1", "SFTPC", "ITGA3", "SDC1", "SDC4")) {
        feature_pl <- 
            SpatialFeaturePlot(spatial_list[[ob_name]],
                                features = gene,
                                image.alpha = 0,
                                stroke = NA,
                                pt.size.factor = pt_size_factors[[ob_name]]) +
            theme(legend.title.position = "top",
                  legend.title.size = 2,
                  legend.key.height = unit(0.3, "cm"),
                  legend.key.width = unit(0.7, "cm"))
        plot_list[[gene]] <- feature_pl
    }
    combined_plot <- cowplot::plot_grid(plotlist = plot_list, nrow = 1)
    all_plots[[ob_name]] <- combined_plot
    ggsave(str_c("output/figures/epithelial_analysis/spatial_expression_combined_", ob_name, ".pdf"),
        combined_plot,
        width = 12,
        height = 3,
        bg = "white")
    ggsave(str_c("output/figures/epithelial_analysis/spatial_expression_combined_", ob_name, ".png"),
        combined_plot,
        width = 12,
        height = 3,
        bg = "white")
}
combine_all_plots <- cowplot::plot_grid(plotlist = all_plots, ncol = 1)
ggsave("output/figures/epithelial_analysis/spatial_expression_combined_all_samples.pdf",
    combine_all_plots,
    width = 12,
    height = 21,
    bg = "white")
ggsave("output/figures/epithelial_analysis/spatial_expression_combined_all_samples.png",
    combine_all_plots,
    width = 12,
    height = 21,
    bg = "white")

# could do a correlation plots of two features for example
p <-
    FetchData(spatial_list$OS7_Seurat, vars = c("FN1", "IFNG")) %>%
    as.data.frame() %>%
    # dplyr::filter(FN1 > 0) %>%
    # dplyr::filter(SDC1 > 0) %>%
    ggplot(aes(x = FN1, y = IFNG)) +
    geom_point(alpha = 0.1) +
    #geom_smooth(method = "lm", se = FALSE, color = "blue") +
    theme_minimal() +
    labs(
        title = "Correlation between FN1 and SFTPC Expression (FN1 > 0)",
        x = "FN1 Expression",
        y = "IFNG Expression"
    )

ggExtra::ggMarginal(p, type='histogram', margins = 'both')

# list gene names in the spatial object that start with "IFN" (case-sensitive, fallback to case-insensitive)
genes_all <- rownames(spatial_list$OS8_Seurat)
genes_ifn <- sort(unique(grep("^IFN", genes_all, value = TRUE)))
if (length(genes_ifn) == 0) {
    genes_ifn <- sort(unique(grep("^IFN", genes_all, value = TRUE, ignore.case = TRUE)))
}
print(genes_ifn)
# optionally save to file
writeLines(genes_ifn, "output/ifn_genes_in_OS1.txt")

Spatial_qc_fun <-
    function(spatial_obj) {
        spatial_obj[["percent.mt"]] <-
            PercentageFeatureSet(spatial_obj, pattern = "^MT-")
        spatial_obj <- SCTransform(spatial_obj, assay = "Spatial", verbose = FALSE)
        spatial_obj <- RunPCA(spatial_obj, verbose = FALSE)
        spatial_obj <- FindNeighbors(spatial_obj, dims = 1:30)
        spatial_obj <- FindClusters(spatial_obj, resolution = 0.5)
        spatial_obj <- RunUMAP(spatial_obj, dims = 1:30)
        return(spatial_obj)
    }

spatial_obj <-
    Spatial_qc_fun(spatial_list$OS2_Seurat)

# determine cluster column available in the spatial object
expr_data <- FetchData(spatial_list$OS6_Seurat,
                        vars = c("FN1", "SDC4", "SDC1", "ITGA3", "SCT_snn_res.0.4"))

expr_data <- expr_data %>%
    tibble::as_tibble(rownames = "cell") %>%
    dplyr::rename(cluster = `SCT_snn_res.0.4`) %>%
    tidyr::pivot_longer(cols = c("FN1", "SDC4", "SDC1", "ITGA3"), names_to = "gene", values_to = "expression")

genes <- unique(expr_data$gene)

ggplot(expr_data, aes(x = cluster, y = expression, fill = cluster)) +
    geom_violin(scale = "width", trim = TRUE) +
    facet_wrap(~ gene, ncol = 1, scales = "free_y") +
    theme_classic() +
    labs(title = "Expression of genes across clusters", x = "Cluster", y = "Expression") +
    theme(
        legend.position = "none",
        strip.text = element_text(size = 10),
        axis.text.x = element_text(angle = 45, hjust = 1)
    ) +
SpatialDimPlot(spatial_list$OS6_Seurat,
                group.by = "SCT_snn_res.0.4", label = TRUE, label.size = 3)

```



## compare primary vs mets by pathways as a whole
```{r compare_pathways_primary_mets_as_whole}

## compare_pathway networks between primary and mets for clustering using PCA
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## PCA analysis for each sample within primary and mets
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame()

    # fill up the missing pathways with 0 prob for each sample
    df_wide <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        column_to_rownames("sample_group")  

    # perform PCA
    pca_res <- prcomp(df_wide, scale. = TRUE)
    pca_df <- as.data.frame(pca_res$x)
    pca_df$site <-
        rownames(pca_df) %>%
        str_split("-") %>%
        map_chr(2)
    pca_df$sample_group <-
        rownames(pca_df) %>% 
            str_remove("_AnnL2.*$")

    # get the loadings for PC1
    loadings_pc1 <-
        pca_res$rotation %>%
        as.data.frame() %>%
        select(PC2) %>%
        rownames_to_column("pathways") %>%
        arrange(desc(abs(PC2)))

    # plot PCA
    library(ggrepel)
    pca_plot<-
        ggplot(pca_df, aes(x = PC1, y = PC2, label = sample_group)) +
        geom_point(aes(color = site), size = 3) +
        geom_text_repel(size = 3, max.overlaps = Inf) +
        labs(title = str_c("PCA - ", group_prim, " vs ", group_mets),
             x = "PC1", y = "PC2") +
        theme_minimal() 
    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_mets_pathway_probabilities_PCA.png"),
        pca_plot,
        width = 15,
        height = 10,
        bg = "white"
    )
}


sig_pathways <- list()
## Analysis for the pathway and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # fill up the missing pathways with 0 prob for each sample
    fill_prob_prim_mets <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the mean prob for each pathway in both primary and mets separately
    total_number_primary <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
    total_number_mets <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

    mean_per_pathway_in_mets <-
        pathways_prob_df %>%
        filter(group == "Metastatic") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        #summarise(mean_prob = mean(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_mets) %>%  
        arrange(desc(mean_prob))
    mean_per_pathway_in_primary <-
        pathways_prob_df %>%
        filter(group == "Primary") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_primary) %>%  
        arrange(desc(mean_prob))
    
    # jopin the two means and keep the higher one
    mean_per_pathway <-
        full_join(x = mean_per_pathway_in_primary,
                  y = mean_per_pathway_in_mets,
                  by = "pathway_name",
                  suffix = c("_prim", "_mets")) %>%
        mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
        select(pathway_name, mean_prob) %>%
        arrange(desc(mean_prob))
    
    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        fill_prob_prim_mets %>%
        filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob) %>%
        select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        group_by(pathway_name, group) %>%
        mutate(fold_change = mean(prob) / max(mean_prob)) %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    prob_filter <- median(pathways_prob_df$prob)
    chosen_pathways <- 
        pathways_prob_df_filtered %>%
        #filter(mean_prob > prob_filter & fold_change < 0.5) %>%
        filter(fold_change < 0.7) %>%
        filter(padj < 0.1) %>%
        arrange(desc(prob)) %>%
        select(pathway_name, fold_change) %>%
        distinct() %>%
        arrange(desc(fold_change))

    # finally plot the chosen pathways
    if (nrow(chosen_pathways) != 0) {
       # save the chosen pathways
        sig_pathways[[str_c(group_prim, "_vs_", group_mets)]] <-
            chosen_pathways$pathway_name
        
        plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% chosen_pathways$pathway_name) %>% 
            mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
            mutate(pathway_name = factor(pathway_name, levels = chosen_pathways$pathway_name)) %>%
            ggplot(aes(x = pathway_name, y = log10(norm_prob +0.001), fill = group)) +
            geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
            # ggbeeswarm::geom_beeswarm(aes(color = group)) +
            scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
            scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
            labs(title = str_c("Top Pathways in ", group_prim, " vs ", group_mets),
                x = "Pathway",
                y = "Normalized Probability (by mean)") +
            theme_minimal() +
            theme(
                axis.text.x = element_text(angle = 45, hjust = 1),
                panel.grid = element_blank(),
                axis.line.x = element_line(),
                axis.line.y = element_line())

        ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_pathways_boxplot.png"),
        plot_pathways,
        width = length(chosen_pathways$pathway_name) * 0.6 + 1,
        height = 6,
        limitsize = FALSE,
        bg = "white")
    }
}

```


## Compare prim vs mets pathways tumor as sender and specific celltype as receiver
```{r compare_pathways_primary_mets_specific_receiver}

## compare_pathway networks between primary and mets
# but this time set tumor as sending and normal as receiving

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")

receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

sig_pathways_list <- list()
## Analysis for the pathway and probabilities leve
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # loop for the receiver celltypes
    for (receiver_cell in receiver_celltypes) {
        # list for both primary and mets
        cellchat_list <- list()
        pathways_prob <- list()
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            
            target_cells <- receiver_cell
            
            # filter to LR and pathways and prob
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }
        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            target_cells <- receiver_cell
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
        # this is for the specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_prob) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))
        
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(pathway_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "pathway_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(pathway_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "pathway_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                    group_by(pathway_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(pathway_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(pathway_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(pathway_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(pathway_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "pathway_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(pathway_name, fold_change) %>%
                    distinct()
                # save the significant pathways to a list
                sig_pathways_list[[str_c(receiver_cell, "_in_", group_prim, "_vs_", group_mets)]] <- chosen_pathways

                # finally plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Pathways in ", receiver_cell, " in ",  group_prim, " vs ", group_mets),
                            x = "Pathway",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())
                                    
                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                            dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                            recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_pathways_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant pathway found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    }
}


```


### I want tumor to be the sender and stroma to be the receiver
### look at the top pathways
```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

pathway_of_interest <- c("VEGF", "FN1", "TGFb")

## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob))
        
        target_cells <-
            setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% target_cells) %>% 
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        target_cells <-
            setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
        # target_cells <- receiver_cell

        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% target_cells) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }

    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # only continue if there are both primary and mets samples
    if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
        # fill up the missing pathways with 0 prob for each sample
        fill_prob_prim_mets <-
            pathways_prob_df %>%
            mutate(sample_group = paste(sample, group, sep = "-")) %>%
            select(pathway_name, sample_group, prob) %>%
            pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
            pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
            separate(sample_group, into = c("sample", "group"), sep = "-")

        # calculate the mean prob for each pathway in both primary and mets separately
        total_number_primary <- 
            n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
        total_number_mets <- 
            n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
        
        # only proceed if total number of primary and mets samples are both > 1
        if (total_number_primary > 1 & total_number_mets > 1) {
            mean_per_pathway_in_mets <-
                pathways_prob_df %>%
                filter(group == "Metastatic") %>%
                group_by(pathway_name) %>%
                arrange(desc(prob)) %>%
                summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                arrange(desc(mean_prob))
            mean_per_pathway_in_primary <-
                pathways_prob_df %>%
                filter(group == "Primary") %>%
                group_by(pathway_name) %>%
                arrange(desc(prob)) %>%
                summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                arrange(desc(mean_prob))
            
            # jopin the two means and keep the higher one
            mean_per_pathway <-
                full_join(x = mean_per_pathway_in_primary,
                        y = mean_per_pathway_in_mets,
                        by = "pathway_name",
                        suffix = c("_prim", "_mets")) %>%
                mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                select(pathway_name, mean_prob) %>%
                arrange(desc(mean_prob))
            
            # to calculate the pvalue
            myfun <- function(x) {
                x$pvalue <-
                    t.test(prob ~ group, data = x)$p.value
                return(x)
            }

            # now filter pathways for primary
            pathways_prob_df_filtered <- 
                fill_prob_prim_mets %>%
                filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                arrange(desc(prob)) %>%
                left_join(mean_per_pathway, by = "pathway_name") %>%
                mutate(norm_prob = prob / mean_prob) %>%
                select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                group_by(pathway_name) %>%
                group_split() %>%
                map(~ myfun(.x)) %>%
                bind_rows() %>%
                group_by(pathway_name, group) %>%
                mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                arrange(pathway_name) %>%
                ungroup()

            pull_path_pval <-
                pathways_prob_df_filtered %>%
                select(pathway_name, pvalue) %>%
                distinct() %>%
                mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                select(pathway_name, padj)

            # put the padj baclk to the pathways_prob_df_filtered
            pathways_prob_df_filtered <-
                pathways_prob_df_filtered %>%
                left_join(pull_path_pval, by = "pathway_name")

            prob_filter <- median(pathways_prob_df$prob)
            chosen_pathways <- 
                pathways_prob_df_filtered %>%
                filter(mean_prob > prob_filter & fold_change < 0.75) %>%
                filter(padj < 0.1) %>%
                arrange(desc(prob)) %>%
                select(pathway_name, fold_change) %>%
                distinct()

            # plot the chosen pathways
            if (nrow(chosen_pathways) != 0) {
                plot_pathways <-
                    pathways_prob_df_filtered %>%
                    filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                    mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                    ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                    geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                    geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                    scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                    scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                    labs(title = str_c("Top overall sharedgenes pathways in" , group_prim, " vs ", group_mets),
                        x = "Interaction",
                        y = "Normalized Probability (by mean)") +
                    theme_minimal() +
                                theme(
                                    axis.text.x = element_text(angle = 45, hjust = 1),
                                    panel.grid = element_blank(),
                                    axis.line.x = element_line(),
                                    axis.line.y = element_line())

                if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                    dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                    recursive = TRUE)
                }
                ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/sharedgenes_all_pathways_boxplot.png"),
                plot_pathways,
                width = max(length(chosen_pathways$pathway_name) * 0.75 + 1, 6),
                height = 6,
                bg = "white")
            } else {
                message("No significant interactions found for ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough samples in either primary or metastatic group for  ", group_prim, " vs ", group_mets)
        }
    } else {
        message("Not enough groups or interactions for ", group_prim, " vs ", group_mets)
    }
} 



## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```


### I want tumor to be the sender and stroma to be the receiver but only for significant pathways
for each celltypes shown by analysis above where I look at tumor as sender and specific celltype as receiver

```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor", "Proliferative", "COMA", "MP_Progenitor")


receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

# celltype by signigicant patways from previous analysis


## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    for (receiver_cell in receiver_celltypes) {
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))

            target_cells <- receiver_cell

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                filter(pathway_name == "LAMININ") %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }

        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))
            # target_cells <-
            #     setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
            target_cells <- receiver_cell

            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                filter(pathway_name == "LAMININ") %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
    
        # this is for the specific interactions across primary and mets
        # specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_LR) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))

        # only continue if there are both primary and mets samples
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {

            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(interaction_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-interaction_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
            
            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "interaction_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(interaction_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(interaction_name %in% mean_per_pathway$interaction_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "interaction_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, interaction_name, prob, mean_prob, norm_prob) %>%
                    group_by(interaction_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(interaction_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(interaction_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(interaction_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(interaction_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "interaction_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(interaction_name, fold_change) %>%
                    distinct()

                # plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(interaction_name %in% chosen_pathways$interaction_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(interaction_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Interactions from Tumor to ", receiver_cell," in ",group_prim, " vs ", group_mets),
                            x = "Interaction",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())

                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                        dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                        recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_LR_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant interactions found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    } 
}


## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```




## Leverage Nichenet to identify dowstream
```{r nichenet_downstream_analysis}

# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary
ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
    # Convert the ligand_target_matrix to a long data frame for ggplot

ligand_target_long <- 
    as.data.frame(as.matrix(ligand_target_matrix)) %>%
    rownames_to_column("ligand") %>%
    pivot_longer(-ligand, names_to = "target", values_to = "value")

ggplot(ligand_target_long, aes(x = value)) +
    geom_histogram(bins = 200, fill = "skyblue", color = "black") +
    geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
    labs(title = "Histogram of Ligand-Target Matrix Values",
            x = "Values", y = "Frequency") +
    theme_minimal() +
    xlim(c(0, 0.1))
cutoff <- 0.01

lig <- "FN1"
targets <-
    ligand_target_matrix[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    #filter(score > cutoff) %>%
    mutate(ligand = lig) 



downstream_genes <-
    targets %>%
    filter(target %in% fn1_downstream_genes)

dimplot_better(Epithelial_cells_all, group_by = "seurat_clusters")
fn1_downstream_genes <- c(
  # FAK/Src readouts
  "VIM", "FN1", "TNC", "ITGA5",
  # YAP/TAZ targets
  "POSTN", "ZEB1", "ZEB2",
  # SMAD / TGF-beta targets
  "TGFB1", "SERPINE1", "FN1"
)

prim <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_prim.qs") %>%
    subset(Ann_Level2 == "TAMs")

# run AUCell score using the downstream genes

entire_matrix <- prim@assays$RNA$counts

genelist <- downstream_genes

cell_ranks <-
    AUCell::AUCell_run(exprMat = entire_matrix,
                    geneSets = genelist)
prim$LAMB1 <- AUCell::getAUC(cell_ranks)[1,]

mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs") %>%
    subset(Ann_Level2 == "TAMs")


combine <-
    merge(prim, mets) %>%
    JoinLayers() %>%
    process_seurat()
dimplot_better(combine, group_by = "unique")
VlnPlot(combine,
        group.by = "unique",
        #split.by = "Ann_Level3",
        ncol = 7,
        features = downstream_genes,
        pt.size = 0.1)

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
           pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))  
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))  
    
    }
    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # filter the pathways interested
    interested_pathways <-
        c("FN1", "LAMININ")

    pathways_LR_df_interested <-
        pathways_LR_df %>%
        filter(pathway_name %in% interested_pathways) %>%
        arrange(desc(prob))

    # identify the top downstream activated genes for each top ligand using nichenet
    top_ligands <-
        pathways_LR_df_interested %>%
        distinct(interaction_name) %>%
        separate(interaction_name, into = c("ligand", "receptor"), sep = "_") %>%
        distinct(ligand) %>%
        pull(ligand)

    top_targets <- list()
    for (lig in top_ligands) {
        if (lig %in% rownames(ligand_target_matrix)) {
            targets <-
                ligand_target_matrix[lig, ] %>%
                as.data.frame() %>%
                rownames_to_column("target") %>%
                rename(score = 2) %>%
                arrange(desc(score)) %>%
                head(20) %>%
                mutate(ligand = lig)
            top_targets[[lig]] <- targets

        }
    }


}



```


## spatial nichenet
```{r spatial_nichenet_analysis}

## sample by sample lees perm
lee_stats <-
    read_tsv(
        list.files(
            "output/spacexr/granular_references/lee_perms",
            full.names = TRUE,
            pattern = "lee_perms_.*\\.tsv"
        ),
        show_col_types = FALSE
    ) %>%
    mutate(
        perm_p = if_else(
            perm_p == "p < 1e-05",
            "0.00001",
            perm_p
        ) %>%
            as.numeric(),
        fdr = p.adjust(perm_p, method = "fdr")
    )


correlated <-
    lee_stats %>%
    #filter(group == "Correlated") %>%
    filter(cell_type_1 %in% c("AT1", "AT2") &
            cell_type_2 %in% c("Interactive", "Fibrogenic", "MP_Progenitor", "Basal_Progenitor", "Proliferative", "COMA"))


ggplot(data.frame(value = correlated$lee_stat), aes(x = value)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black") +
    ggtitle("Histogram of Correlated Lee Stat Values") +
    xlab("Lee Stat")


df_pairs <-
    average_spatial_leestat %>%
    rownames_to_column("Cell1") %>%
    pivot_longer(-Cell1, names_to = "Cell2", values_to = "LeeStat") %>%
    filter(Cell1 != Cell2)

# Select top 10% values
threshold <- quantile(df_pairs$LeeStat, 0.95)

top_pairs <- df_pairs %>% filter(LeeStat >= threshold)
high_cells <- top_pairs %>%
  gather(CellRole, Cell, Cell1:Cell2) %>%
  group_by(Cell) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))

# Option 1: Use a fixed LeeStat threshold (e.g., 0.1)
fixed_threshold <- 0.2
top_pairs_fixed <- df_pairs %>% filter(LeeStat >= fixed_threshold)
high_cells_fixed <- 
    top_pairs_fixed %>%
    gather(CellRole, Cell, Cell1:Cell2) %>%
    group_by(Cell) %>%
    summarise(Count = n()) %>%
    arrange(desc(Count))


# Example grouping (you can expand/modify)
pathway_groups <- list(
  ECM = c("COLLAGEN","FN1","LAMININ","TENASCIN","THBS","CADM","NCAM"),
  Angiogenesis = c("VEGF","PDGF","EPHA","PECAM1","NRG","FLRT","ANGPTL"),
  Immune = c("TGFb","MIF","APP","TWEAK","SEMA3","IGF","CXCL","CCL","IL1","TNF"),
  CellAdhesion = c("PTPRM","ICAM","JAM","NECTIN","UNC5","Netrin"),
  GrowthMetabolic = c("Cholesterol","Glutamate","DHEA","PTN","MK")
)

pathway_scores <- data.frame(
  Pathway = c("COLLAGEN","FN1","VEGF","TGFb","Cholesterol"),
  Human = c(0.8,0.7,0.9,0.6,0.3),
  Dog   = c(0.75,0.6,0.2,0.5,0.1),
  Mouse = c(0.5,0.4,0.1,0.2,0.05),
  PDX   = c(0.85,0.65,0.8,0.55,0.2)
)

library(dplyr)
library(tidyr)

aggregate_module <- function(scores_df, groups){
  long <- scores_df %>%
    pivot_longer(-Pathway, names_to="Dataset", values_to="Score") %>%
    mutate(Group = sapply(Pathway, function(p) {
      g <- names(groups)[sapply(groups, function(v) p %in% v)]
      if(length(g)) g[1] else "Other"
    }))
  
  module_summary <- long %>%
    group_by(Group, Dataset) %>%
    summarise(MeanScore = mean(Score, na.rm=TRUE), .groups="drop")
  
  return(module_summary)
}

module_summary <- aggregate_module(pathway_scores, pathway_groups)
print(module_summary)

# Spread to wide for correlations
module_wide <- module_summary %>%
  pivot_wider(names_from=Dataset, values_from=MeanScore)

# Spearman correlation of module patterns
cor_dog   <- cor(module_wide$Human, module_wide$Dog, method="spearman")
cor_mouse <- cor(module_wide$Human, module_wide$Mouse, method="spearman")
cor_pdx   <- cor(module_wide$Human, module_wide$PDX, method="spearman")

print(cor_dog); print(cor_mouse); print(cor_pdx)

library(ggplot2)

ggplot(module_summary, aes(x=Group, y=MeanScore, fill=Dataset)) +
  geom_bar(stat="identity", position="dodge") +
  theme_minimal(base_size=14) +
  ylab("Mean pathway score (aggregated)") +
  xlab("Functional Module") +
  ggtitle("Module-level pathway fidelity across species")


```



Using the all the target and LR interactions
```{r multi_sample_cellchat_analysis_sharedgenes_analysis}

average_pathways <- list()
module_pathways_list <- list()

site_specific_pathways <-
    list(prim = c("COLLAGEN", "LAMININ", "FN1", "APP", "MK",
                "SLIT", "THBS", "CADM", "NCAM", "PTPRM",
                "TGFb", "ADGRL", "PDGF", "VEGF", "MPZ",
                "FLRT", "PTN", "Cholesterol", "TENASCIN", "CDH",
                "MHC-II", "UNC5", "NRXN", "CXCL", "NRG",
                "EPHA", "Glutamate", "CCL"),
        mets = c("COLLAGEN", "LAMININ", "SLIT", "FN1", "ADGRL",
            "CADM", "NCAM", "PTPRM", "APP", "VEGF",
            "THBS", "Glutamate", "UNC5", "PDGF", "CDH",
            "EPHA", "TGFb", "FLRT", "MPZ", "MK",
            "Cholesterol", "PTN", "SEMA3", "PECAM1", "TENASCIN",
            "BMP", "ADGRG", "ICAM", "CCL", "ANNEXIN"))

# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    if (str_detect(group, "prim")) {
        pathways_of_interest <- site_specific_pathways$prim
    }  else if (str_detect(group, "mets")) {
        pathways_of_interest <- site_specific_pathways$mets
    }
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob)) %>%
            select(source, target, pathway_name, prob) %>%
            filter(pathway_name %in% pathways_of_interest) %>%
            mutate(target_LR = paste0(source, "-to-", target, "-", pathway_name)) %>%
            select(target_LR, prob) %>%
            group_by(target_LR) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name) %>%
            ungroup()

        # save to list
        pathways_LR[[sample_name]] <- pathways_and_lr_prob
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        group_by(target_LR) %>%
        summarise(mean_prob = mean(prob)) %>%
        mutate(group = group) %>%
        select(group, target_LR, mean_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(target_LR)
    average_pathways[[group]] <- pathways_LR_df
}

## compare prim vs mets
# make a heatmap from the average pathways
All_cellchat <-
    do.call(rbind, average_pathways) %>%
    as_tibble() %>%
    as.data.frame() %>%
    arrange(desc(mean_prob))

# plots
for (site in c("prim", "mets")) {
    mean_cutoff <-
        All_cellchat %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        select(mean_prob) %>%
        summarise(mean = mean(mean_prob)) %>%
        pull(mean)

    site_specific <-
        All_cellchat %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        arrange(group, target_LR) %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0, id_cols = target_LR) %>%
        column_to_rownames("target_LR")
    cor_matrix <-
        cor(site_specific, use = "everything", method = "spearman")
    pheatmap::pheatmap(
        cor_matrix,
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        color = colorRampPalette(c("#ffe0e0ff", "#fd3f3fff"))(100),
        main = str_c("Correlation Heatmap of Pathways - ", site, " Site"),
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(cor_matrix, 2),
        number_color = "black"
    ) 

    # Alternative: pairwise scatterplots
    site_specific_GGPAIRS <-
        site_specific %>%
        rownames_to_column("pathways") %>%
        filter(pathways != "COLLAGEN") %>%
        column_to_rownames("pathways")
    library(GGally)
    GGally::ggpairs(
        site_specific_GGPAIRS,
        lower = list(continuous = wrap("points", alpha = 0.5)),
        upper = list(continuous = wrap("cor", size = 3)),
        diag = list(continuous = wrap("barDiag", fill = "lightblue")),
        title = str_c("Pairwise Pathway Correlations - ", site, " Site"),
        axisLabels = "show"
    )
}


```




Now using specific modules of pathways
```{r multi_sample_cellchat_analysis_sharedgenes_analysis_modules}

pathway_list_all <- list()
celltypes_receiver_all <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    pathway_list <- list()
    receiver_celltype_list <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        # pull the individual interactions without probabilities
        pathway_present <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            select(pathway_name) %>%
            distinct()
        pathway_list[[sample_name]] <- pathway_present
        # receiver cell types
        receiver_celltypes <-
            unique(cellchat@idents) %>% 
            as.vector()
        receiver_celltype_list[[sample_name]] <- receiver_celltypes
    }
    pathway_list_all[[group]] <- 
        do.call(rbind, pathway_list) %>%
        as_tibble() %>%
        as.data.frame() %>%
        select(pathway_name) %>%
        distinct() %>%
        mutate(group = group)
    
    celltypes_receiver_all[[group]] <-
        do.call(c, receiver_celltype_list) %>%
        unique() %>%
        as.vector() %>%
        sort()
}

# get the unique pathways across all samples
unique_pathways_all <-
    do.call(rbind, pathway_list_all) %>%
    as.tibble() %>%
    as.data.frame() %>%
    select(pathway_name) %>%
    distinct() %>%
    as.vector()
# get the unique receiver cell types across all samples
unique_receiver_celltypes_all <-
    do.call(c, celltypes_receiver_all) %>%
    unique() %>%
    as.vector() %>%
    sort()



# with 50 pathways, we can group them into functional modules
prim_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH",
                            "PECAM1", "ICAM", "SELL", "JAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "ANGPT"),
    Immune_Modulation = c("CXCL", "CCL", "IL1", "MHC-II"),
    Stemness          = c("BMP", "RA", "NRG"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate")
)
length(unlist(prim_modules))
# Metastatic
mets_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH", "PECAM1", "ICAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "FGF", "ANGPT"),
    Immune_Modulation = c("CXCL", "CCL", "IL1", "TNF", "CD80"),
    Stemness          = c("BMP", "RA"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate", "DHEA")
)
length(unlist(mets_modules))
Immune_Modulation_cells <- 
    c("Alv_Macrophages","TAMs","Monocytes","Neutrophils",
        "Mast","DC","T_cells","B_cells","NK_cells","ILCs",
        "Interactive")

# load the objects
All_pathways_and_Groups <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR_per_group <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                                slot.name = "net") %>%
            select(target, prob, pathway_name, interaction_name, source) %>% 
            mutate(Target_LR = paste0(target, "-", interaction_name)) %>%
            select(Target_LR, pathway_name, prob) %>%
            group_by(Target_LR, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop")
            
        # filter out unwanted cell types Neutrophils|Smooth_muscle|
        pathways_and_lr_prob <-
            pathways_and_lr_prob %>%
                filter(!str_detect(Target_LR, "^(Chondrocytes|Mast|Osteoblasts|Stressed|Erythrocytes|Progenitor|MSC|Neuronal)-"))

        # save to list
        pathways_LR_per_group[[sample_name]] <- pathways_and_lr_prob
    }

    pathways_LR_df_group <-
        do.call(rbind, pathways_LR_per_group) %>%
        group_by(Target_LR, pathway_name) %>%
        summarise(mean_prob = mean(prob), .groups = "drop") %>%
        mutate(group = group) %>%
        as_tibble() %>%
        as.data.frame() 
    All_pathways_and_Groups[[group]] <- pathways_LR_df_group
}

# get the combined df
All_pathways_LR_combined <-
    do.call(rbind, All_pathways_and_Groups) %>%
    as_tibble() %>%
    as.data.frame()

#color for pathays in modules
module_colors <- c(
    ECM_Remodelling = "#D43F3AFF",
    Cell_Adhesion = "#EEA236FF",
    Angiogenesis = "#357EBDFF",
    Immune_Modulation = "#5CB85CFF",
    Stemness = "#90302DFF",
    Neuronal = "#9632B8FF",
    Metabolic = "#46B8DAFF"
)


# loop for primary and mets
for (site in c("prim", "mets")) {
    site_specific <-
        All_pathways_LR_combined %>%
        filter(str_detect(group, site)) %>%
        as_tibble() %>%
        filter(pathway_name %in% (if (site == "prim") unique(unlist(prim_modules)) 
                                  else unique(unlist(mets_modules)))) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group,
                    values_from = mean_prob,
                    values_fill = 0,
                    id_cols = c(Target_LR, pathway_name)) %>%
        filter(if (site == "prim") patient_prim > 0 
               else patient_mets > 0) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        # Need to filter the immune modulation pathways to only include those with immune cell targets
        map(function(df) {
            if (df$pathway_name[1] == "CXCL" || df$pathway_name[1] == "CCL" || df$pathway_name[1] == "IL1" || df$pathway_name[1] == "MHC-II" || df$pathway_name[1] == "TNF" || df$pathway_name[1] == "CD80") {
                df %>% filter(str_detect(Target_LR, paste0("^(", paste(Immune_Modulation_cells, collapse = "|"), ")-")))
            } else {
                df
            }
        }) %>%
        # remove any dataframes that are less than 10 rows after filtering
        keep(~ nrow(.) >= 10) %>%
        # Calculate correlation for each group or pathway_name in xeno, mm, and dogs compared to patient
        map(function(df) {
            # Get the patient column (reference)
            patient_col <- grep("^patient_", colnames(df), value = TRUE)
            # Get comparison columns (xeno, mm, dogs)
            compare_cols <- grep("^(xeno|mm|dogs)_", colnames(df), value = TRUE)
            # For each comparison group, calculate Spearman correlation with patient
            cor_results <- lapply(compare_cols, function(col) {
                cor_val <- suppressWarnings(cor(df[[patient_col]], df[[col]], method = "spearman"))
                data.frame(
                    pathway_or_group = unique(df$pathway_name %||% df$Target_LR),
                    comparison_group = col,
                    correlation = if_else(is.na(cor_val), 0, cor_val)
                )
            })
            do.call(rbind, cor_results)
        }) %>%
        bind_rows()

    # plot the correlations
    plot_cooraltion_df <-
        site_specific %>%
        pivot_wider(names_from = comparison_group,
            values_from = correlation,
            values_fill = 0) %>%
        arrange(factor(pathway_or_group,
                    levels = if (site == "prim") unique(unlist(prim_modules)) 
                             else unique(unlist(mets_modules)))) %>%
        column_to_rownames("pathway_or_group") %>%
        rename(patient = starts_with("patient_"),
                PDX = starts_with("xeno_"),
                Mouse = starts_with("mm_"),
                Dogs = starts_with("dogs_")) %>%
                select(Dogs, Mouse, PDX) %>%
        as.matrix()

    # plot the heatmap 
    # describe the color for the values
    my_colors <- c("#46a2f1ff", "#ffffff", "#a80601ff")
    my_breaks <- c(-1, -0.3, 0.3, 1)
    my_values <- scales::rescale(my_breaks, from = c(-1, 1))
    # Map pathway_name to module and color
    module_map <- if (site == "prim") prim_modules else mets_modules
    module_color_df <- tibble(
        pathway_name = unlist(module_map),
        module = rep(names(module_map), lengths(module_map)),
        color = unname(module_colors[rep(names(module_map), lengths(module_map))])
    )

    # Prepare data for plotting
    plot_cooraltion_df_df <- as.data.frame(as.table(plot_cooraltion_df))
    plot_cooraltion_df_df$module <- module_color_df$module[match(plot_cooraltion_df_df$Var1, module_color_df$pathway_name)]
    plot_cooraltion_df_df$color <- module_color_df$color[match(plot_cooraltion_df_df$Var1, module_color_df$pathway_name)]

    # Colored y-axis labels
    pathway_label_colors <- module_color_df$color
    names(pathway_label_colors) <- module_color_df$pathway_name
    y_labels_colored <- sapply(
        rownames(plot_cooraltion_df),
        function(lab) {
            col <- pathway_label_colors[lab]
            if (is.na(col)) col <- "#000000"
            sprintf("<span style='color:%s'>%s</span>", col, lab)
        }
    )

    heatmap_LR <- 
        ggplot(plot_cooraltion_df_df, 
            aes(x = Var2, y = factor(Var1, levels = rev(rownames(plot_cooraltion_df))), fill = Freq)) +
            geom_tile(color = "white", linewidth = 0.5) +
            geom_text(aes(label = sprintf("%.2f", Freq)), size = 5, color = "black") +
            scale_fill_gradientn(colours = my_colors,
                                values = my_values,
                                limits = c(-1, 1),
                                name = "Spearman\nCorrelation",
                                guide = guide_colorbar(barwidth = 1, barheight = 15,
                                                      frame.colour = "black", ticks.colour = "black")) +
            labs(x = "Comparison Group",
                y = "Pathway",
                title = str_c("Correlation Heatmap of Pathways - ", site, " Site")) +
            theme_minimal(base_size = 15) +
            theme(axis.text.x = element_text(size = 15),
                axis.text.y = ggtext::element_markdown(size = 15),
                axis.title = element_text(size = 15),
                plot.title = element_text(size = 15, hjust = 0.5),
                legend.title = element_text(size = 15),
                legend.text = element_text(size = 15),
                panel.grid = element_blank(),
                panel.border = element_rect(color = "black", fill = NA, linewidth = 1)) +
            guides(fill = guide_colorbar(barwidth = 1, barheight = 15)) 
            # +
            # scale_y_discrete(labels = y_labels_colored) +
            # geom_point(data = module_color_df %>% distinct(module, color),
            #     aes(x = 1, y = -Inf, color = module),
            #     size = 5, shape = 15, inherit.aes = FALSE, show.legend = TRUE) +
            # scale_color_manual(name = "Pathway Module",
            #     values = setNames(module_colors, names(module_colors)),
            #     guide = guide_legend(override.aes = list(size = 5, shape = 15),
            #                         order = 1,
            #                         title.position = "top",
            #                         title.hjust = 0.5,
            #                         label.position = "right",
            #                         label.hjust = 0),
            #     breaks = names(module_colors),
            #     labels = names(module_colors)) +
            # theme(legend.position = "right",
            #      legend.box = "vertical",
            #      legend.box.just = "left")

    ggsave(str_c("output/figures/cellchat/sharedgenes_modules/correlation_heatmap_pathways_",
                site, ".png"),
            heatmap_LR,
            width = 7,
            height = 12,
            bg = "white")
    ggsave(str_c("output/figures/cellchat/sharedgenes_modules/correlation_heatmap_pathways_",
                site, ".pdf"),
            heatmap_LR,
            width = 7,
            height = 12,
            bg = "white")

    # compute one average point per module x comparison_group
    plot_cooraltion_df_long <-
        plot_cooraltion_df_df %>%
        rename(pathway_name = Var1,
                comparison_group = Var2,
                correlation = Freq)

    # ensure a 'module' column exists by mapping pathway_name to module_color_df (use match to avoid join failures)
    plot_cooraltion_df_long$module <-
        module_color_df$module[match(plot_cooraltion_df_long$pathway_name, module_color_df$pathway_name)]
    
    module_avg_df <-
        plot_cooraltion_df_long %>%
        group_by(module, comparison_group) %>%
        summarize(mean_corr = mean(correlation, na.rm = TRUE), .groups = "drop")
 
     # violin + one dot per module (module dots colored by module)
    violin_plot_correlation <-
        ggplot(plot_cooraltion_df_long, aes(x = comparison_group, y = correlation, fill = comparison_group)) +
        geom_violin(trim = FALSE, alpha = 0.6, width = 0.9) +
        geom_boxplot(width = 0.15, outlier.shape = NA, alpha = 0.9, colour = "black",
                    position = position_dodge(width = 0.9)) +
        # overlay module-average points (dodge so points for different modules don't perfectly overlap)
        geom_point(data = module_avg_df,
                aes(x = comparison_group, y = mean_corr, color = module),
                position = position_dodge(width = 0.4),
                size = 5) +
        labs(title = str_c("Distribution of Pathway Correlations - ", site, " Site"),
            x = "Comparison Group",
            y = "Spearman Correlation",
            fill = "Comparison",
            color = "Module Average") +
        theme_minimal(base_size = 14) +
        theme(axis.text.x = element_text(size = 12),
            axis.text.y = element_text(size = 12),
            axis.title = element_text(size = 13),
            plot.title = element_text(size = 15, hjust = 0.5),
            legend.position = "right") +
        scale_fill_manual(values = c(Dogs = "#ffd497ff", PDX = "#fd7e79ff", Mouse = "#a0ffa0ff")) +
        scale_color_manual(values = c(module_colors, Other = "#666666"))
    ggsave(str_c("output/figures/cellchat/sharedgenes_modules/violin_plot_correlation_pathways_",
                site, ".png"),
            violin_plot_correlation,
            width = 10,
            height = 6,
            bg = "white")
    ggsave(str_c("output/figures/cellchat/sharedgenes_modules/violin_plot_correlation_pathways_",
                site, ".pdf"),
            violin_plot_correlation,
            width = 10,
            height = 6,
            bg = "white")

}


```


## matts permutation
```{r matt_permutation_cellchat_analysis}
run_cellchat <- function(sobject,
                        group.by="celltype",
                        species_db="human") {
    data.input <- 
        GetAssayData(sobject, assay="RNA", slot="data")  # log-normalized
    meta <- 
        data.frame(labels = sample(sobject[[group.by]][,1]), row.names=colnames(sobject))
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
    cellchat@DB <- if (species_db=="human") CellChatDB.human else CellChatDB.mouse
    future::plan("multisession", workers = 10) # do parallel
    cellchat <- 
        subsetData(cellchat) %>%
        identifyOverExpressedGenes() %>%
        identifyOverExpressedInteractions() %>%
        computeCommunProb() %>%
        filterCommunication(min.cells = 10) %>%
        computeCommunProbPathway() %>%
        aggregateNet() %>%
        netAnalysis_computeCentrality()
  return(cellchat)
}

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim",
                # "patient_mets",
                # "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects_permutation/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat_perm <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if(dir.exists(str_c("output/cellchat_objects_permutation/", group))==FALSE){
                dir.create(str_c("output/cellchat_objects_permutation/", group), recursive = TRUE)
            }
            qs::qsave(cellchat_perm, str_c("output/cellchat_objects_permutation/", group, "/", sample, "_AnnL2_whole", ".qs"))  
        }
    }
}


for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_permutation/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR_per_group <- list()
    hist_list <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                                slot.name = "net") %>%
            mutate(sample = sample_name)
        hist_p <- 
            ggplot(pathways_and_lr_prob, aes(x = prob)) +
                geom_histogram(bins = 50, fill = "skyblue", color = "black") +
                labs(title = sample_name, x = "Interaction Probability", y = "Count") +
                theme_minimal() 
        hist_list[[sample_name]] <- hist_p
        # save to list
        pathways_LR_per_group[[sample_name]] <- pathways_and_lr_prob
    }

    pathways_LR_df_group <-
        do.call(rbind, pathways_LR_per_group) 

    pathways_LR_df_group %>%
        ggplot(aes(x = prob)) +
        geom_histogram(bins = 50, fill = "skyblue", color = "black") +
        facet_wrap(~ sample, ncol = 5, scales = "free_y")

    hist(pathways_LR_df_group$prob, breaks=50)
    
    All_pathways_and_Groups[[group]] <- pathways_LR_df_group
}

# plot the histogram of probabilities
all_probs <-
    patchwork::wrap_plots(hist_list, ncol=7) +
    plot_annotation(title ="PMets CellChat Interaction Probabilities",
                    theme = theme(plot.title = element_text(size = 20, hjust = 0.5)))

```

## Cellchat Validation with potential co-culture
```{r cell_chat_to_wetlab}

samples_info <-
    tribble(
        ~sample_name,           ~details,                   ~method,
        # "S0001",             "HBEC_and_OS17_MOX",       "SC_10X",
        # "S0064A",             "HBEC_OS17_COX1",             "SC_10X",
        # "S0064B",             "HBEC_OS17_COX2",             "SC_10X",
        "S0144",             "Day0",                            "SC_10X",
        "S0145",             "Day1",                            "SC_10X",
        "S0146",             "Day5",                        "SC_10X")

HBEC_OS17_COX_mix_day5
sample_list <- list()
for (i in 1:nrow(samples_info)) {
    sample <- samples_info$sample_name[i]
    details <- samples_info$details[i]
    object <-
        qs::qread(str_c("/gpfs0/home2/gdrobertslab/lab/SeuratObj_2/",
                        sample,"_human.qs"))
    object$sample_name <- sample
    object$details <- details
    sample_list[[sample]] <- object
}

combined_obj <-
    merge(sample_list[[1]],
          y = sample_list[-1],
          add.cell.ids = names(sample_list),
          project = "CoCulture_HBEC_OS17_COX3") %>%
    JoinLayers() %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = "sample_name") %>%
    process_seurat(reduction = "harmony",
                    resolution = 0.1)
combined_obj$cox_mono <-
    str_replace_all(combined_obj$details,
                    c("Day0"="Mono",
                      "Day1"="COX",
                      "Day5"="COX"))

combined_obj$Ann_l3 <-
    str_replace_all(combined_obj$seurat_clusters,
                    c("0"="Tumor",
                      "1"="Epithelial",
                      "2"="Tumor",
                      "3"="Epithelial"))
qs::qsave(combined_obj,
            "output/seurat_objects/HBEC_OS17_COX_combined_obj.qs")

# load the object
combined_obj <-
    qs::qread("output/seurat_objects/HBEC_OS17_COX_combined_obj.qs")
tumor <-
    subset(combined_obj, Ann_l3 == "Tumor")

# Violin plot with overlaid boxplot using raw data for reliable layering
df_plot_FN1 <- FetchData(tumor, vars = c("FN1", "details")) %>% 
    as.data.frame()
Fn1_tumor_vln_boxplot <-
    ggplot(df_plot_FN1, aes(x = details, y = FN1, fill = details)) +
        geom_violin(trim = FALSE, scale = "width", alpha = 0.8) +
        geom_boxplot(width = 0.12, outlier.shape = NA, color = "black", alpha = 0.9) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
                    legend.position = "none") +
        scale_fill_manual(values = c("Day0" = "#5CB85CFF", "Day1" = "#fc8d62", "Day5" = "#D43F3AFF")) +
        labs(x = NULL, y = "FN1 expression", title = "FN1 expression in Tumor Cells")
ggsave("output/figures/epithelial_analysis/for_wetlab/FN1_tumor_vln_boxplot.png",
        Fn1_tumor_vln_boxplot,
        width = 5,
        height = 7,
        bg = "white")

epithelial <-
    subset(combined_obj, Ann_l3 == "Epithelial")

dimplot_better(epithelial,
                    group_by = "details")


genes <- c("SDC4","ITGA3","ITGB1","ITGAV","CD44", "SDC1", "FN1", "VIM",
            "SERPINE1", "FAP", "TNC", "TAGLN", "PLOD2")
more_genes <- c(
    "ITGA1","ITGA2","ITGA3","ITGA4","ITGA5","ITGA6","ITGA7","ITGA8","ITGA9",
    "ITGA10","ITGA11","ITGAD","ITGAE","ITGAL","ITGAM","ITGAV","ITGAX",
    "ITGB1","ITGB2","ITGB3","ITGB4","ITGB5","ITGB6","ITGB7","ITGB8"
)
DotPlot(epithelial,
        features = "ZEB1",
        group.by = "details",
        scale = F,
        cols = "RdBu")
dotplot_intgrins <-
    DotPlot(epithelial,
            features = c(genes, more_genes) %>% unique(),
            group.by = "details",
            scale = T,
            cols = "RdBu") +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
                legend.position = "right") +
    coord_flip() +
    ggtitle("Expression of Integrins in Epithelial Cells")

ggsave("output/figures/epithelial_analysis/for_wetlab/dotplot_integrins_fn1_receptors_epi.png",
        dotplot_intgrins,
        width = 6,
        height = 10,
        bg = "white")

df_plot <- FetchData(epithelial, vars = c(genes, "details")) %>%
    tibble::rownames_to_column("cell") %>%
    tidyr::pivot_longer(cols = all_of(genes), names_to = "gene", values_to = "expression")

violin_boxplot_fn1_receptors_in_epi <-
    ggplot(df_plot, aes(x = details, y = expression, fill = details)) +
        geom_violin(trim = FALSE, scale = "width", alpha = 0.7) +
        geom_boxplot(width = 0.12, outlier.shape = NA, color = "black", alpha = 0.9,
                                position = position_dodge(width = 0.9)) +
        facet_wrap(~ gene, scales = "free_y", ncol = 3) +
        theme_minimal(base_size = 12) +
        scale_fill_manual(values = c("Day0" = "#5CB85CFF", "Day1" = "#fc8d62", "Day5" = "#D43F3AFF")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
                    legend.position = "none") +
        labs(x = NULL, y = "Expression", title = "Expression of FN1 receptors in Epithelial Cells")

if(!dir.exists("output/figures/epithelial_analysis/for_wetlab")) {
    dir.create("output/figures/epithelial_analysis/for_wetlab", recursive = TRUE)
}
ggsave("output/figures/epithelial_analysis/for_wetlab/violin_boxplot_fn1_receptors_in_epi.png",
        violin_boxplot_fn1_receptors_in_epi,
        width = 7,
        height = 10,
        bg = "white")


# find downstream targets of FN1
ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
    # Convert the ligand_target_matrix to a long data frame for ggplot

ligand_target_long <- 
    as.data.frame(as.matrix(ligand_target_matrix)) %>%
    rownames_to_column("ligand") %>%
    pivot_longer(-ligand, names_to = "target", values_to = "value")

lig <- "FN1"
targets <-
    ligand_target_matrix[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    #filter(score > cutoff) %>%
    mutate(ligand = lig) %>%
    select(target) %>%
    slice_head(n = 100)

# check the targets at each time point
each_timepoint_df <-
    AverageExpression(epithelial,
                    group.by = "details",
                    assays = "RNA",
                    features = targets$target,
                    slot = "data")$RNA %>%
    as.data.frame() %>%
    rownames_to_column("gene") %>%
    column_to_rownames("gene") %>%
    as.matrix()

# plot heatmap of targets across time points
heatmap_targets_timepoints <-
    pheatmap::pheatmap(each_timepoint_df,
                    cluster_rows = TRUE,
                    cluster_cols = FALSE,
                    scale = "row",
                    color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100),
                    fontsize_row = 6,
                    fontsize_col = 10,
                    main = "Heatmap of Top 100 FN1 Downstream Targets in Epithelial Cells Across Timepoints")
if(!dir.exists("output/figures/epithelial_analysis/for_wetlab")) {
    dir.create("output/figures/epithelial_analysis/for_wetlab", recursive = TRUE)
}
ggsave("output/figures/epithelial_analysis/for_wetlab/heatmap_FN1_downstream_targets_timepoints.png",
        heatmap_targets_timepoints,
        width = 4,
        height = 10,
        bg = "white")

# Want to quantifyt and plot what genes form Targets$target goes up vs down over time
time_points <- c("day0"=0, "day1"=1, "day5"=5)
# compute average expression per gene in COX vs Mono and plot which genes go up in COX or in Mono
# define the group column names produced by AverageExpression
cox_name <- "COX"
mono_name <- "Mono"

# compute average expression per gene in COX vs Mono and store as df_changes
df_changes <-
    AverageExpression(epithelial,
                    group.by = "cox_mono",
                    assays = "RNA",
                    features = targets$target,
                    slot = "data")$RNA %>%
    as.data.frame() %>%
    rownames_to_column("gene") %>%
    mutate(change = .data[[cox_name]] - .data[[mono_name]],
            direction = ifelse(change > 0, "Up_in_COX", "Up_in_Mono")) %>%
    arrange(change) %>%
    mutate(gene = factor(gene, levels = gene))  # preserve order for plotting

n_up <- sum(df_changes$change > 0, na.rm = TRUE)
n_down <- sum(df_changes$change < 0, na.rm = TRUE)

# waterfall / barplot showing directional change
plot_exp_change <-
    ggplot(df_changes, aes(x = gene, y = change, fill = direction)) +
        geom_col() +
        geom_hline(yintercept = 0, color = "gray40") +
        coord_flip() +
        scale_fill_manual(values = c(Up_in_COX = "#D43F3AFF", Up_in_Mono = "#5CB85CFF")) +
        labs(title = "Change in Average Expression of Genes DS of FN1 (COX - Mono) in Epithelial Cells",
            subtitle = paste0("Genes up in COX: ", n_up, " | Genes up in Mono: ", n_down),
            x = NULL, y = "COX - Mono (change in expression)") +
        theme_minimal(base_size = 12) +
        theme(axis.text.y = element_text(size = 9), plot.title = element_text(face = "bold"))

if(!dir.exists("output/figures/epithelial_analysis/for_wetlab")) {
    dir.create("output/figures/epithelial_analysis/for_wetlab", recursive = TRUE)
}
ggsave("output/figures/epithelial_analysis/for_wetlab/waterfall_exprsn_change_COX_vs_Mono_ds_of_FN1.png",
        plot_exp_change,
        width = 10,
        height = 10,
        bg = "white")

# find the top 20 genes that go up in COX downstream of FN1
df_changes_up <-
    df_changes %>%
    filter(change > 0) %>%
    arrange(desc(change)) %>%
    select(gene, change) %>%
    slice_head(n = 15)

# make the vector of those top 20 genes
top20_genes_up_in_COX_ds_FN1 <- c(
    "SLPI", "IGFBP3", "PLAU", "PTGS2", "INHBA", "IL32", "IGFBP7", "CLDN1",
    "PRNP", "GLG1", "VEGFC", "IL18", "GAS6", "IL1B", "IL15", "CCN2",
    "PRRG4", "TGFB1", "BMP2", "IL23A"
)

# Prepare long dataframe for plotting
df_plot <- FetchData(epithelial, vars = c(top20_genes_up_in_COX_ds_FN1, "details")) %>%
    tibble::rownames_to_column("cell") %>%
    pivot_longer(cols = all_of(top20_genes_up_in_COX_ds_FN1),
                             names_to = "gene",
                             values_to = "expression")

# Violin + boxplot (one panel per gene)
violin_boxplot <-
    ggplot(df_plot, aes(x = details, y = expression, fill = details)) +
        geom_violin(trim = FALSE, scale = "width", alpha = 0.7) +
        geom_boxplot(width = 0.12, outlier.shape = NA, colour = "black", alpha = 0.9) +
        #geom_jitter(width = 0.15, size = 0.5, alpha = 0.4) +
        facet_wrap(~ gene, ncol = 5, scales = "free_y") +
        theme_minimal(base_size = 12) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1),
              legend.position = "none") +
        scale_fill_manual(values = c("Day0" = "#5CB85CFF", "Day1" = "#fc8d62", "Day5" = "#D43F3AFF")) +
        labs(x = NULL, y = "Expression", title = "Top FN1 downstream genes: Violin + boxplot by timepoint")
# Optionally save
ggsave("output/figures/epithelial_analysis/for_wetlab/top20_FN1_downstream_violin_boxplot.png",
             violin_boxplot, width = 10, height = 10, bg = "white")


```

## DEGS and GSEA
```{r tumor_epit_degs_gsea}

# load the object
combined_obj <-
    qs::qread("output/seurat_objects/HBEC_OS17_COX_combined_obj.qs") %>%
    subset(nCount_RNA < 50000) %>%
    process_seurat(reduction = "harmony",
                    resolution = 0.1)

dimplot_better(combined_obj,
                group_by = "details")
FeaturePlot(combined_obj,
            features = c(Diana_wants, EOD, LOD) %>% unique(),
            ncol = 5) +
    plot_annotation(title = "Combined Object: FN1, KRT8, VIM Expression")

tumor <-
    subset(combined_obj, Ann_l3 == "Tumor") %>%
    RunHarmony(group.by.vars = c("sample_name", "") %>%
    # subset(details == "Day5") %>%
    process_seurat(resolution = 0.3) 
dimplot_better(tumor,
                group_by = "seurat_clusters")
tumor$deta <- paste0(tumor$details, "_", tumor$seurat_clusters)

DimPlot(tumor,
            group.by = "details",
            label = TRUE,
            reduction = "pca",
            dims = c(2,3),
            label.size = 5) +
    plot_annotation(title = "Tumor Cells Colored by Timepoint and Cluster")
Idents(tumor) <- "details"
VlnPlot(tumor,
            features = c("FN1", "KRT8", "KRT18", "VIM", "ZEB1"),
            group.by = "deta",
            ncol = 1)
(dimplot_better(tumor,
                group_by = "details")/
FeaturePlot(tumor,
            features = "KRT8") +
    plot_annotation(title = "Tumor Cells Colored by Timepoint and Cluster"))

Diana_wants <- c("FOS", "FOSB", "JUN", "JUNB", "EGR1")
EOD <- c("RUNX2", "SP7", "MEF2C", "SATB2", "ZNF148")
LOD <- c("FOSL1", "FOSL2", "JUN", "ATF4", "NFATC2")
DotPlot(tumor,
        features = c(Diana_wants, EOD, LOD) %>% unique(),
        group.by = "seurat_clusters",
        scale = F,
        cols = "RdBu") +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
                legend.position = "right") +
    coord_flip() +
    ggtitle("Expression of Transcription Factors in Tumor Cells")

Epithelial <-
    subset(combined_obj, Ann_l3 == "Epithelial")

For (celltypes in unique(combined_obj$Ann_l3)) {
    sub_object <-
        subset(combined_obj, Ann_l3 == celltypes)
    Idents(sub_object) <- "details"
    degs_day5_vs_day0 <-
        FindMarkers(object = sub_object,
                    ident.1 = "Day5",
                    ident.2 = "Day0")
    degs_i_want <-
        degs_day5_vs_day0 %>%
        rownames_to_column("gene") %>%
        filter(p_val_adj < 0.05 & avg_log2FC > 0.25) %>%
        mutate(pct_diff = pct.1 - pct.2) %>%
        arrange(desc(pct_diff)) %>%
        filter(pct_diff > 0.10) %>%
        arrange(desc(avg_log2FC))
    
    # perform gsea on the degs
    gene_list <- degs_i_want$avg_log2FC
    names(gene_list) <- degs_i_want$gene
    gene_list <- sort(gene_list, decreasing = TRUE)

    #GSEA Miltilevel
    cat_tib <- dplyr::tribble(
        ~category, ~subcategory,   ~cat_expl,
        "H",        "NA",          "Hallmark_paths",
        "C2",       "CP:REACTOME", "Reactome"
        )

    all_gsea_results <- list()
    for (i in 1:nrow(cat_tib)) {
        cat <- cat_tib$category[i]
        subcat <- cat_tib$subcategory[i]
        expl <- cat_tib$cat_expl[i]

        if (subcat == "NA") {
            gsea_ref <- 
                msigdbr::msigdbr(species = "Homo sapiens",
                                category = cat,
                                subcategory = NA) %>%
                split(x = .$gene_symbol, f = .$gs_name)
            } else {
            gsea_ref <- 
                msigdbr::msigdbr(species = "Homo sapiens",
                                category = cat,
                                subcategory = subcat) %>%
                split(x = .$gene_symbol, f = .$gs_name)
            }
        output <-
            fgsea::fgseaMultilevel(gsea_ref,
                                    gene_list,
                                    minSize = 10,
                                    maxSize = 500,
                                    nPermSimple = 10000)
        gsea_output <-
            output %>%
            dplyr::arrange(desc(NES)) %>%
            filter(padj < 0.05) %>%
            group_by(pathway) %>%
            mutate(leadingEdge = unlist(leadingEdge) %>%
                        str_c(collapse = ", ")) %>%
            ungroup() %>%
            na.omit() %>%
            filter(NES > 0)
        # save to the list
        all_gsea_results[[cat]] <- gsea_output
    }

    All_pathways <-
        bind_rows(all_gsea_results, .id = "category") %>%
        as.data.frame()

    # make a dotplot of the top 5 up and down regulated pathways in each comparison
    All_pathways$sample <- "mesenchymal_vs_AT1AT2"
    All_pathways_for_plot <-
        All_pathways %>%
        dplyr::select(pathway,
                    NES,
                    size,
                    padj) %>%
        arrange(desc(NES)) %>%
        mutate(pathway = as.factor(pathway) %>%
                    str_replace_all("_", " ") %>%
                    str_wrap(80) %>%
                    fct_reorder(NES),
                sample = "Mesenchymal vs AT1/AT2",
                order = seq_len(n()),
                justify_y = dplyr::if_else(NES > 0, 1, 0),
                y_pos = dplyr::if_else(NES > 0, -0.1, 0.1))

    # make a plot
    gsea_plot <- 
        gsea_dotplot(data = All_pathways_for_plot, x_col = "NES")
    
    ggsave(str_c("output/figures/epithelial_analysis/for_wetlab/gsea_",
                celltypes,
                "_day5_vs_day0.png"),
            gsea_plot,
            width = 8,
            height = 6,
            bg = "white")
    
}


#leading edge of top pathways
leading_edge_list <- list()
for (pathway in unique(All_pathways$pathway)) {
    leading_edge_genes <-
        All_pathways %>%
        filter(pathway == !!pathway) %>%
        pull(leadingEdge) %>%
        str_split(", ") %>%
        unlist()
    leading_edge_list[[pathway]] <- leading_edge_genes
    
}

DotPlot(epithelial,
        features = leading_edge_list$HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION,
        group.by = "details",
        scale = T,
        cols = "RdBu") +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
                legend.position = "right") +
    coord_flip() +
    ggtitle("Expression of Leading Edge Genes from GSEA in Epithelial Cells")


```