

## Run Nichenet and other analyses

```{r cell_cell_communication}
object_list <-
    tribble(~group1,                         ~group2,                       ~group3,
            "xeno_prim_mouse",              "xeno_prim_human_cancer_cells", "xeno_prim_cancer_normal",
            "xeno_mets_mouse",              "xeno_mets_human_cancer_cells", "xeno_mets_cancer_normal"
            )

# conver the xeno mouse stroma into human symbols
for (i in 1:nrow(object_list)) {
    group1 <- object_list$group1[i]
    group2 <- object_list$group2[i]
    group3 <- object_list$group3[i]
    object1 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group1,
                        ".qs"))
    raw_counts <-
        GetAssayData(object1,
                     slot = "counts")

    human_genes <-
        object1 %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object1@meta.data)
    object1 <-
        new_seurat_object %>%
        process_seurat()

    object2 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group2,
                        ".qs"))
    combined_object <-
        merge(object1, object2) %>%
        JoinLayers() %>%
        process_seurat() %>%
        RunHarmony(group.by.vars = c("sample_name", "model"),
                    theta = c(12, 12),
                    lambda = c(0.1, 0.1)) %>%
        process_seurat(reduction = "harmony")

    combined_object$organism <- "human"
    combined_object$unique <- group3

    qs::qsave(combined_object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group3,
                    ".qs"))
}

# convert dog to human symbols
orthologs <-
    read_tsv("input/downloads/dog_human_gene_orthologs.txt")
for (group in c("dogs_prim",
                "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")

    number_of_ENSEMBL_genes <-
        sum(str_detect(rownames(raw_counts), "^ENSCAFG"))

    raw_counts_new <-
        raw_counts[rownames(raw_counts) %in% orthologs$dog_gene_name, ]
    rownames(raw_counts_new) <-
        orthologs$human_gene_ortholog[match(rownames(raw_counts_new), orthologs$dog_gene_name)]
    new_seurat_object <-
        CreateSeuratObject(counts = raw_counts_new) %>%
        AddMetaData(metadata = object@meta.data)
    newobject <-
        new_seurat_object %>%
        process_seurat()
    newobject$organism <- "human"
    qs::qsave(newobject,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

for (group in c("mm_prim",
                "mm_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")
    human_genes <-
        object %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object@meta.data)
    object <-
        new_seurat_object %>%
        process_seurat()
    
    object$organism <- "human"
    qs::qsave(object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

# function for cellchat function
suppressPackageStartupMessages({
  library(CellChat); library(patchwork)
})
run_cellchat <- function(sobject,
                        group.by="celltype",
                        species_db="human") {
    data.input <- GetAssayData(sobject, assay="RNA", slot="data")  # log-normalized
    meta <- data.frame(labels = sobject[[group.by]][,1], row.names=colnames(sobject))
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
    cellchat@DB <- if (species_db=="human") CellChatDB.human else CellChatDB.mouse
    future::plan("multisession", workers = 10) # do parallel
    cellchat <- 
        subsetData(cellchat) %>%
        identifyOverExpressedGenes() %>%
        identifyOverExpressedInteractions() %>%
        computeCommunProb() %>%
        filterCommunication(min.cells = 10) %>%
        computeCommunProbPathway() %>%
        aggregateNet() %>%
        netAnalysis_computeCentrality()
        # computeNetSimilarity(type = "functional") %>%
        # netEmbedding(type = "functional") %>%
        # netClustering(type = "functional", do.parallel = FALSE) %>%
        # computeNetSimilarity(type = "structural") %>%
        # netEmbedding(type = "structural") %>%
        # netClustering(type = "structural", do.parallel = FALSE)
  return(cellchat)
}

pathways_by_module <-
    CellChatDB.human$interaction %>%
    select(pathway_name, annotation) %>%
    group_by(annotation) %>%
        summarise(pathways = list(unique(pathway_name)))

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim",
                # "patient_mets"
                # "mm_prim",
                # "mm_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho"
                "mm_primhuman_ortho"
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects", "/", group))) {
                dir.create(str_c("output/cellchat_objects", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}



# cellchat at ann_level2 using all the pathways general identify the shared genes only
list_of_genes <- list()
samples_numbers <- list()
for (group in c(
                # "patient_prim",
                # "patient_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal",
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho",
                # "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    samples_numbers[[group]] <- length(unique(object$sample_name))

    genes <- rownames(object)
    list_of_genes[[group]] <- genes
}

# shared genes
shared_genes <-
    Reduce(intersect, list_of_genes) %>%
    as_tibble()

# save the shared genes
write_tsv(shared_genes,
          "input/shared_genes_across_groups_for_cellchat.txt")

# load the shared genes
shared_genes <-
    read_tsv("input/shared_genes_across_groups_for_cellchat.txt",
            col_names = "gene")  %>%
            as.data.frame()

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim"
                # "patient_mets"
                # "xeno_prim_cancer_normal"
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho"
                # "dogs_metshuman_ortho"
                "mm_primhuman_ortho"
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    object <-
        subset(object, features = shared_genes$gene) %>%
        process_seurat()

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects_sharedgenes", "/", group))) {
                dir.create(str_c("output/cellchat_objects_sharedgenes", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects_sharedgenes/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}




```

### Run cellchat in slurm job
```{bash cellchat_slurm_job}

sbatch --array=1-25 child_qmds/cellchat_run_shellscript.sh patient_prim 
sbatch --array=1-36 child_qmds/cellchat_run_shellscript.sh patient_mets
sbatch --array=1-14 child_qmds/cellchat_run_shellscript.sh  xeno_prim_cancer_normal
sbatch --array=1-12 child_qmds/cellchat_run_shellscript.sh xeno_mets_cancer_normal
sbatch --array=1-17 child_qmds/cellchat_run_shellscript.sh dogs_primhuman_ortho
sbatch --array=1-16 child_qmds/cellchat_run_shellscript.sh dogs_metshuman_ortho
sbatch --array=1-3 child_qmds/cellchat_run_shellscript.sh mm_primhuman_ortho
sbatch --array=1-8 child_qmds/cellchat_run_shellscript.sh mm_metshuman_ortho

```

### Plotting for cellchat
```{r cellchat_plots}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

    object_list[[group]] <- cellchat

    # 8. visualize the aggregated cell-cell communication network
    groupSize <- as.numeric(table(cellchat@idents))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
        dir.create(str_c("output/figures/cellchat/", group),
                    recursive = TRUE)
    }
    p1 <- netVisual_circle(cellchat@net$count,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Number of interactions")
    p2 <- netVisual_circle(cellchat@net$weight,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Interaction weights/strength")
    combined_plot <- 
        plot_grid(p1, p2, ncol = 1) +
        patchwork::plot_annotation(title = stringr::str_c(group," everything "))
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.pdf"),
        combined_plot,
        width = 15,
        height = 30
    )
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.png"),
        combined_plot,
        width = 15,
        height = 30
    )
    #  examine the signaling sent from each cell group
    mat <- cellchat@net$weight
    plot_list1 <- list()
    for (i in 1:nrow(mat)) {
        mat2 <- 
            matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
        mat2[i, ] <- mat[i, ]
        plot_list1[[i]] <-
            netVisual_circle(mat2, 
                                vertex.weight = groupSize,
                                weight.scale = F, 
                            edge.weight.max = max(mat),
                            title.name = rownames(mat)[i]) 
    }
    combined_plot1 <- 
        plot_grid(plotlist = plot_list1, ncol = 3) +
        patchwork::plot_annotation(title = stringr::str_c(group," ", subset_db))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "outgoing_signaling.png"),
        combined_plot1,
        width = 21,
        height = 7 * length(plot_list1)/3
    )

    future::plan("multisession", workers = 10) # do parallel
    # 9. Identify the signaling roles of cell
    cellchat@netP[["pathways"]]
    # rank the pathways 
    ranked_pathways <-
        rankNet(cellchat, mode="single")
    ggsave(str_c("output/figures/cellchat/", group, "/everything_ranked_pathways.png"),
        ranked_pathways,
        width = 10,
        height = 15
    )
    # reveal all the ligand-receptor pairs for a signaling pathway
    extractEnrichedLR(cellchat, signaling = c(cellchat@netP[["pathways"]]),
                    geneLR.return = TRUE)

    # visualize the contribution of each LR pairs to the communication network
    netAnalysis_contribution(cellchat, 
                            signaling = c(cellchat@netP[["pathways"]]), 
                            title = "Contribution of each LR pairs")
    # visualize the contribution of each LR pairs to the communication network top5
    top5_ligand_receptor_pairs <-
        netAnalysis_contribution(cellchat, 
                                signaling = c(cellchat@netP[["pathways"]][1]))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "top5_ligand_receptor_pairs.png"),
        top5_ligand_receptor_pairs,
        width = 10,
        height = 15
    )
    # 10. Visualize cell-cell communication mediated by specific signaling pathways
    extractEnrichedLR(cellchat, signaling = "COLLAGEN", geneLR.return = FALSE)
    netAnalysis_contribution(cellchat, signaling = "COLLAGEN")

    # Circle plot
    netVisual_aggregate(cellchat, signaling = "COLLAGEN", layout = "circle")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1")

    # Arrange so that tumor are on one side in the chord diagram
    # Define group.cellType so that tumor cell types are grouped together
    # Example: assign "Tumor" to tumor clusters, others as before
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive", "Stressed")
    other_clusters <- setdiff(levels(cellchat@idents), tumor_clusters)

    group.cellType <- c(
        rep("Tumor", length(tumor_clusters)),
        rep("Other", length(other_clusters)))
    names(group.cellType) <- c(tumor_clusters, other_clusters)

    chord_plot <-
        netVisual_chord_cell(cellchat, signaling = "COLLAGEN", 
            group = group.cellType, 
            title.name = paste0("COLLAGEN_", "signaling network"))

    # Chord diagram: define source and target cell types
    netVisual_chord_gene(cellchat, sources.use = 4, targets.use = c(5:6), 
                        lab.cex = 0.5,legend.pos.y = 30)

    netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4), targets.use = 8,
                        lab.cex = 0.5, legend.pos.x = 15)

    # Chord diagram: show LR pairs associated with certain signaling pathways
    netVisual_chord_gene(cellchat,
                         sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c("TAMs"),
                        signaling = c("COLLAGEN"),legend.pos.x = 8)

    # Hierarchy plot 
    # Define tumor clusters as vertex.receiver for hierarchy plot
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive")
    vertex.receiver <- which(levels(cellchat@idents) %in% tumor_clusters)

    netVisual_aggregate(cellchat, signaling = "COLLAGEN", 
                        vertex.receiver = vertex.receiver, layout = "hierarchy")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1", 
                        vertex.receiver = vertex.receiver, 
                        layout = "hierarchy")

    # Heatmap for sender receiver pairs for a specific signaling pathway
    netVisual_heatmap(cellchat, signaling = "COLLAGEN", color.heatmap = "Reds")

    # bubble plot 
    # bubble plot: show all LR pairs from source to target cell groups
    netVisual_bubble(cellchat, sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c(1:10), 
                    remove.isolate = FALSE) 

    # bubble plot: show LR pairs associated with certain signaling pathways
    netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:12), 
                    signaling = c("COLLAGEN"), remove.isolate = FALSE)
                
    # 1. Compute the network centrality scores
    cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP")

    # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- netAnalysis_signalingRole_scatter(cellchat) + coord_fixed()
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_aggregated_network.png"),
        aggregated_network,
        width = 7,
        height = 7
    )

    # Scatter plot to Visualize selected communication networks
    netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    # Heatmap to visualize dominant cell types for each signaling pathway
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing", height = 11)
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming", height = 11)

    # Visualize selected outgoing/incoming signals and contributing cell types
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing",
                                        signaling = c("COLLAGEN"))
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming",
                                        signaling = c("COLLAGEN"))

    # Heatmap to visualize major signaling roles of different cell groups
    netAnalysis_signalingRole_network(cellchat, signaling = "FN1", width = 10, 
                                    height = 5, font.size = 10)

    # 2. Identify global communication patterns to explore how multiple cell types 
    # and signaling pathways coordinate
    # Identify and visualize outgoing communication pattern of secreting cells
    selectK(cellchat, pattern = "outgoing") # infer the number of patterns, NMF
    nPatterns = 4 # a suitable number of patterns is the one begin to drop suddenly.
    cellchat <- identifyCommunicationPatterns(cellchat, pattern = "outgoing",
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "outgoing") # river plot
    netAnalysis_dot(cellchat, pattern = "outgoing") # dot plot

    ## Identify and visualize incoming communication pattern of target cells
    selectK(cellchat, pattern = "incoming")
    nPatterns = 4
    cellchat <- identifyCommunicationPatterns(cellchat,pattern = "incoming", 
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "incoming") # river plot
    netAnalysis_dot(cellchat, pattern = "incoming") # dot plot

    # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)

    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "functional", nCol = 2)

    # Identify signaling groups based on structure similarity
    # multimeric ligand-receptor complexes, soluble agonists and antagonists, 
    # stimulatory and inhibitory co-ligands and co-receptors
    cellchat <- computeNetSimilarity(cellchat, type = "structural")
    cellchat <- netEmbedding(cellchat, type = "structural")
    cellchat <- netClustering(cellchat, type = "structural",do.parallel = FALSE)

    # Visualization in 2D-space
    structural_gene_groups <-
        netVisual_embedding(cellchat, type = "structural", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_structural_gene_groups.png"),
        structural_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "structural", nCol = 2)
}



object_list <- list()
collagen_bubble <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

     # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- 
        netAnalysis_signalingRole_scatter(cellchat) +
        coord_fixed() +
        ggtitle(str_c(group," aggregated network"))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
    dir.create(str_c("output/figures/cellchat/", group),
                recursive = TRUE)
    }
    ggsave(str_c("output/figures/cellchat/", group, "/", "ann2_aggregated_network.png"),
        aggregated_network,
        width = 10,
        height = 10)

    # Visualize selected outgoing/incoming signals and contributing cell types
        # Scatter plot to Visualize selected communication networks
    collagen_bubble[[group]] <-
        netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    ggsave(str_c("output/figures/cellchat/", group, "/", "collagen_bubble.png"),
        collagen_bubble[[group]],
        width = 10,
        height = 10)
    
     # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)
    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5) +
        ggtitle(str_c(group," functional gene groups"))
    ggsave(str_c("output/figures/cellchat/", group, "/", "functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )

    png(filename = str_c("output/figures/cellchat/", group, "/", "collagen_network_heatmap.png"),
        width = 1000, height = 500, res = 300)
    netAnalysis_signalingRole_network(cellchat, signaling = "COLLAGEN", width = 10, height = 5, font.size = 10)

    dev.off()
}

```


## comparative cellchat analysis
```{r cellchat_comparative analysis}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))
    
    # qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs")) 

    object_list[[group]] <- cellchat
            }

# rank the pathways and compare across groups
rankNet(object_list$mm_metshuman_ortho, mode="single")
rankNet(mergeCellChat(list(object_list$patient_prim,
                            object_list$mm_primhuman_ortho),
        add.names=c("patient","xeno")),
        mode="comparison",
        stacked = TRUE)
rankNet(mergeCellChat(list(object_list$mm_primhuman_ortho,
                            object_list$mm_metshuman_ortho),
        add.names=c("patient","xeno", "dog")),
        mode="comparison",
        stacked = FALSE)

get_pathway_flow <- function(cc,
                             dataset_name) {
    flows <- 
        apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE))
    data.frame(pathway = names(flows),
            information_flow = as.numeric(flows),
            dataset = dataset_name,
            stringsAsFactors = FALSE)
}

# Collect all datasets and perform PCA for each dataset
df_list <- 
    Map(get_pathway_flow, object_list,
    names(object_list))
df_all <-
    do.call(rbind, df_list) %>%
    as_tibble() %>%
    as.data.frame()
# Pivot to wide format: rows = pathway, columns = dataset, values = information_flow
df_wide <- df_all %>%
    select(pathway, dataset, information_flow) %>%
    tidyr::pivot_wider(names_from = dataset,
                        values_from = information_flow,
                        values_fill = 0)
# Set rownames to pathway and remove pathway column
mat_t <- 
    as.data.frame(df_wide) %>%
    column_to_rownames("pathway") %>%
    t()

# Scale and run PCA
pca_res <- prcomp(mat_t, scale. = TRUE)

# PCA plot: one dot per group (dataset)
pca_df <- as.data.frame(pca_res$x)
pca_df$group <- rownames(pca_df)

library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, label = group)) +
    geom_point(size = 3) +
    geom_text(vjust = -0.5, size = 3) +
    labs(title = "PCA of Pathway Information Flow (one dot per group)",
            x = "PC1", y = "PC2") +
    theme_minimal()

# the pathways that drive the differences between groups
loading_scores_df <-
    pca_res$rotation %>%
    as.data.frame() %>%
    rownames_to_column("pathway")



# Function to compare pathways between two CellChat objects (e.g. primary vs. mets)
compare_pathways <- function(cc_primary,
                            cc_mets) {
                        
    info_primary <- 
        cc_primary@netP$pathways %>% 
        data.frame(pathway = .,
                flow = apply(cc_primary@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    info_mets <- 
        cc_mets@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc_mets@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))

    merged <- 
        merge(info_primary, info_mets, by="pathway", suffixes = c("_prim", "_mets"))
    merged$diff_mets_up <- merged$flow_mets - merged$flow_prim
    merged$diff_prim_up <- merged$flow_prim - merged$flow_mets

    merged
}

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    patient_diff <-
        compare_pathways(cc_primary = object_list[[group_prim]],
                        cc_mets = object_list[[group_mets]])

    # Sort and visualize
    # Top 10 pathways enriched in mets (mets > primary)
    top_diff_mets_up <-
        head(patient_diff[order(-patient_diff$diff_mets_up), ], 10)

    # Top 10 pathways enriched in primary (primary > mets)
    top_diff_prim_up <-
        head(patient_diff[order(-patient_diff$diff_prim_up), ], 10)

    # Barplot of top pathways enriched in mets (mets > primary)
    top_diff_mets_up$group <- "Metastasis"
    # Barplot of top pathways enriched in primary (primary > mets)
    top_diff_prim_up$group <- "Primary"

    # Combine top pathways for plotting
    top_diff_combined <- rbind(
        top_diff_mets_up %>% dplyr::select(pathway, flow_mets, flow_prim, group),
        top_diff_prim_up %>% dplyr::select(pathway,  flow_mets, flow_prim, group))

    # Reshape to long format for ggplot
    top_diff_long <-
        top_diff_combined %>%
        tidyr::pivot_longer(cols = c(flow_prim, flow_mets),
                            names_to = "condition",
                            values_to = "information_flow") %>%
        mutate(condition = ifelse(condition == "flow_prim", "Primary", "Metastasis")) %>%
        arrange(desc(group), information_flow) %>%
        mutate(pathway = factor(pathway, levels = unique(pathway)))

    ggplot(top_diff_long,
                    aes(x = information_flow, y = pathway,
                            fill = condition)) +
        geom_bar(stat = "identity", position = "dodge") +
        labs(title = "Top 10 Differential Pathways: Metastasis vs. Primary",
                x = "Information Flow", y = "Pathway") +
        scale_fill_manual(values = c("Metastasis" = "#E41A1C", "Primary" = "#377EB8")) +
        theme_minimal()

    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "_top_diff_pathways.png"),
        width = 10,
        height = 10,
        bg = "white"
    )
}



# look at top five pathways for everything
pathways_list <- list()

for (item in names(object_list)) {
    cc <- object_list[[item]]
    top_pathways <-
        cc@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    top5 <-
        head(top_pathways[order(-top_pathways$flow), ], 5) %>%
        mutate(group = item)

    pathways_list[[item]] <- top5
}

pathwys_df <-
    do.call(rbind, pathways_list) %>%
    as_tibble() %>%
    as.data.frame()

# Define plot_cols as a named vector, e.g.:
# plot_cols <- c("patient_prim"="#1f77b4", "patient_mets"="#ff7f0e", ...)
top5_all <-
    ggplot(pathwys_df,
    aes(x = flow, y = pathway, fill = group)) +
    geom_bar(stat = "identity",position = position_dodge(preserve = "single", width = 0.8), width = 0.7) +
    labs(title = "Top 5 Pathways per Group",
        x = "Information Flow", y = "Pathway") +
    scale_fill_manual(values = plot_cols) +
    theme_minimal()

ggsave("output/figures/cellchat/top5_pathways_all.png",
    top5_all,
    width = 10,
    height = 10,
    bg = "white"
)


### merge by cellchat function testing if the net number and weight of interaciton change by merging
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    object_list_sub <-
        list(object_list[[group_prim]],
             object_list[[group_mets]]) %>%
        setNames(c(group_prim, group_mets))
    cellchat <-
        mergeCellChat(object.list = object_list_sub,
                      add.names = names(object_list_sub),
                      merge.data = FALSE,
                      cell.prefix = FALSE)

    # comapre fropm merged
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "count")
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "weight")

    # 2. Compare the total number of interactions and interaction strength
    # Calculate total number of interactions for each group
    interaction_sums <- 
        sapply(object_list_sub, function(x) sum(x@net$count))
    interaction_sum_df <- 
        data.frame(
        group = names(interaction_sums),
        total_interactions = as.numeric(interaction_sums))

    # Barplot individually
    library(ggplot2)
    interaction_df$group <-
        factor(interaction_df$group,
                levels = c("patient_prim", setdiff(interaction_df$group, "patient_prim")))
    ggplot(interaction_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Number of Interactions per Group",
             x = "Group", y = "Total Interactions") +
        theme_minimal() +
        theme(legend.position = "none")
    
    # weight     
    interaction_weight <- 
        sapply(object_list_sub, function(x) sum(x@net$weight))
    interaction_weight_df <- 
        data.frame(
        group = names(interaction_weight),
        total_interactions = as.numeric(interaction_weight))
    interaction_weight_df$group <-
        factor(interaction_weight_df$group,
                levels = c("patient_prim", setdiff(interaction_weight_df$group, "patient_prim")))
    ggplot(interaction_weight_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Interaction Weights per Group",
             x = "Group", y = "Total Interaction Weights") +
        theme_minimal() +
        theme(legend.position = "none")

}


# merge everything
merged_all <-
    mergeCellChat(object.list = object_list,
                  add.names = names(object_list),
                  cell.prefix = TRUE)
# compare the total number of interactions and interaction strength
gg1<-
    compareInteractions(merged_all, show.legend = F, group = c(1:8)) +
        theme(axis.text.x = element_blank())
gg2 <-
    compareInteractions(merged_all, show.legend = F, group = c(1:8), measure = "weight") +
     theme(axis.text.x = element_text(angle = 45, hjust = 1))

combined <-
    patchwork::wrap_plots(gg1 + xlab(NULL), gg2, ncol = 1)

ggsave("output/figures/cellchat/merged_everything_compare_interactions.png",
    combined,
    width = 10,
    height = 10
)

```


### multi sample by sample per group
```{r multi_sample_cellchat_analysis}

average_pathways_allgenes <- list()
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "netP") %>%
            arrange(desc(prob))

        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% receiver_cells) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    #mean filter for probabilities
    mean_filter <- mean(pathways_LR_df$prob)

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        select(sample, pathway_name, prob) %>%
        group_by(pathway_name) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group)
    
    average_pathways_allgenes[[group]] <- pathway_average

    # Perform PCA on the pathways
    pca_input <- 
        pathways_LR_df %>%
        filter(str_starts(sample, "CCDI")) %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        column_to_rownames("sample_group")
    
    # make a heatmap
    heatmap_matrix <-
        pathways_LR_df %>%
        filter(str_starts(sample, "CCDI")) %>%
        filter(!pathway_name %in% c("COLLAGEN", "FN1", "LAMININ")) %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        { 
            mat <- .
            cols_to_keep <- names(mat)[-1][colSums(mat[,-1, drop=FALSE]) > mean_filter]
            mat <- mat[, c("sample_group", cols_to_keep), drop=FALSE]
            mat
        } %>%
        column_to_rownames("sample_group")

    # plot heatmap
    heatmap <-
        pheatmap::pheatmap(
            heatmap_matrix,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
            main = stringr::str_c("Pathway Probabilities Heatmap ", group),
            fontsize_row = 8,
            fontsize_col = 8
        )

    # Run PCA
    pca_res <- prcomp(pca_input, scale. = TRUE)
    # PCA plot: one dot per sample
    pca_df <- as.data.frame(pca_res$x)
    pca_df$sample <- rownames(pca_df) %>% sub("_.*", "", .) 
    pca_df$group <- sapply(strsplit(rownames(pca_df), "-"), `[`, 2)

    # K-means clustering (choose k=2 for example, adjust as needed)
    set.seed(123)
    k <- 3
    km_res <- kmeans(pca_df[, c("PC1", "PC2")], centers = k)
    pca_df$cluster <- as.factor(km_res$cluster)

    # Plot PCA with clusters
    ggplot(pca_df, aes(x = PC1, y = PC2, label = sample, color = cluster, shape = group)) +
        geom_point(size = 3) +
        geom_text(vjust = -0.5, size = 3) +
        labs(title = stringr::str_c(group, " PCA of Pathway Probabilities with Clustering"),
             x = "PC1", y = "PC2") +
        theme_minimal()

}
## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df_allgenes <-
    do.call(rbind, average_pathways_allgenes)
prob_filter <- mean(average_pathways_df_allgenes$mean_prob)
heatmap_matrix_allgenes <-
    average_pathways_df_allgenes %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    filter(rowSums(across(-pathway_name)) > prob_filter) %>%
    column_to_rownames("pathway_name") %>%
    select(patient_prim, patient_mets, mm_primhuman_ortho, mm_metshuman_ortho,
           xeno_prim_cancer_normal, xeno_mets_cancer_normal,
           dogs_primhuman_ortho, dogs_metshuman_ortho) %>%
    arrange(desc(patient_mets))
# Plot heatmap: group on x-axis, pathway on y-axis
heatmap_allgenes <-
    pheatmap::pheatmap(
        heatmap_matrix_allgenes,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix_allgenes, 2)
)
ggsave("output/figures/cellchat/aallgenes_average_pathway_heatmap_across_all.png",
    heatmap_allgenes,
    width = 10,
    height = 20,
    bg = "white"
)
```






```{r multi_sample_cellchat_analysis_sharedgenes_analysis}

average_pathways <- list()
module_pathways_list <- list()
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob)) 
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(source,target, pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    
    #mean filter for probabilities
    mean_filter <- mean(pathways_LR_df$prob)

    # plot heatmap of top interactions by group
    pathway_average <-
        pathways_LR_df %>%
        select(sample, pathway_name, prob) %>%
        group_by(pathway_name) %>%
        summarise(mean_prob = mean(prob)) %>%
        arrange(desc(mean_prob)) %>%
        mutate(group = group)
    
    average_pathways[[group]] <- pathway_average

}

## compare prim vs mets
# make a heatmap from the average pathways
average_pathways_df <-
    do.call(rbind, average_pathways)

heatmap_matrix <-
    average_pathways_df %>%
    pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
    column_to_rownames("pathway_name") %>% 
    select(patient_prim, patient_mets, mm_primhuman_ortho, mm_metshuman_ortho,
           xeno_prim_cancer_normal, xeno_mets_cancer_normal,
           dogs_primhuman_ortho, dogs_metshuman_ortho) %>%
    arrange(desc(patient_mets))
# Plot heatmap: group on x-axis, pathway on y-axis
heatmap<-
    pheatmap::pheatmap(
        heatmap_matrix,
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        silent = TRUE,
        color = colorRampPalette(c("white", "#fd5252ff","#fd3c3cff","#fc1717ff", "#ff0000ff"))(100),
        main = "Average Pathway Mean Probability Across All)",
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(heatmap_matrix, 2)
)
ggsave("output/figures/cellchat/sharedgenes_average_pathway_heatmap_across_all.png",
    heatmap,
    width = 10,
    height = 20,
    bg = "white"
)


# plots
for (site in c("prim", "mets")) {
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        column_to_rownames("pathway_name")

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()  
    heatmap_df <-
        site_specific %>%
        filter(rowSums(across(everything())) > mean_filter) %>%
        as.matrix()
    # Plot heatmap: group on x-axis, pathway on y-axis
    heatmap_per_site<-
        pheatmap::pheatmap(
            heatmap_df,
            cluster_rows = TRUE,
            cluster_cols = TRUE,
            silent = TRUE,
            color = colorRampPalette(c("white", "#ff6b6bff","#ff4a4aff","#ff2424ff", "#ff0e0eff"))(100),
            main = "Pathway Mean Probability (Shared Genes)",
            fontsize_row = 8,
            fontsize_col = 10,
            display_numbers = round(heatmap_df, 2)
        )
    ggsave(str_c("output/figures/cellchat/sharedgenes_", site, "_average_pathway_heatmap.png"),
        heatmap_per_site,
        width = 4,
        height = length(colnames(heatmap_df)) * 0.5 + 4,
        bg = "white"
    )

    # plot correlation heatmap
    # Correlation matrix heatmap (already present)
    cor_matrix <-
        cor(site_specific, use = "pairwise.complete.obs")
    pheatmap::pheatmap(
        cor_matrix,
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        color = colorRampPalette(c("#ffe0e0ff", "#fd3f3fff"))(100),
        main = str_c("Correlation Heatmap of Pathways - ", site, " Site"),
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(cor_matrix, 2),
        number_color = "black"
    )  # Alternative visualization: correlation network graph
    library(igraph)
    library(ggraph)
    # Convert correlation matrix to long format for graph
    cor_long <-
        as.data.frame(as.table(cor_matrix))
    colnames(cor_long) <- c("Var1", "Var2", "Correlation")
    cor_long <- cor_long %>% filter(Var1 != Var2 & abs(Correlation) > 0.7)

    # Create igraph object
    g <- graph_from_data_frame(cor_long, directed = FALSE)

    # Plot correlation network
    ggraph(g, layout = "fr") +
        geom_edge_link(aes(edge_alpha = abs(Correlation), edge_width = abs(Correlation), color = Correlation > 0), show.legend = TRUE) +
        geom_node_point(size = 5) +
        geom_node_text(aes(label = name), repel = TRUE) +
        scale_edge_color_manual(values = c("TRUE" = "red", "FALSE" = "blue")) +
        labs(title = str_c("Pathway Correlation Network - ", site, " Site")) +
        theme_void()

    # Alternative: pairwise scatterplots
    site_specific_GGPAIRS <-
        site_specific %>%
        rownames_to_column("pathways") %>%
        filter(pathways != "COLLAGEN") %>%
        column_to_rownames("pathways")
    library(GGally)
    GGally::ggpairs(
        site_specific_GGPAIRS,
        lower = list(continuous = wrap("points", alpha = 0.5)),
        upper = list(continuous = wrap("cor", size = 3)),
        diag = list(continuous = wrap("barDiag", fill = "lightblue")),
        title = str_c("Pairwise Pathway Correlations - ", site, " Site"),
        axisLabels = "show"
    )
}
# Fidelity by modules like ECM (compact spacing)
pathway_groups <- list(
    ECM = c("COLLAGEN","LAMININ","FN1","THBS","TENASCIN","AGRN","VWF",
            "ANNEXIN","GAP","PCDH","PTN"),
    Angiogenesis = c("VEGF","PDGF","ANGPT","ANGPTL","FGF","EDN","VWF",
                    "PECAM1","HGF","KIT"),
    ImmuneEvasion = c("MHC-II","CXCL","CCL","TNF","IL1","IL2","IL6",
                    "IL16","OSM","CSF","CD45","CD39",   "CD80","CD86",
                    "ICOS","APRIL","BAFF","CD30","TWEAK","RANKL","CX3C","CysLTs"),
    CellAdhesion = c("CADM","NCAM","PTPRM","CDH","CDH1","CDH5","ICAM",
                    "JAM","SELL","NECTIN","OCLN","CLDN","SEMA3","SEMA5",
                    "SEMA6","Netrin","UNC5","EPHB","EPHA","NRXN"),
    GrowthFactor = c("TGFb","BMP","IGF","NOTCH","WNT","ncWNT","GDF",
                    "RA","HGF","NRG"),
    Metabolic = c("Cholesterol","Desmosterol","DHEA","Estradiol",
                    "Prostaglandin","ENHO","RBP4","CALCR"),
    Other = c("APP","ADGRL","ADGRG","ADGRB","NEGR","FLRT","MPZ",
                "SEMA3","SEMA5","SEMA6","CysLTs")
)


# plots
site_specific_paths <- list()
for (site in c("prim", "mets")) {
    patient_site_name <-
        ifelse(site == "prim", "patient_prim", "patient_mets")
    site_specific <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0) %>%
        filter(.data[[patient_site_name]] > 0) %>% 
        column_to_rownames("pathway_name") %>%
        mutate(row_sum = rowSums(across(everything()))) %>%
        arrange(desc(row_sum)) %>%
        select(-row_sum) %>%
        slice_head(n=40)

    # heatmap as a whole
    mean_filter <-
        average_pathways_df %>%
        filter(str_detect(group, site)) %>%
        pull(mean_prob) %>%
        mean()
    pathway_scores <-
        site_specific %>%
        # filter(rowSums(across(everything())) > mean_filter) %>%
        as.data.frame() %>%
        rownames_to_column("Pathway") %>%
        rename_with(~ ifelse(str_detect(.x, "dog"), "Dog",
                        ifelse(str_detect(.x, "mm"), "Mouse",
                        ifelse(str_detect(.x, "xeno"), "PDX",
                        ifelse(str_detect(.x, "patient"), "Human", .x)))), .cols = everything()) #%>% 
        # filter(Pathway %in% unlist(pathway_groups))

    site_specific_paths[[site]] <- pathway_scores
    
    aggregate_module <- function(scores_df, groups){
        long <- scores_df %>%
            pivot_longer(-Pathway, names_to="Dataset", values_to="Score") %>%
            mutate(Group = sapply(Pathway, function(p) {
            g <- names(groups)[sapply(groups, function(v) p %in% v)]
            if(length(g)) g[1] else "Other"
            }))
        
        module_summary <- long %>%
            group_by(Group, Dataset) %>%
            summarise(MeanScore = mean(Score, na.rm=TRUE), .groups="drop")
        
        return(module_summary)
    }

    module_summary <- aggregate_module(pathway_scores, pathway_groups)

    # Spread to wide for correlations
    module_wide <- module_summary %>%
    pivot_wider(names_from=Dataset, values_from=MeanScore)

    # Spearman correlation of module patterns
    cor_dog   <- cor(module_wide$Human, module_wide$Dog, method="spearman")
    cor_mouse <- cor(module_wide$Human, module_wide$Mouse, method="spearman")
    cor_pdx   <- cor(module_wide$Human, module_wide$PDX, method="spearman")

    # plot
    ggplot(module_summary, aes(x=Group, y=MeanScore, fill=factor(Dataset, levels=c("Human", "Dog", "PDX", "Mouse")))) +
        geom_bar(stat="identity", position="dodge") +
        scale_fill_manual(
            values = c(
                Human = "#D43F3AFF",
                Dog = "#EEA236FF",
                PDX = "#357EBDFF",
                Mouse = "#5CB85CFF"
            ),
            guide = guide_legend(title = NULL)
        ) +
        theme_minimal(base_size=14) +
        ylab("Mean pathway score (aggregated)") +
        xlab("Functional Module") +
        ggtitle("Module-level pathway fidelity across species") +
        theme(
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            axis.line.x = element_line(),
            axis.line.y = element_line()
        )
    }

```

## Statistical comparison for all primary across 
```{r statistical_comparison_pathways_primary_mets}
# > site_specific_paths$prim$Pathway
#  [1] "COLLAGEN"    "LAMININ"     "FN1"         "APP"         "MK"         
#  [6] "SLIT"        "THBS"        "CADM"        "NCAM"        "PTPRM"      
# [11] "TGFb"        "ADGRL"       "PDGF"        "VEGF"        "MPZ"        
# [16] "FLRT"        "PTN"         "Cholesterol" "TENASCIN"    "CDH"        
# [21] "MHC-II"      "UNC5"        "NRXN"        "CXCL"        "NRG"        
# [26] "EPHA"        "Glutamate"   "CCL"        
# > site_specific_paths$mets$Pathway
#  [1] "COLLAGEN"    "LAMININ"     "SLIT"        "FN1"         "ADGRL"      
#  [6] "CADM"        "NCAM"        "PTPRM"       "APP"         "VEGF"       
# [11] "THBS"        "Glutamate"   "UNC5"        "PDGF"        "CDH"        
# [16] "EPHA"        "TGFb"        "FLRT"        "MPZ"         "MK"         
# [21] "Cholesterol" "PTN"         "SEMA3"       "PECAM1"      "TENASCIN"   
# [26] "BMP"         "ADGRG"       "ICAM"        "CCL"         "ANNEXIN"    

average_pathways <- list()
tumor_sub <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")
# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "netP") %>%
            arrange(desc(prob))
        
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            # filter(!source %in% tumor_sub) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    average_pathways[[group]] <- pathways_LR_df
}

# perform stats
ttest_results <- list()
comparisons <- list(
    c("patient_prim", "xeno_prim_cancer_normal"),
    c("patient_prim", "dogs_primhuman_ortho"),
    c("patient_prim", "mm_primhuman_ortho"),
    c("patient_mets", "xeno_mets_cancer_normal"),
    c("patient_mets", "dogs_metshuman_ortho"),
    c("patient_mets", "mm_metshuman_ortho")
)


for (comp in comparisons) {
    group1 <- comp[1]
    group2 <- comp[2]

    data_sub <- 
        do.call(rbind, list(average_pathways[[group1]], average_pathways[[group2]])) %>%
        as_tibble() %>%
        as.data.frame()

    # fill up the missing pathways with 0 prob for each sample
    human_vs_another <-
        data_sub %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the total number of samples in each group
    total_number_human <- 
        n_distinct(human_vs_another$sample[human_vs_another$group == group1])
    total_number_another <- 
        n_distinct(human_vs_another$sample[human_vs_another$group == group2]) 
    
    # will use human average to calculate the fold change
    mean_per_pathway_in_human <-
        data_sub %>%
        filter(group == group1) %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob_human = sum(prob)/total_number_human) %>%  
        arrange(desc(mean_prob_human))

    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        human_vs_another %>%
        #filter(pathway_name %in% mean_per_pathway_in_human$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway_in_human, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob_human) %>%
        select(sample, group, pathway_name, prob, mean_prob_human, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    # choose top pathways based on primary
    if (str_detect(group1, "prim")) {
        chosen_pathways <- site_specific_paths$prim$Pathway
    } else {
        chosen_pathways <- site_specific_paths$mets$Pathway
    }

    plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% chosen_pathways) %>%
            mutate(group = case_when(
                str_detect(group, "patient") ~ "Human",
                str_detect(group, "dogs") ~ "Dog",
                str_detect(group, "xeno") ~ "PDX",
                str_detect(group, "mm") ~ "Mouse",
                TRUE ~ group
            ))
    plot_pathways$site <-
        ifelse(str_detect(group1, "prim"), "Primary", "Metastatic")
 
    ttest_results[[str_c(group1, "_vs_", group2)]] <- plot_pathways
}


# with 50 pathways, we can group them into functional modules
prim_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH",
                            "PECAM1", "ICAM", "SELL", "JAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "ANGPT"),
    Immune_Signalling = c("CXCL", "CCL", "IL1", "MHC-II"),
    Stemness          = c("BMP", "RA", "NRG"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate")
) %>%
unlist() %>%
unique()

# Metastatic
mets_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH", "PECAM1", "ICAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "FGF", "ANGPT"),
    Immune_Signalling = c("CXCL", "CCL", "IL1", "TNF", "CD80"),
    Stemness          = c("BMP", "RA"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate", "DHEA")
)%>%
unlist() %>%
unique()

# now plot the results all together side by side for each pathway, for each site (Primary and Metastatic)
for (site in c("Primary", "Metastatic")) {
    ttest_results_df_site <-
        do.call(rbind, ttest_results) %>%
        as_tibble() %>%
        as.data.frame() %>%
        filter(site == !!site) %>%
        mutate(comparison = case_when(
            str_detect(group, "PDX") ~ "Human vs PDX",
            str_detect(group, "Dog") ~ "Human vs Dog",
            str_detect(group, "Mouse") ~ "Human vs Mouse"
        )) %>%
        mutate(significance = case_when(
            padj < 0.001 ~ "***",
            padj < 0.05 ~ "**",
            padj < 0.1 ~ "*",
            TRUE ~ "ns"
        ))

    ttest_results_df_site$group <- factor(ttest_results_df_site$group,
        levels = c("Human", "Dog", "PDX", "Mouse"))
    ttest_results_df_site$comparison <- factor(ttest_results_df_site$comparison,
        levels = c("Human vs Dog", "Human vs PDX", "Human vs Mouse"))

    # Split pathways into two halves
    if (site == "Primary") {
        pathway_modules <- prim_modules
    } else {
        pathway_modules <- mets_modules
    }
    half_n <- ceiling(length(pathway_modules) / 2)
    pathways1 <- pathway_modules[1:half_n]
    pathways2 <- pathway_modules[(half_n + 1):length(pathway_modules)]

    plot1 <-
        ggplot(
            ttest_results_df_site %>%
                filter(group != "Human", pathway_name %in% pathways1) %>%
                mutate(pathway_name = factor(pathway_name, levels = pathways1)),
            aes(x = pathway_name, y = log10(norm_prob + 0.0001), fill = group)
        ) +
            geom_boxplot(outlier.shape = NA, width = 0.6, position = position_dodge(width = 0.8)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            scale_color_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            theme_minimal(base_size = 14) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            labs(
                title = str_c("Pathway Probability Comparison Across Species (", site, ", Excluding Human)"),
                x = "Pathway", y = "Normalized Probability log10"
            ) +
            geom_text(
                data = ttest_results_df_site %>%
                    filter(group != "Human", pathway_name %in% pathways1) %>%
                    mutate(pathway_name = factor(pathway_name, levels = pathways1)) %>%
                    group_by(pathway_name, group, comparison) %>%
                    summarise(
                        y_pos = min(max(log10(norm_prob + 0.0001), na.rm = TRUE) + 0.1, 22),
                        significance = first(significance),
                        .groups = "drop"
                    ),
                aes(x = pathway_name, y = y_pos, label = significance, group = group),
                inherit.aes = FALSE,
                position = position_dodge(width = 0.8),
                vjust = 0,
                fontface = "bold",
                size = 3
            )

    plot2 <-
        ggplot(
            ttest_results_df_site %>%
                filter(group != "Human", pathway_name %in% pathways2) %>%
                mutate(pathway_name = factor(pathway_name, levels = pathways2)),
            aes(x = pathway_name, y = log10(norm_prob + 0.0001), fill = group)
        ) +
            geom_boxplot(outlier.shape = NA, width = 0.6, position = position_dodge(width = 0.8)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            scale_color_manual(values = c("Dog" = "#EEA236FF", "PDX" = "#D43F3AFF", "Mouse" = "#5CB85CFF")) +
            theme_minimal(base_size = 14) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            labs(
                title = NULL,
                x = "Pathway", y = "Normalized Probability log10"
            ) +
            geom_text(
                data = ttest_results_df_site %>%
                    filter(group != "Human", pathway_name %in% pathways2) %>%
                    mutate(pathway_name = factor(pathway_name, levels = pathways2)) %>%
                    group_by(pathway_name, group, comparison) %>%
                    summarise(
                        y_pos = min(max(log10(norm_prob + 0.0001), na.rm = TRUE) + 0.1, 22),
                        significance = first(significance),
                        .groups = "drop"
                    ),
                aes(x = pathway_name, y = y_pos, label = significance, group = group),
                inherit.aes = FALSE,
                position = position_dodge(width = 0.8),
                vjust = 0,
                fontface = "bold",
                size = 3
            )

    combined_plot <- plot1 / plot2 + plot_layout(heights = c(1, 1))

    ggsave(str_c("output/figures/cellchat/statistical_comparison_pathways_", site, "_across_species.png"),
        combined_plot,
        width = 20,
        height = 10,
        bg = "white"
    )
}


```








## Dig Deepeer into the pathways that are interesting
```{r dig_deeper_pathways}

interesting_pathways <- c(
                    #"TGFb", 
                    "FN1"
                    # "LAMININ", "VEGF", "CXCL",
                    # "IL1",
                    # "CCL",
                    # "THBS",
                    # "CADM",
                    # "APP",
                    # "SLIT",
                    # "NCAM"
                    )
average_pathways <- list()
interaction_names <- list()
# load the objects
for (group in c(
                #"patient_prim",
                "patient_mets",
                #"xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                #"dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                #"mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        pathways_present <- 
            intersect(interesting_pathways, unique(cellchat@netP$pathways))
        if (length(pathways_present) > 0) {
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                    signaling = pathways_present,
                                    slot.name = "net") %>%
                arrange(desc(prob))

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                select(pathway_name, prob, source, target, interaction_name)
        } else {
            message(str_c("No interesting pathways found in ", sample_name, " of group ", group))
        }
    }
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame()

    pathways_present_all <- 
        unique(pathways_LR_df$pathway_name)
    # help me plot this using ggplot2 source in y axis target in x axis for each intersaction name
    for (pathway in pathways_present_all) {
        pathway_df <-
            pathways_LR_df %>%
            filter(pathway_name == pathway) %>%
            arrange(desc(prob))
    
        # plot fr each pathway for each group
        pathway_df_plot <-
            pathway_df %>%
            group_by(source, target) %>%
            summarise(
                prob = sum(prob, na.rm = TRUE),
                count = n(),
                .groups = "drop"
            )
        # overall plot for the pathway
        plot_path <-
            ggplot(pathway_df_plot, aes(x = target, y = source, size = count, color = prob)) +
                geom_point(alpha = 0.7) +
                scale_color_gradientn(colours = c("#fcf4f4ff", "#e90000ff"),
                                      name = "Strength") +  
                theme_minimal(base_size = 14) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                labs(
                    title = str_c("Pathway: ", pathway, " (", group, ")"),
                    x = "Receiver Cell Type",
                    y = "Sender Cell Type"
                ) +
                scale_x_discrete(labels = function(x) gsub("_", " ", x)) +
                scale_y_discrete(labels = function(y) gsub("_", " ", y)) +
                theme(
                    plot.title = element_text(size = 10),
                    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
                    axis.title.x = element_text(size = 10),
                    axis.title.y = element_text(size = 10),
                    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
                    axis.text.y = element_text(size = 9)
                ) 
                
        if (!dir.exists(str_c("output/figures/cellchat/", group))) {
            dir.create(str_c("output/figures/cellchat/", group), recursive = TRUE)
        }
        ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_overall_plot.png"),
            plot_path,
            width = length(unique(pathway_df_plot$target)) * 0.3 + 3,
            height = length(unique(pathway_df_plot$source)) * 0.3 + 1,
            bg = "white"
        )
        
        interaction_names[[str_c(group, "_", pathway)]] <- unique(pathway_df$interaction_name)
        # plot for each interaction
      
        for (interaction in unique(pathway_df$interaction_name)) {
            interaction_df <-
                pathway_df %>%
                filter(interaction_name == interaction) %>%
                group_by(source, target) %>%
                summarise(
                    prob = sum(prob, na.rm = TRUE),
                    count = n(),
                    .groups = "drop"
                )

            plot_lr <-
                ggplot(interaction_df, aes(x = target, y = source, size = count, color = prob)) +
                    geom_point(alpha = 0.7) +
                    # scale_size_continuous(range = range(interaction_df$count, na.rm = TRUE), name = "Count") + 
                    scale_color_gradientn(colours = c("#fcf4f4ff", "#e90000ff"),
                                            name = "Strength") +  
                    theme_minimal(base_size = 14) +
                    labs(
                        title = str_c("LR: ", interaction, " (Pathway:", pathway, " - ", group, ")"),
                        x = "Receiver Cell Type",
                        y = "Sender Cell Type") +
                    theme(plot.title = element_text(size = 10),
                        axis.title.x = element_text(size = 10),
                        axis.title.y = element_text(size = 10),
                        axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
                        axis.text.y = element_text(size = 9))

            if (!dir.exists(str_c("output/figures/cellchat/", group))) {
                dir.create(str_c("output/figures/cellchat/", group), recursive = TRUE)
            }
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_", interaction, "_interaction_plot.png"),
                plot_lr,
                width = length(unique(interaction_df$target)) * 0.3 + 3,
                height = length(unique(interaction_df$source)) * 0.3 + 2,
                bg = "white"
            )
        }
        # make receiver as epithelial cells only
        epithelial_interactions <- list()
        for (interaction in unique(pathway_df$interaction_name)) {
            interaction_df <-
                pathway_df %>%
                filter(interaction_name == interaction, target == "Epithelial_cells") %>%
                group_by(source, target) %>%
                summarise(
                    prob = sum(prob, na.rm = TRUE),
                    count = n(),
                    .groups = "drop"
                )
            if (nrow(interaction_df) > 0) {
                epithelial_interactions[[interaction]] <- interaction_df
            }
        }
        merge_epithelial_interactions <-
            bind_rows(
                lapply(names(epithelial_interactions), function(nm) {
                    df <- epithelial_interactions[[nm]]
                    df$interaction_name <- nm
                    df
                })
            ) %>%
            as_tibble() %>%
            as.data.frame() #%>%
            #filter(interaction_name %in% c("FN1_ITGA3_ITGB1", "FN1_SDC1", "FN1_CD44"))
 
            plot_tile_interaction <-
                ggplot(merge_epithelial_interactions,
                        aes(x = interaction_name, y = source, size = count, color = prob)) +
                    geom_point(alpha = 0.8) +
                    scale_color_gradientn(colours = c("#fcf4f4ff", "#e90000ff"),
                                          name = "Strength") +
                    scale_size_continuous(name = "Count") +
                    theme_minimal(base_size = 14) +
                    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                    labs(
                        title = str_c("Pathway: ", pathway, " (", group, ") - Epithelial cells as Receiver"),
                        x = "Interaction Name", y = "Sender Cell Type"
                    ) +
                #scale_x_discrete(labels = function(x) gsub("_", " ", x)) +
                scale_y_discrete(labels = function(y) gsub("_", " ", y)) +
                theme(
                    plot.title = element_text(size = 10),
                    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
                    axis.title.x = element_text(size = 10),
                    axis.title.y = element_text(size = 10),
                    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
                    axis.text.y = element_text(size = 9)
                )
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_epithelial_receiver_interaction_plot.png"),
                plot_tile_interaction,
                width = length(unique(merge_epithelial_interactions$interaction_name)) * 0.3 + 3,
                height = length(unique(merge_epithelial_interactions$source)) * 0.3 + 1,
                bg = "white"
            )
            ggsave(str_c("output/figures/cellchat/", group, "/", pathway, "_epithelial_receiver_interaction_plot.pdf"),
                plot_tile_interaction,
                width = length(unique(merge_epithelial_interactions$interaction_name)) * 0.3 + 3,
                height = length(unique(merge_epithelial_interactions$source)) * 0.3 + 1,
                bg = "white"
            )
    }
}


# whole object reference for rctd
for (sobj in c("patient_mets", "dogs_mets",
                "mm_mets", "xeno_mets_cancer_normal")) {
    sobj_path <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/", sobj, ".qs"))
    
    features <-
        c("SDC1", "SDC4", "ITGA3", "ITGB1", "CD44")
    if (sobj == "mm_mets") {
        features <- 
            nichenetr::convert_human_to_mouse_symbols(features)
    }
    dotplot <-
        DotPlot(sobj_path,
                features = features,
                cols = "RdBu",
                group.by = "Ann_Level2",
                scale = T) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            ggtitle(str_c("Expression in All Cells - ", sobj))
    if (!dir.exists(str_c("output/figures/cellchat/", sobj))) {
        dir.create(str_c("output/figures/cellchat/", sobj), recursive = TRUE)
    }
    ggsave(str_c("output/figures/cellchat/", sobj, "/FN1_receptor_exp.png"),
        dotplot,
        width = 6,
        height = 9,
        bg = "white"
    )
    ggsave(str_c("output/figures/cellchat/", sobj, "/FN1_receptor_exp.pdf"),
        dotplot,
        width = 6,
        height = 9,
        bg = "white"
    )
}




# from the plots in TGFb, the alv macroiphages and TAMs seems interesting

# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary

# ligand_target_long <- 
#     as.data.frame(as.matrix(ligand_target_matrix_mouse)) %>%
#     rownames_to_column("ligand") %>%
#     pivot_longer(-ligand, names_to = "target", values_to = "value")

# ggplot(ligand_target_long, aes(x = value)) +
#     geom_histogram(bins = 200, fill = "skyblue", color = "black") +
#     geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
#     labs(title = "Histogram of Ligand-Target Matrix Values",
#             x = "Values", y = "Frequency") +
#     theme_minimal() +
#     xlim(c(0, 0.1))

ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")

# mouse 
ligand_target_matrix_mouse <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final_mouse.rds")

#pathways by celltype interested list
pathways_by_celltype <-
    list(
        TGFB1 = c("Endothelial_cells",  "TAMs", "Epithelial_cells"),
        TGFB2 = c("Endothelial_cells", "TAMs", "Epithelial_cells"),
        TGFB3 = c("Endothelial_cells", "TAMs"),
        FN1 = c("Epithelial_cells"
            #, "TAMs", "Endothelial_cells", "Monocytes"
            ),
        COL1A1 = c("Epithelial_cells"),
        LAMA4 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive", "Epithelial_cells", "Endothelial_cells"),
        LAMB1 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive","TAMs", "Epithelial_cells", "Endothelial_cells"),
        CXCL12 = c("CAFs", "TAMs", "B_cells", "Alv_Macrophages", "Neutrophils",
                    "DC", "NK_cells", "Monocytes"),
        VEGFA = c("Endothelial_cells"),
        VEGFB = c("Endothelial_cells"),
        VEGFC = c("Endothelial_cells"),
        CADM1 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive", "Epithelial_cells"),
        NCAM1 = c("COMA", "Proliferative", "MP_Progenitor", "Basal_Progenitor",
                  "Fibrogenic", "Interactive", "Epithelial_cells")
    )

# find the unique ligand_receptor names from all
unique_LR_names <- 
    unique(unlist(interaction_names)) %>%
    as.character()

# ligand_by_receptor
ligand_receptor_list <- list(
    FN1 = c("CD44", "ITGA3", "ITGB1","ITGA2B", "ITGB3", "SDC1", "SDC4"),
    # LAMA4 = c("CD44", "ITGA1", "ITGB1", "ITGA2", "ITGA3", "ITGA7", "SV2A", "SV2C", "DAG1"),
    # LAMB1 = c("CD44", "ITGA1", "ITGB1", "ITGA2", "ITGA3", "ITGA7", "SV2A", "SV2C", "DAG1"),
    #LAMC1 = c("CD44", "ITGA1", "ITGB1", "ITGA2", "ITGA3", "ITGA7", "SV2A", "SV2C", "DAG1"),
    TGFB1 = c("TGFBR1", "TGFBR2", "ACVR1"),
    TGFB2 = c("TGFBR1", "TGFBR2", "ACVR1"),
    TGFB3 = c("TGFBR1", "TGFBR2", "ACVR1"),
    VEGFA = c("VEGFR1", "VEGFR2"),
    VEGFB = c("VEGFR1"),
    VEGFC = c("VEGFR2"),
    CXCL12 = c("CXCR4", "ACKR3"),
    CADM1 = c("CADM1"),
    NCAM1 = c("NCAM1"),
    COL1A1 = c("CD44", "ITGA1", "ITGB1", "ITGA3")
)

# make downstream plots for each ligand in each group
for (group in c(
                # "patient_prim",
                "patient_mets",
                # "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                # "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                # "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    if (object$organism[1] == "human") {
        ligand_target_matrix_use <- ligand_target_matrix
    } else {
        ligand_target_matrix_use <- ligand_target_matrix_mouse
    }
    # Use parallel::mclapply to process ligands in parallel
    ligand_results <- parallel::mclapply(
        c(
            #"TGFB1","TGFB2", "TGFB3", "FN1",
        "COL1A1"
        # "LAMA4", "LAMB1", "VEGFA", "VEGFB",
        #   "VEGFC", "CXCL12", "CADM1", "NCAM1"
          ),
        function(ligands) {
            # check if the ligand is expressed in the object
            if (ligands %in% rownames(object)) {
                message(str_c("Processing ligand ", ligands, " in group ", group))
                if (object$organism[1] == "human") {
                    lig <- ligands
                } else {
                    lig <- nichenetr::convert_human_to_mouse_symbols(ligands) %>%
                        as.character()
                }
                if (lig %in% rownames(ligand_target_matrix_use)) {
                    targets <-
                        ligand_target_matrix_use[lig, ] %>%
                        as.data.frame() %>%
                        rownames_to_column("target") %>%
                        rename(score = 2) %>%
                        arrange(desc(score)) %>%
                        filter(score > 0.01) %>%
                        mutate(ligand = lig)
                    #make a expression name with ligands_ligand
                    ligand_display_name <- str_c(ligands, "_ligand")
                    object[[ligand_display_name]] <- GetAssayData(object, slot = "data")[ligands, ]

                    downstream_genes <-
                        targets %>%
                        filter(target %in% rownames(object)) %>%
                        # filter(target != lig) %>%
                        pull(target)
                    if (length(downstream_genes) > 100) {
                        downstream_genes <- downstream_genes[1:100]
                    }
                    # run Aucell with the downstream genes
                    entire_matrix <- object@assays$RNA$counts
                    genelist <- downstream_genes
                    cell_ranks <-
                        AUCell::AUCell_run(exprMat = entire_matrix,
                                           geneSets = genelist)
                    object[[str_c(ligands,"_dwnstrm")]] <- AUCell::getAUC(cell_ranks)[1,]

                    Idents(object) <- "Ann_Level2"
                    dotplot_everything <-
                        DotPlot(object,
                            #cols = "RdBu",
                            features =  c(ligand_display_name,
                                         ligand_receptor_list[[ligands]],
                                         str_c(ligands,"_dwnstrm"),
                                         downstream_genes),
                            group.by = "Ann_Level2",
                            idents = pathways_by_celltype[[ligands]],
                            scale = F) +
                            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                            ggtitle(str_c("Ligand: ", ligands, " and Downstream Targets (", group, ")"))
                    
                
                    ggsave(str_c("output/figures/cellchat/", group, "/", ligands, "_ligand_and_downstream_targets.png"),
                            dotplot_everything,
                            width = length(downstream_genes) * 0.3 + 5,
                            height = length(unique(object$Ann_Level2)) * 0.3 + 3,
                            bg = "white")
                    # return(TRUE)
                } else {
                    message(str_c("Ligand ", ligands, " not found in ligand-target matrix for ", group))
                    # return(FALSE)
                }
            }
            # return(FALSE)
        },
        mc.cores = 3,
        mc.preschedule = F # adjust the number of cores as needed
    )
}

# TGFB plts
tgfb<- list()
for (group in c(
                # "patient_prim",
                "patient_mets",
                # "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                # "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                # "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs")) %>%
        subset(Ann_Level2 %in% c("Epithelial_cells"))
    dotplot_tgfb <-
        DotPlot(object,
                features =  c("TGFB1"),
                group.by = "Ann_Level2",
                scale = F) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
            ggtitle(str_c("TGFB in Epithelial Cells (", group, ")"))
    tgfb[[group]] <- dotplot_tgfb
}

panel <-
    wrap_plots(tgfb, ncol = 2) +
    plot_annotation(title = "TGFB Expression in Epithelial Cells Across Samples",
                    theme = theme(plot.title = element_text(size = 16, hjust = 0.5)))

#compare the expression in normal lung vs tumor associated macrophages
normal_lung <-
    qs::qread("input/downloads/ds_human_lung_atlas.qs")

dimplot_better(normal_lung, group_by = "ann_level_3")
cell_types <- c(
    "Macrophages",
    "AT2",
    "EC venous",
    "EC arterial",
    "AT1",
    "Monocytes",
    "EC capillary",
    "Lymphatic EC mature",
    "Lymphatic EC differentiating",
    "Lymphatic EC proliferating"
)
normal_lung_sub <-
    normal_lung %>%
    subset(ann_level_3 %in% cell_types)
normal_lung_sub$unique <- "normal"
dimplot_better(normal_lung_sub, group_by = "ann_level_3")
FeaturePlot(normal_lung_sub, features = c("TGFB1"))
normal_lung_sub$compare_label <-
    str_replace_all(normal_lung_sub$ann_level_3, c("^EC venous$" = "Endothelial_cells",
                                                "^EC arterial$" = "Endothelial_cells",
                                                "^EC capillary$" = "Endothelial_cells",
                                                "^Lymphatic EC mature$" = "Endothelial_cells",
                                                "^Lymphatic EC differentiating$" = "Endothelial_cells",
                                                "^Lymphatic EC proliferating$" = "Endothelial_cells",
                                                "^AT2$" = "Epithelial_cells",
                                                "^AT1$" = "Epithelial_cells"))

tumor_lung <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
tumor_lung_sub <-
    tumor_lung %>%
    subset(Ann_Level2 %in% c("TAMs", "Monocytes", "Endothelial_cells", "Epithelial_cells"))
tumor_lung_sub$unique <- "tumor"
tumor_lung_sub$compare_label <-
    str_replace_all(tumor_lung_sub$Ann_Level2, c("^Alv_Macrophages$" = "Macrophages",
                                                "^TAMs$" = "Macrophages"))
# combine the two datasets
combine_tumor_normal <-
    merge(tumor_lung_sub, normal_lung_sub) %>%
    JoinLayers() %>%
    process_seurat()

qs::qsave(combine_tumor_normal,
        "output/seurat_objects/combined_normal_tumor_lung.qs")

# calculate average expression of TGFB1, HMGB1, CMTM8, GLG1, VEGFA, VEGFB, VEGFC in normal vs tumor
genes_of_interest <- c(
    "TGFB1", "IL18", "IL15", "TGFB2", "HMGB1", "CMTM8", "GAS6", "GLG1", "IL32", 
    "IGFBP7", "MIF", "NAMPT", "ALCAM", "CCN1", "VEGFA", "TNF", "TNFSF10", "IL1B"
)

combine_tumor_normal <-
    qs::qread("output/seurat_objects/combined_normal_tumor_lung.qs")

# Calculate average expression for each gene and cell type in tumor and normal
avg_expr_list <- list()
for (gene in genes_of_interest) {
    for (celltype in unique(combine_tumor_normal$compare_label)) {
        avg_normal <- mean(GetAssayData(combine_tumor_normal, slot = "data")[gene, 
            combine_tumor_normal$unique == "normal" & combine_tumor_normal$compare_label == celltype], na.rm = TRUE)
        avg_tumor <- mean(GetAssayData(combine_tumor_normal, slot = "data")[gene, 
            combine_tumor_normal$unique == "tumor" & combine_tumor_normal$compare_label == celltype], na.rm = TRUE)
        log2FC <- log2((avg_tumor + 0.001) / (avg_normal + 0.001))
        avg_expr_list[[paste(gene, celltype, sep = "_")]] <- data.frame(
            Gene = gene,
            CellType = celltype,
            Tumor = avg_tumor,
            Normal = avg_normal,
            log2FC = log2FC
        )
    }
}

Anerage_exp <-
    do.call(rbind, avg_expr_list) %>%
    arrange(log2FC) %>%
    filter(str_detect(CellType, "Epithelial_cells"))
pheatmap::pheatmap(
    Anerage_exp %>% 
        select(Tumor, Normal, log2FC) %>% 
        as.matrix(),
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    color = colorRampPalette(c("#ceddf3ff", "#facbcbff", "#D43F3AFF"))(100),
    main = "Average Expression Heatmap (Tumor/Normal/log2FC)",
    fontsize_row = 10,
    fontsize_col = 10,
    display_numbers = T
)

# dotplot for epithelail
DotPlot(combine_tumor_normal %>% subset(compare_label == "Epithelial_cells"),
        features = c("TGFB1", "TGFB2"),
        group.by = "unique",
        scale = F) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Expression in Epithelial Cells (Normal vs Tumor)")



# what different about normal epithelial vs tumor associated epithelial DEGS






# whats different about this TGFB1 and TGFB2 activated vs not activated epithelial cells in tumor
Epithelial_cells_tumor <-
    combine_tumor_normal %>%
    subset(compare_label == "Epithelial_cells" & unique == "tumor") %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = c("sample_name", "method", "data_source"),
             theta = c(12, 12, 12)) %>%
    process_seurat(reduction = "harmony")
Epithelial_cells_tumor <-
    FindClusters(Epithelial_cells_tumor, resolution = 0.2)

DotPlot(Epithelial_cells_tumor,
        features = c("TGFB1", "SDC1", "SDC4"),
        group.by = "seurat_clusters",
        scale = F) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("DATP Markers in Human Tumor Associated Epithelial Cells")



dimplot_better(Epithelial_cells_tumor, group_by = c("seurat_clusters")) + NoLegend()
FeaturePlot(Epithelial_cells_tumor, features = c("TGFB1", "GLG1", "SDC1", "SDC4", "ITGA3", "ITGB1"), order=T, pt.size = 1)
VlnPlot(Epithelial_cells_tumor,
        features = c("TGFB1", "GLG1", "SDC1", "SDC4", "ITGA3", "ITGB1"),
        group.by = "seurat_clusters")
DotPlot(Epithelial_cells_tumor,
        features = c("TGFB1", "GLG1", "SDC1", "SDC4", "ITGA3", "ITGB1"),
        group.by = "seurat_clusters",
        scale = F) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Integrin and Syndecan Expression in Human Tumor Associated Epithelial Cells")

# what are the top 30 target genes of FN1 that activate TGFB1
up_of_fn1_that_acitivate_tgfb <-
    ligand_target_matrix[, "TGFB1"] %>%
    sort(decreasing = TRUE) %>%
    head(30) %>%
    names() %>%
    as.vector()


cell_chat_objs <-
    list.files(str_c("output/cellchat_objects_sharedgenes/", "patient_mets"),
            pattern = "*.qs",
            full.names = TRUE)
cellchat_list <- list()
pathways_LR <- list()

for (file_path in cell_chat_objs) {
    sample_name <- str_replace(basename(file_path), ".qs", "")
    cellchat <- qs::qread(file_path)
    cellchat_list[[sample_name]] <- cellchat
    
    pathways_and_lr_prob <-
        subsetCommunication(cellchat,
                            slot.name = "net") %>%
        arrange(desc(prob)) %>%
        filter(target %in% c("Epithelial_cells")) %>%
        filter(ligand %in% up_of_fn1_that_acitivate_tgfb) %>%
        filter(source %in% c("Basal_Progenitor", "Proliferative", "Fibrogenic",
                        "COMA", "Interactive", "MP_Progenitor")) %>%
        arrange(desc(prob)) %>%



}


```













## Run RCTD for spatial mapping of TAECs
see if the TAECs are spatially located near the tumor edge compared to normal epithelial cells
```{r rctd_input_files_for_epithelial}
# whats different about this TGFB1 and TGFB2 activated vs not activated epithelial cells in tumor
combine_tumor_normal <-
    qs::qread("output/seurat_objects/combined_normal_tumor_lung.qs")

combine_tumor_normal$sample_name <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$sample_name,
           combine_tumor_normal$study)
combine_tumor_normal$method <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$method,
           "single_cell")
combine_tumor_normal$data_source <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$data_source,
           "human_lung_atlas")
combine_tumor_normal$Ann_Level3 <-
    ifelse(combine_tumor_normal$unique == "tumor",
           combine_tumor_normal$Ann_Level3,
           combine_tumor_normal$ann_level_3)

Epithelial_cells_all <-
    combine_tumor_normal %>%
    subset(Ann_Level3 %in% c("AT1", "AT2")) %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = c("sample_name", "method", "data_source"),
             theta = c(12, 12, 12)) %>%
    process_seurat(reduction = "harmony")
Epithelial_cells_all <-
    FindClusters(Epithelial_cells_all, resolution = 0.3)
dimplot_better(Epithelial_cells_all, group_by = c("seurat_clusters", "unique")) + NoLegend()
table(Epithelial_cells_all$seurat_clusters, Epithelial_cells_all$unique)
Epithelial_cells_all$Annotation_detailed <-
    ifelse(Epithelial_cells_all$unique == "tumor", 
           str_replace_all(Epithelial_cells_all$seurat_clusters,
                        c("^0$" = "AT1",
                        "^1$" = "AT2",
                        "^2" = "Mesenchymal_like",
                        "^3$$" = "AT1",
                        "^4$" = "AT1")),
        Epithelial_cells_all$Ann_Level3)


DimPlot(Epithelial_cells_all,
                group.by = "Annotation_detailed",
                split.by = "unique",
                label.box = T,
                label = T,
                cols = plot_cols,
                ncol = 2) + NoLegend()

TAEC_markers <- c(
    "ZEB1",      # EMT transcription factor
    "ITGAV",     # activates tgfb1
    "VIM",       # Vimentin, mesenchymal marker
    "TNC",
    "TGFB1",
    "SFTPC",
    "SFTPB",
    "AGER",
    "CAV1"
)

# Combined list
DotPlot(Epithelial_cells_all,
        features =TAEC_markers,
        group.by = "Annotation_detailed",
        split.by = "unique",
        cols = "RdBu",
        dot.scale = 8,
        scale = T) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Expression in Epithelial Cells (Normal vs Tumor)")


# make gsea plots
Epithelial_cells_all$organism <- "human"

make_panel_plot(sobj = Epithelial_cells_all %>% subset(unique == "tumor"),
                comparison_col = "Annotation_detailed",
                label = "Annotation_detailed",
                group = "Mesenchymal_like_vs_AT1_AT2",
                aggregate_by = c("sample_name", "Annotation_detailed"),
                organism_col = "organism",
                subset = FALSE,
                batch_var = "data_source")



Epithelial_cells_tumor <-
    combine_tumor_normal %>%
    subset(compare_label == "Epithelial_cells" & unique == "tumor") %>%
    subset(Ann_Level3 %in% c("AT1", "AT2")) %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = c("sample_name", "method", "data_source"),
             theta = c(12, 12, 12)) %>%
    process_seurat(reduction = "harmony")

Epithelial_cells_tumor <-
    FindClusters(Epithelial_cells_tumor, resolution = 0.1) 
dimplot_better(Epithelial_cells_tumor, group_by = c("seurat_clusters")) + NoLegend()
# rename the TGFb1 high clusters to TAECs
Epithelial_cells_tumor$Annotation_detailed <-
    ifelse(Epithelial_cells_tumor$seurat_clusters %in% c(2, 3), "TAECs", "General_AT1_AT2")


DotPlot(Epithelial_cells_tumor,
        features = TAEC_markers,
        group.by = "seurat_clusters",
        #cols = "RdBu",
        dot.scale = 8,
        scale = T) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Expression in Epithelial Cells (Normal vs Tumor)")

# run degs between the TAECs and other epithelial cells
degs_Iwant <-
    run_degs(sobject = Epithelial_cells_tumor,
            comparison_col = "Annotation_detailed",
            aggregate_by = c("sample_name", "Annotation_detailed"),
            organism_col = "organism",
            subset = FALSE,
            batch_var = "data_source")

TAECs_degs <-
    degs_Iwant$TAECs %>%
    filter(padj < 0.05) %>%
    arrange(desc(log2FoldChange)) %>%
    head(50) %>%
    pull(gene)

Epithelial_cells_tumor$organism <- "human"

dimplot_better(Epithelial_cells_tumor, group_by = "Annotation_detailed") + NoLegend()
# make gsea plots
make_panel_plot(sobj = Epithelial_cells_tumor,
                comparison_col = "Annotation_detailed",
                label = "Annotation_detailed",
                group = "TAECs_vs_Other",
                aggregate_by = c("sample_name", "Annotation_detailed"),
                organism_col = "organism",
                subset = FALSE,
                batch_var = "data_source")

# whole object reference for rctd
patient_mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
Metadata_TECS <-
    Epithelial_cells_tumor@meta.data %>%
    rownames_to_column("cell_id") %>%
    select(cell_id, Annotation_detailed)

whole_metadata <-
    patient_mets@meta.data %>%
    rownames_to_column("cell_id") %>%
    select(cell_id, Ann_Level2) %>%
    left_join(Metadata_TECS, by = "cell_id") %>%
    mutate(rctd_ann_col = ifelse(is.na(Annotation_detailed), Ann_Level2, Annotation_detailed)) %>%
    select(cell_id, rctd_ann_col)

patient_mets_ref <-
    AddMetaData(patient_mets,
                whole_metadata %>% column_to_rownames("cell_id"))
dimplot_better(patient_mets_ref, group_by = "rctd_ann_col") + NoLegend()

# make the reference object for rctd
reference <- 
    spacexr::Reference(GetAssayData(patient_mets_ref, layer = "counts"),
                        as.factor(patient_mets_ref$rctd_ann_col),
                        n_max_cells = 2000)

spatial_list <-
    qs::qread("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/spatial_objects/spatial_list_level3_annotations.qs")

# functions
run_rctd <- function(sp_ob, ref) {
    coords <- GetTissueCoordinates(sp_ob, image = "slice1") %>%
        dplyr::rename(x = imagerow, y = imagecol)
    #convert our object to an rctd object
    my_data <- spacexr::SpatialRNA(coords,
                                   GetAssayData(sp_ob, layer = "counts"))
    rctd_obj <- spacexr::create.RCTD(
        my_data,
        ref,
        max_cores = 4,
        UMI_min = 3,
        counts_MIN = 0,
        UMI_max = 900000000,
        CELL_MIN_INSTANCE = 0
    )
    rctd_out <- spacexr::run.RCTD(
        rctd_obj,
        doublet_mode = "doublet"
    )
    return(rctd_out)
}

# read in object list and select correct reference
for (ob_name in names(spatial_list)) {
    sp_object <- spatial_list[[ob_name]]
    rctd_annots <- run_rctd(sp_ob = sp_object,
                             ref = reference)
    norm_weights <-
            spacexr::normalize_weights(rctd_annots@results$weights) %>%
            as.data.frame()

    spatial_list[[ob_name]] <-
        AddMetaData(spatial_list[[ob_name]], norm_weights)

}

qs::qsave(
    spatial_list,
    "output/spatial_objects/spatial_list_with_TAECs.qs"
)

# plot the rctd results
spatial_list <-
    qs::qread("output/spatial_objects/spatial_list_with_TAECs.qs")

for (ob_name in names(spatial_list)) {
    spatial_list[[ob_name]]$tumor_cumulative <-
        spatial_list[[ob_name]]$Basal_Progenitor +
        spatial_list[[ob_name]]$Fibrogenic +
        spatial_list[[ob_name]]$Interactive +
        spatial_list[[ob_name]]$MP_Progenitor +
        spatial_list[[ob_name]]$Proliferative +
        spatial_list[[ob_name]]$COMA
}

SpatialFeaturePlot(spatial_list$OS7_Seurat,
                    features = c("TAECs", "General_AT1_AT2", "tumor_cumulative"),
                    ncol = 2,
                    pt.size.factor = 2
                    #image.alpha = 0
                    ) +
SpatialDimPlot(spatial_list$OS7_Seurat,
                alpha = 0) + NoLegend()


patient_mets_ref <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
patient_mets_ref$tissue_type <- "TME"
ds_pmets <-
    patient_mets_ref %>%
    subset(cells = sample(colnames(patient_mets_ref), 41086))
dimplot_better(ds_pmets, group_by = "Ann_Level3") + NoLegend()
VlnPlot(ds_pmets,
        features = c("FN1"),
        group.by = "Ann_Level2")
healthy_lung <-
    qs::qread("input/downloads/ds_human_lung_atlas.qs")
healthy_lung$tissue_type <- "Healthy"
healthy_lung$sample_name <- healthy_lung$study

VlnPlot(healthy_lung,
        features = c("FN1"),
        group.by = "ann_level_3")

combine <-
    merge(ds_pmets, healthy_lung) %>%
    JoinLayers() %>%
    process_seurat()
combine$Ann_Level0 <-
    ifelse(combine$tissue_type == "Healthy", "Healthy", combine$Ann_Level0)

avg_expr <- 
    AverageExpression(combine,
                        features = c("FN1"),
                        group.by = c("Ann_Level0", "sample_name"))$RNA %>%
    as.data.frame()

# make a boxplot of FN1 expression in healthy vs TME and perform t test
avg_expr_long <-
    avg_expr %>%
    rownames_to_column("gene") %>%
    pivot_longer(-gene, names_to = "tissue_sample", values_to = "expression") %>%
    separate(tissue_sample, into = c("Ann_Level0", "sample_name"), sep = "_", extra = "merge")

average_FN1_plot <-
    ggplot(avg_expr_long %>% filter(gene == "FN1"),
            aes(x = Ann_Level0, y = expression, fill = Ann_Level0)) +
        geom_boxplot() +
        scale_fill_manual(values = c("Healthy" = "#357EBDFF",
                                     "Host" = "#EEA236FF",
                                     "Tumor" = "#D43F3AFF")) +
        geom_jitter(width = 0.2) +
        theme_minimal() +
        ggpubr::stat_compare_means(comparisons = list(c("Healthy", "Host"),
                               c("Healthy", "Tumor"),
                               c("Host", "Tumor")),
            method = "t.test", label = "p.format", p.adjust.method = "bonferroni"
        ) +
        ggtitle("Average FN1 Expression in Healthy vs TME") +
        xlab("Tissue Type") +
        ylab("Average Expression") +
        theme(legend.position = "none",
            plot.title = element_text(hjust = 0.5, size = 16),
            axis.title = element_text(size = 14),
            axis.text = element_text(size = 12),
            panel.grid = element_blank())

ggsave("output/figures/cellchat/FN1_expression_healthy_vs_TME.pdf",
        average_FN1_plot,
        width = 4,
        height = 5,
        bg = "white")
```


## for Mouse
```{r see_if_TAECs_in_mouse}
# load the mouse mets object
mm_mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/mm_mets.qs")

tumor_asso_tams <-
    mm_mets %>%
    subset(Ann_Level2 %in% c("TAMs", "Alv_Macrophages", "Monocytes", "cMonocytes", "ncMonocytes"))
DotPlot(tumor_asso_tams,
        features = c("Inhba"),
        group.by = "Ann_Level3",
        scale = F) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Expression in Tumor Associated Macrophages")

tumor_asso_epi <-
    mm_mets %>%
    subset(Ann_Level3 %in% c("AT1", "AT2")) %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = c("sample_name", "method")) %>%
    process_seurat(reduction = "harmony",
                   resolution = 0.4)
# assign the celltypes based on the markers
tumor_asso_epi$TEACs_and_others <-
    ifelse(tumor_asso_epi$seurat_clusters %in% c(1, 5, 6), "TAECs", "General_AT1_AT2")

dimplot_better(tumor_asso_epi, group_by = "TEACs_and_others") + NoLegend()
FeaturePlot(tumor_asso_epi,features = c("Tgfb1"), order=T, pt.size = 1)
VlnPlot(tumor_asso_epi,
        features = c("Tgfb1", "Sdc1", "Sdc4"),
        group.by = "TEACs_and_others")
DotPlot(tumor_asso_epi,
        features = c(TAEC_markers, AT1_markers, AT2_markers, "SDC1", "SDC4", "KRT8") %>%
            nichenetr::convert_human_to_mouse_symbols() %>%
            as.character(),
        group.by = "TEACs_and_others",
        scale= F) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

# healthy mouse lung epithelial cells
mouse_lung <-
    qs::qread("input/downloads/mouse_lung.qs")

normal_epi <-
    mouse_lung %>%
    subset(CellType %in% c("AT")) %>%
    process_seurat()
normal_epi$TEACs_and_others <-
    str_replace_all(normal_epi$seurat_clusters, c("^0$" = "AT2",
                                                "^1$" = "AT2",
                                                "^2$" = "AT1",
                                                "^3$" = "AT1",
                                                "^4$" = "AT2"))
normal_epi$unique <- "normal"
normal_epi$organism <- "mouse"
normal_epi$sample_name <- normal_epi$orig.ident
normal_epi$data_source <- "online"

dimplot_better(normal_epi, group_by = "TEACs_and_others") + NoLegend()
FeaturePlot(normal_epi, features = c("Tgfb1"), order=T, pt.size = 1)
VlnPlot(normal_epi,
        features = c("Tgfb1"),
        group.by = "TEACs_and_others")
DotPlot(normal_epi,
        features = c("Tgfb1"),
        group.by = "TEACs_and_others",
        scale = F)
# combine the two datasets
combine_mouse_tumor_normal <-
    merge(tumor_asso_epi, normal_epi) %>%
    JoinLayers() %>%
    process_seurat() %>%
    RunHarmony(group.by.vars = c("sample_name", "data_source"),
             theta = c(12, 12)) %>%
    process_seurat(reduction = "harmony",
                   resolution = 0.4)

dimplot_better(combine_mouse_tumor_normal, group_by = c("TEACs_and_others", "unique")) + NoLegend()



```
















## compare primary vs mets by pathways as a whole
```{r compare_pathways_primary_mets_as_whole}

## compare_pathway networks between primary and mets for clustering using PCA
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## PCA analysis for each sample within primary and mets
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame()

    # fill up the missing pathways with 0 prob for each sample
    df_wide <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = pathway_name, values_from = prob, values_fill = 0) %>%
        column_to_rownames("sample_group")  

    # perform PCA
    pca_res <- prcomp(df_wide, scale. = TRUE)
    pca_df <- as.data.frame(pca_res$x)
    pca_df$site <-
        rownames(pca_df) %>%
        str_split("-") %>%
        map_chr(2)
    pca_df$sample_group <-
        rownames(pca_df) %>% 
            str_remove("_AnnL2.*$")

    # get the loadings for PC1
    loadings_pc1 <-
        pca_res$rotation %>%
        as.data.frame() %>%
        select(PC2) %>%
        rownames_to_column("pathways") %>%
        arrange(desc(abs(PC2)))

    # plot PCA
    library(ggrepel)
    pca_plot<-
        ggplot(pca_df, aes(x = PC1, y = PC2, label = sample_group)) +
        geom_point(aes(color = site), size = 3) +
        geom_text_repel(size = 3, max.overlaps = Inf) +
        labs(title = str_c("PCA - ", group_prim, " vs ", group_mets),
             x = "PC1", y = "PC2") +
        theme_minimal() 
    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_mets_pathway_probabilities_PCA.png"),
        pca_plot,
        width = 15,
        height = 10,
        bg = "white"
    )
}


sig_pathways <- list()
## Analysis for the pathway and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # fill up the missing pathways with 0 prob for each sample
    fill_prob_prim_mets <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the mean prob for each pathway in both primary and mets separately
    total_number_primary <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
    total_number_mets <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

    mean_per_pathway_in_mets <-
        pathways_prob_df %>%
        filter(group == "Metastatic") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_mets) %>%  
        arrange(desc(mean_prob))
    mean_per_pathway_in_primary <-
        pathways_prob_df %>%
        filter(group == "Primary") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_primary) %>%  
        arrange(desc(mean_prob))
    
    # jopin the two means and keep the higher one
    mean_per_pathway <-
        full_join(x = mean_per_pathway_in_primary,
                  y = mean_per_pathway_in_mets,
                  by = "pathway_name",
                  suffix = c("_prim", "_mets")) %>%
        mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
        select(pathway_name, mean_prob) %>%
        arrange(desc(mean_prob))
    
    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        fill_prob_prim_mets %>%
        filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob) %>%
        select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        group_by(pathway_name, group) %>%
        mutate(fold_change = mean(prob) / max(mean_prob)) %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    prob_filter <- median(pathways_prob_df$prob)
    chosen_pathways <- 
        pathways_prob_df_filtered %>%
        #filter(mean_prob > prob_filter & fold_change < 0.5) %>%
        filter(fold_change < 0.7) %>%
        filter(padj < 0.1) %>%
        arrange(desc(prob)) %>%
        select(pathway_name, fold_change) %>%
        distinct()

    # finally plot the chosen pathways
    if (nrow(chosen_pathways) != 0) {
            # save the chosen pathways
        sig_pathways[[str_c(group_prim, "_vs_", group_mets)]] <-
            chosen_pathways$pathway_name
        
        # Split pathways into two halves for plotting
        half_n <- ceiling(length(chosen_pathways$pathway_name) / 2)
        pathways1 <- chosen_pathways$pathway_name[1:half_n]
        pathways2 <- chosen_pathways$pathway_name[(half_n + 1):length(chosen_pathways$pathway_name)]

        plot1 <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% pathways1) %>%
            mutate(group = factor(group, levels = c("Primary", "Metastatic")),
                   pathway_name = factor(pathway_name, levels = pathways1)) %>%
            ggplot(aes(x = pathway_name, y = log10(norm_prob+0.0001), fill = group)) +
            geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
            scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
            labs(title = str_c("Top Pathways (1st half) in ", group_prim, " vs ", group_mets),
                 x = "Pathway Arranged by Fold Change",
                 y = "Normalized Log10 Probability (by mean)") +
            theme_minimal() +
            theme(
                axis.text.x = element_text(angle = 45, hjust = 1),
                panel.grid = element_blank(),
                axis.line.x = element_line(),
                axis.line.y = element_line())

        plot2 <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% pathways2) %>%
            mutate(group = factor(group, levels = c("Primary", "Metastatic")),
                   pathway_name = factor(pathway_name, levels = pathways2)) %>%
            ggplot(aes(x = pathway_name, y = log10(norm_prob+0.0001), fill = group)) +
            geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
            scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
            labs(title = str_c("Top Pathways (2nd half) in ", group_prim, " vs ", group_mets),
                 x = "Pathway Arranged by Fold Change",
                 y = "Normalized Log10 Probability (by mean)") +
            theme_minimal() +
            theme(
                axis.text.x = element_text(angle = 45, hjust = 1),
                panel.grid = element_blank(),
                axis.line.x = element_line(),
                axis.line.y = element_line())

        # Save both plots
        ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_pathways_boxplot_1.pdf"),
               plot1,
               width = max(length(pathways1) * 0.6 + 1, 6),
               height = 6,
               limitsize = FALSE,
               bg = "white")
        ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_pathways_boxplot_2.pdf"),
               plot2,
               width = max(length(pathways2) * 0.6 + 1, 6),
               height = 6,
               limitsize = FALSE,
               bg = "white")  ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_pathways_boxplot.pdf"),
        plot_pathways,
        width = length(chosen_pathways$pathway_name) * 0.6 + 1,
        height = 6,
        limitsize = FALSE,
        bg = "white")
    }
}

mm_mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/mm_mets.qs")

dimplot_better(mm_mets, group_by = "Ann_Level3") + NoLegend()

```











## Compare prim vs mets pathways tumor as sender and specific celltype as receiver
```{r compare_pathways_primary_mets_specific_receiver}

## compare_pathway networks between primary and mets
# but this time set tumor as sending and normal as receiving

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")

receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

sig_pathways_list <- list()
## Analysis for the pathway and probabilities leve
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # loop for the receiver celltypes
    for (receiver_cell in receiver_celltypes) {
        # list for both primary and mets
        cellchat_list <- list()
        pathways_prob <- list()
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            
            target_cells <- receiver_cell
            
            # filter to LR and pathways and prob
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }
        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            target_cells <- receiver_cell
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
        # this is for the specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_prob) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))
        
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(pathway_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "pathway_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(pathway_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "pathway_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                    group_by(pathway_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(pathway_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(pathway_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(pathway_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(pathway_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "pathway_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(pathway_name, fold_change) %>%
                    distinct()
                # save the significant pathways to a list
                sig_pathways_list[[str_c(receiver_cell, "_in_", group_prim, "_vs_", group_mets)]] <- chosen_pathways

                # finally plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Pathways in ", receiver_cell, " in ",  group_prim, " vs ", group_mets),
                            x = "Pathway",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())
                                    
                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                            dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                            recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_pathways_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant pathway found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    }
}





```





### I want tumor to be the sender and stroma to be the receiver
### look at the top pathways
```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

pathway_of_interest <- c("VEGF", "FN1", "TGFb")


## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob))
        
        target_cells <-
            setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% target_cells) %>% 
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        target_cells <-
            setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
        # target_cells <- receiver_cell

        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            #filter(source %in% ligand_source & target %in% target_cells) %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }

    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # only continue if there are both primary and mets samples
    if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
        # fill up the missing pathways with 0 prob for each sample
        fill_prob_prim_mets <-
            pathways_prob_df %>%
            mutate(sample_group = paste(sample, group, sep = "-")) %>%
            select(pathway_name, sample_group, prob) %>%
            pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
            pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
            separate(sample_group, into = c("sample", "group"), sep = "-")

        # calculate the mean prob for each pathway in both primary and mets separately
        total_number_primary <- 
            n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
        total_number_mets <- 
            n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
        
        # only proceed if total number of primary and mets samples are both > 1
        if (total_number_primary > 1 & total_number_mets > 1) {
            mean_per_pathway_in_mets <-
                pathways_prob_df %>%
                filter(group == "Metastatic") %>%
                group_by(pathway_name) %>%
                arrange(desc(prob)) %>%
                summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                arrange(desc(mean_prob))
            mean_per_pathway_in_primary <-
                pathways_prob_df %>%
                filter(group == "Primary") %>%
                group_by(pathway_name) %>%
                arrange(desc(prob)) %>%
                summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                arrange(desc(mean_prob))
            
            # jopin the two means and keep the higher one
            mean_per_pathway <-
                full_join(x = mean_per_pathway_in_primary,
                        y = mean_per_pathway_in_mets,
                        by = "pathway_name",
                        suffix = c("_prim", "_mets")) %>%
                mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                select(pathway_name, mean_prob) %>%
                arrange(desc(mean_prob))
            
            # to calculate the pvalue
            myfun <- function(x) {
                x$pvalue <-
                    t.test(prob ~ group, data = x)$p.value
                return(x)
            }

            # now filter pathways for primary
            pathways_prob_df_filtered <- 
                fill_prob_prim_mets %>%
                filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                arrange(desc(prob)) %>%
                left_join(mean_per_pathway, by = "pathway_name") %>%
                mutate(norm_prob = prob / mean_prob) %>%
                select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                group_by(pathway_name) %>%
                group_split() %>%
                map(~ myfun(.x)) %>%
                bind_rows() %>%
                group_by(pathway_name, group) %>%
                mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                arrange(pathway_name) %>%
                ungroup()

            pull_path_pval <-
                pathways_prob_df_filtered %>%
                select(pathway_name, pvalue) %>%
                distinct() %>%
                mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                select(pathway_name, padj)

            # put the padj baclk to the pathways_prob_df_filtered
            pathways_prob_df_filtered <-
                pathways_prob_df_filtered %>%
                left_join(pull_path_pval, by = "pathway_name")

            prob_filter <- median(pathways_prob_df$prob)
            chosen_pathways <- 
                pathways_prob_df_filtered %>%
                filter(mean_prob > prob_filter & fold_change < 0.75) %>%
                filter(padj < 0.1) %>%
                arrange(desc(prob)) %>%
                select(pathway_name, fold_change) %>%
                distinct()

            # plot the chosen pathways
            if (nrow(chosen_pathways) != 0) {
                plot_pathways <-
                    pathways_prob_df_filtered %>%
                    filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                    mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                    ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                    geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                    geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                    scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                    scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                    labs(title = str_c("Top overall sharedgenes pathways in" , group_prim, " vs ", group_mets),
                        x = "Interaction",
                        y = "Normalized Probability (by mean)") +
                    theme_minimal() +
                                theme(
                                    axis.text.x = element_text(angle = 45, hjust = 1),
                                    panel.grid = element_blank(),
                                    axis.line.x = element_line(),
                                    axis.line.y = element_line())

                if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                    dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                    recursive = TRUE)
                }
                ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/sharedgenes_all_pathways_boxplot.png"),
                plot_pathways,
                width = max(length(chosen_pathways$pathway_name) * 0.75 + 1, 6),
                height = 6,
                bg = "white")
            } else {
                message("No significant interactions found for ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough samples in either primary or metastatic group for  ", group_prim, " vs ", group_mets)
        }
    } else {
        message("Not enough groups or interactions for ", group_prim, " vs ", group_mets)
    }
} 



## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```










### I want tumor to be the sender and stroma to be the receiver but only for significant pathways
## for each celltypes shown by analysis above where I look at tumor as sender and specific celltype as receiver

```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor", "Proliferative", "COMA", "MP_Progenitor")


receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

# celltype by signigicant patways from previous analysis


## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    for (receiver_cell in receiver_celltypes) {
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))

            target_cells <- receiver_cell

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                filter(pathway_name == "LAMININ") %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }

        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))
            # target_cells <-
            #     setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
            target_cells <- receiver_cell

            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                filter(pathway_name == "LAMININ") %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
    
        # this is for the specific interactions across primary and mets
        # specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_LR) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))

        # only continue if there are both primary and mets samples
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {

            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(interaction_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-interaction_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
            
            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "interaction_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(interaction_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(interaction_name %in% mean_per_pathway$interaction_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "interaction_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, interaction_name, prob, mean_prob, norm_prob) %>%
                    group_by(interaction_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(interaction_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(interaction_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(interaction_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(interaction_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "interaction_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(interaction_name, fold_change) %>%
                    distinct()

                # plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(interaction_name %in% chosen_pathways$interaction_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(interaction_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Interactions from Tumor to ", receiver_cell," in ",group_prim, " vs ", group_mets),
                            x = "Interaction",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())

                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                        dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                        recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_LR_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant interactions found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    } 
}


## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```


































## Leverage Nichenet to identify dowstream
```{r nichenet_downstream_analysis}

# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary
ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
    # Convert the ligand_target_matrix to a long data frame for ggplot

ligand_target_long <- 
    as.data.frame(as.matrix(ligand_target_matrix)) %>%
    rownames_to_column("ligand") %>%
    pivot_longer(-ligand, names_to = "target", values_to = "value")

ggplot(ligand_target_long, aes(x = value)) +
    geom_histogram(bins = 200, fill = "skyblue", color = "black") +
    geom_vline(xintercept = 0.01, color = "red", linetype = "dashed", size = 1) +
    labs(title = "Histogram of Ligand-Target Matrix Values",
            x = "Values", y = "Frequency") +
    theme_minimal() +
    xlim(c(0, 0.1))
cutoff <- 0.01

lig <- "FN1"
targets <-
    ligand_target_matrix[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    #filter(score > cutoff) %>%
    mutate(ligand = lig) 



downstream_genes <-
    targets %>%
    filter(target %in% fn1_downstream_genes)

dimplot_better(Epithelial_cells_all, group_by = "seurat_clusters")
fn1_downstream_genes <- c(
  # FAK/Src readouts
  "VIM", "FN1", "TNC", "ITGA5",
  # YAP/TAZ targets
  "POSTN", "ZEB1", "ZEB2",
  # SMAD / TGF-beta targets
  "TGFB1", "SERPINE1", "FN1"
)

DotPlot(Epithelial_cells_all,
        features = fn1_downstream_genes %>% unique(),
        group.by = "Annotation_detailed",
        split.by = "unique",
        #cols = "RdBu",
        dot.scale = 8,
        scale = F) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Expression in Epithelial Cells (Normal vs Tumor)")



prim <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_prim.qs") %>%
    subset(Ann_Level2 == "TAMs")

# run AUCell score using the downstream genes

entire_matrix <- prim@assays$RNA$counts

genelist <- downstream_genes

cell_ranks <-
    AUCell::AUCell_run(exprMat = entire_matrix,
                    geneSets = genelist)
prim$LAMB1 <- AUCell::getAUC(cell_ranks)[1,]

FeaturePlot(prim,
            features = "LAMB1",
            cols = c("#EEEEEE", "#ae0600"),
            min.cutoff = 0.15,
            pt.size = 1,
            order = TRUE) +
    coord_fixed()


mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs") %>%
    subset(Ann_Level2 == "TAMs")


combine <-
    merge(prim, mets) %>%
    JoinLayers() %>%
    process_seurat()
dimplot_better(combine, group_by = "unique")
VlnPlot(combine,
        group.by = "unique",
        #split.by = "Ann_Level3",
        ncol = 7,
        features = downstream_genes,
        pt.size = 0.1)

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
           pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))  
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))  
    
    }
    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # filter the pathways interested
    interested_pathways <-
        c("FN1", "LAMININ")

    pathways_LR_df_interested <-
        pathways_LR_df %>%
        filter(pathway_name %in% interested_pathways) %>%
        arrange(desc(prob))

    # identify the top downstream activated genes for each top ligand using nichenet
    top_ligands <-
        pathways_LR_df_interested %>%
        distinct(interaction_name) %>%
        separate(interaction_name, into = c("ligand", "receptor"), sep = "_") %>%
        distinct(ligand) %>%
        pull(ligand)

    top_targets <- list()
    for (lig in top_ligands) {
        if (lig %in% rownames(ligand_target_matrix)) {
            targets <-
                ligand_target_matrix[lig, ] %>%
                as.data.frame() %>%
                rownames_to_column("target") %>%
                rename(score = 2) %>%
                arrange(desc(score)) %>%
                head(20) %>%
                mutate(ligand = lig)
            top_targets[[lig]] <- targets

        }
    }


}













```



















## spatial nichenet

```{r spatial_nichenet_analysis}

average_spatial_leestat <- 
    read_tsv("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/spacexr/granular_references/lee_perms/average_lee_stats.tsv") 

not_correlated <-
    average_spatial_leestat %>%
    filter(group != "Correlated")

ggplot(data.frame(value = correlated$lee_stat), aes(x = value)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black") +
    ggtitle("Histogram of Correlated Lee Stat Values") +
    xlab("Lee Stat")


df_pairs <-
    average_spatial_leestat %>%
    rownames_to_column("Cell1") %>%
    pivot_longer(-Cell1, names_to = "Cell2", values_to = "LeeStat") %>%
    filter(Cell1 != Cell2)

# Select top 10% values
threshold <- quantile(df_pairs$LeeStat, 0.95)

top_pairs <- df_pairs %>% filter(LeeStat >= threshold)
high_cells <- top_pairs %>%
  gather(CellRole, Cell, Cell1:Cell2) %>%
  group_by(Cell) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))

# Option 1: Use a fixed LeeStat threshold (e.g., 0.1)
fixed_threshold <- 0.2
top_pairs_fixed <- df_pairs %>% filter(LeeStat >= fixed_threshold)
high_cells_fixed <- 
    top_pairs_fixed %>%
    gather(CellRole, Cell, Cell1:Cell2) %>%
    group_by(Cell) %>%
    summarise(Count = n()) %>%
    arrange(desc(Count))








# Example grouping (you can expand/modify)
pathway_groups <- list(
  ECM = c("COLLAGEN","FN1","LAMININ","TENASCIN","THBS","CADM","NCAM"),
  Angiogenesis = c("VEGF","PDGF","EPHA","PECAM1","NRG","FLRT","ANGPTL"),
  Immune = c("TGFb","MIF","APP","TWEAK","SEMA3","IGF","CXCL","CCL","IL1","TNF"),
  CellAdhesion = c("PTPRM","ICAM","JAM","NECTIN","UNC5","Netrin"),
  GrowthMetabolic = c("Cholesterol","Glutamate","DHEA","PTN","MK")
)

pathway_scores <- data.frame(
  Pathway = c("COLLAGEN","FN1","VEGF","TGFb","Cholesterol"),
  Human = c(0.8,0.7,0.9,0.6,0.3),
  Dog   = c(0.75,0.6,0.2,0.5,0.1),
  Mouse = c(0.5,0.4,0.1,0.2,0.05),
  PDX   = c(0.85,0.65,0.8,0.55,0.2)
)

library(dplyr)
library(tidyr)

aggregate_module <- function(scores_df, groups){
  long <- scores_df %>%
    pivot_longer(-Pathway, names_to="Dataset", values_to="Score") %>%
    mutate(Group = sapply(Pathway, function(p) {
      g <- names(groups)[sapply(groups, function(v) p %in% v)]
      if(length(g)) g[1] else "Other"
    }))
  
  module_summary <- long %>%
    group_by(Group, Dataset) %>%
    summarise(MeanScore = mean(Score, na.rm=TRUE), .groups="drop")
  
  return(module_summary)
}

module_summary <- aggregate_module(pathway_scores, pathway_groups)
print(module_summary)

# Spread to wide for correlations
module_wide <- module_summary %>%
  pivot_wider(names_from=Dataset, values_from=MeanScore)

# Spearman correlation of module patterns
cor_dog   <- cor(module_wide$Human, module_wide$Dog, method="spearman")
cor_mouse <- cor(module_wide$Human, module_wide$Mouse, method="spearman")
cor_pdx   <- cor(module_wide$Human, module_wide$PDX, method="spearman")

print(cor_dog); print(cor_mouse); print(cor_pdx)

library(ggplot2)

ggplot(module_summary, aes(x=Group, y=MeanScore, fill=Dataset)) +
  geom_bar(stat="identity", position="dodge") +
  theme_minimal(base_size=14) +
  ylab("Mean pathway score (aggregated)") +
  xlab("Functional Module") +
  ggtitle("Module-level pathway fidelity across species")


```



Using the all the target and LR interactions
```{r multi_sample_cellchat_analysis_sharedgenes_analysis}

average_pathways <- list()
module_pathways_list <- list()

site_specific_pathways <-
    list(prim = c("COLLAGEN", "LAMININ", "FN1", "APP", "MK",
                "SLIT", "THBS", "CADM", "NCAM", "PTPRM",
                "TGFb", "ADGRL", "PDGF", "VEGF", "MPZ",
                "FLRT", "PTN", "Cholesterol", "TENASCIN", "CDH",
                "MHC-II", "UNC5", "NRXN", "CXCL", "NRG",
                "EPHA", "Glutamate", "CCL"),
        mets = c("COLLAGEN", "LAMININ", "SLIT", "FN1", "ADGRL",
            "CADM", "NCAM", "PTPRM", "APP", "VEGF",
            "THBS", "Glutamate", "UNC5", "PDGF", "CDH",
            "EPHA", "TGFb", "FLRT", "MPZ", "MK",
            "Cholesterol", "PTN", "SEMA3", "PECAM1", "TENASCIN",
            "BMP", "ADGRG", "ICAM", "CCL", "ANNEXIN"))

# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    if (str_detect(group, "prim")) {
        pathways_of_interest <- site_specific_pathways$prim
    }  else if (str_detect(group, "mets")) {
        pathways_of_interest <- site_specific_pathways$mets
    }
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            arrange(desc(prob)) %>%
            select(source, target, pathway_name, prob) %>%
            filter(pathway_name %in% pathways_of_interest) %>%
            mutate(target_LR = paste0(source, "-to-", target, "-", pathway_name)) %>%
            select(target_LR, prob) %>%
            group_by(target_LR) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name) %>%
            ungroup()

        # save to list
        pathways_LR[[sample_name]] <- pathways_and_lr_prob
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        group_by(target_LR) %>%
        summarise(mean_prob = mean(prob)) %>%
        mutate(group = group) %>%
        select(group, target_LR, mean_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(target_LR)
    average_pathways[[group]] <- pathways_LR_df
}

## compare prim vs mets
# make a heatmap from the average pathways
All_cellchat <-
    do.call(rbind, average_pathways) %>%
    as_tibble() %>%
    as.data.frame() %>%
    arrange(desc(mean_prob))

# plots
for (site in c("prim", "mets")) {
    mean_cutoff <-
        All_cellchat %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        select(mean_prob) %>%
        summarise(mean = mean(mean_prob)) %>%
        pull(mean)

    site_specific <-
        All_cellchat %>%
        filter(str_detect(group, site)) %>%
        as.data.frame() %>%
        arrange(group, target_LR) %>%
        pivot_wider(names_from = group, values_from = mean_prob, values_fill = 0, id_cols = target_LR) %>%
        column_to_rownames("target_LR")
    cor_matrix <-
        cor(site_specific, use = "everything", method = "spearman")
    pheatmap::pheatmap(
        cor_matrix,
        cluster_rows = TRUE,
        cluster_cols = TRUE,
        color = colorRampPalette(c("#ffe0e0ff", "#fd3f3fff"))(100),
        main = str_c("Correlation Heatmap of Pathways - ", site, " Site"),
        fontsize_row = 8,
        fontsize_col = 10,
        display_numbers = round(cor_matrix, 2),
        number_color = "black"
    ) 

    # Alternative: pairwise scatterplots
    site_specific_GGPAIRS <-
        site_specific %>%
        rownames_to_column("pathways") %>%
        filter(pathways != "COLLAGEN") %>%
        column_to_rownames("pathways")
    library(GGally)
    GGally::ggpairs(
        site_specific_GGPAIRS,
        lower = list(continuous = wrap("points", alpha = 0.5)),
        upper = list(continuous = wrap("cor", size = 3)),
        diag = list(continuous = wrap("barDiag", fill = "lightblue")),
        title = str_c("Pairwise Pathway Correlations - ", site, " Site"),
        axisLabels = "show"
    )
}


```









Now using specific modules of pathways
```{r multi_sample_cellchat_analysis_sharedgenes_analysis_modules}

pathway_list_all <- list()
celltypes_receiver_all <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    pathway_list <- list()
    receiver_celltype_list <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        # pull the individual interactions without probabilities
        pathway_present <-
            subsetCommunication(cellchat,
                            slot.name = "net") %>%
            select(pathway_name) %>%
            distinct()
        pathway_list[[sample_name]] <- pathway_present
        # receiver cell types
        receiver_celltypes <-
            unique(cellchat@idents) %>% 
            as.vector()
        receiver_celltype_list[[sample_name]] <- receiver_celltypes
    }
    pathway_list_all[[group]] <- 
        do.call(rbind, pathway_list) %>%
        as_tibble() %>%
        as.data.frame() %>%
        select(pathway_name) %>%
        distinct() %>%
        mutate(group = group)
    
    celltypes_receiver_all[[group]] <-
        do.call(c, receiver_celltype_list) %>%
        unique() %>%
        as.vector() %>%
        sort()
}

# get the unique pathways across all samples
unique_pathways_all <-
    do.call(rbind, pathway_list_all) %>%
    as.tibble() %>%
    as.data.frame() %>%
    select(pathway_name) %>%
    distinct() %>%
    as.vector()
# get the unique receiver cell types across all samples
unique_receiver_celltypes_all <-
    do.call(c, celltypes_receiver_all) %>%
    unique() %>%
    as.vector() %>%
    sort()



# with 50 pathways, we can group them into functional modules
prim_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH",
                            "PECAM1", "ICAM", "SELL", "JAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "ANGPT"),
    Immune_Modulation = c("CXCL", "CCL", "IL1", "MHC-II"),
    Stemness          = c("BMP", "RA", "NRG"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate")
)

# Metastatic
mets_modules <- list(
    ECM_Remodelling   = c("COLLAGEN", "LAMININ", "FN1", "THBS", "TENASCIN", "TGFb"),
    Cell_Adhesion     = c("APP", "CADM", "PTPRM", "NCAM", "ADGRL", "ADGRG", "CDH", "PECAM1", "ICAM"),
    Angiogenesis      = c("VEGF", "PDGF", "MK", "PTN", "IGF", "FGF", "ANGPT"),
    Immune_Modulation = c("CXCL", "CCL", "IL1", "TNF", "CD80"),
    Stemness          = c("BMP", "RA"),
    Neuronal          = c("SLIT", "FLRT", "MPZ", "EPHA", "NRXN", "NEGR", "SEMA3", "UNC5"),
    Metabolic         = c("Cholesterol", "Glutamate", "DHEA")
)

Immune_Modulation_cells <- 
    c("Alv_Macrophages","TAMs","Monocytes","Neutrophils",
        "Mast","DC","T_cells","B_cells","NK_cells","ILCs",
        "Interactive")

# load the objects
All_pathways_and_Groups <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_sharedgenes/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR_per_group <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                                slot.name = "net") %>%
            select(target, prob, pathway_name, interaction_name, source) %>% 
            mutate(Target_LR = paste0(target, "-", interaction_name)) %>%
            select(Target_LR, pathway_name, prob) %>%
            group_by(Target_LR, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop")
            
        # filter out unwanted cell types Neutrophils|Smooth_muscle|
        pathways_and_lr_prob <-
            pathways_and_lr_prob %>%
                filter(!str_detect(Target_LR, "^(Chondrocytes|Mast|Osteoblasts|Stressed|Erythrocytes|Progenitor|MSC|Neuronal)-"))

        # save to list
        pathways_LR_per_group[[sample_name]] <- pathways_and_lr_prob
    }

    pathways_LR_df_group <-
        do.call(rbind, pathways_LR_per_group) %>%
        group_by(Target_LR, pathway_name) %>%
        summarise(mean_prob = mean(prob), .groups = "drop") %>%
        mutate(group = group) %>%
        as_tibble() %>%
        as.data.frame() 
    All_pathways_and_Groups[[group]] <- pathways_LR_df_group
}

# get the combined df
All_pathways_LR_combined <-
    do.call(rbind, All_pathways_and_Groups) %>%
    as_tibble() %>%
    as.data.frame()

# look at specific pathways
IL6_pathways <-
    All_pathways_LR_combined %>%
    filter(pathway_name == "CXCL") %>%
    filter(group %in% c("xeno_prim_cancer_normal", "xeno_mets_cancer_normal")) %>%
    arrange(desc(mean_prob))

#color for pathays in modules
module_colors <- c(
    ECM_Remodelling = "#D43F3AFF",
    Cell_Adhesion = "#EEA236FF",
    Angiogenesis = "#357EBDFF",
    Immune_Modulation = "#5CB85CFF",
    Stemness = "#90302DFF",
    Neuronal = "#9632B8FF",
    Metabolic = "#46B8DAFF"
)

# loop for primary and mets
for (site in c("prim", "mets")) {
    site_specific <-
        All_pathways_LR_combined %>%
        filter(str_detect(group, site)) %>%
        as_tibble() %>%
        filter(pathway_name %in% (if (site == "prim") unique(unlist(prim_modules)) 
                                  else unique(unlist(mets_modules)))) %>%
        as.data.frame() %>%
        pivot_wider(names_from = group,
                    values_from = mean_prob,
                    values_fill = 0,
                    id_cols = c(Target_LR, pathway_name)) %>%
        filter(if (site == "prim") patient_prim > 0 
               else patient_mets > 0) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        # Need to filter the immune modulation pathways to only include those with immune cell targets
        map(function(df) {
            if (df$pathway_name[1] == "CXCL" || df$pathway_name[1] == "CCL" || df$pathway_name[1] == "IL1" || df$pathway_name[1] == "MHC-II" || df$pathway_name[1] == "TNF" || df$pathway_name[1] == "CD80") {
                df %>% filter(str_detect(Target_LR, paste0("^(", paste(Immune_Modulation_cells, collapse = "|"), ")-")))
            } else {
                df
            }
        }) %>%
        # remove any dataframes that are less than 10 rows after filtering
        keep(~ nrow(.) >= 10) %>%
        # Calculate correlation for each group or pathway_name in xeno, mm, and dogs compared to patient
        map(function(df) {
            # Get the patient column (reference)
            patient_col <- grep("^patient_", colnames(df), value = TRUE)
            # Get comparison columns (xeno, mm, dogs)
            compare_cols <- grep("^(xeno|mm|dogs)_", colnames(df), value = TRUE)
            # For each comparison group, calculate Spearman correlation with patient
            cor_results <- lapply(compare_cols, function(col) {
                cor_val <- suppressWarnings(cor(df[[patient_col]], df[[col]], method = "spearman"))
                data.frame(
                    pathway_or_group = unique(df$pathway_name %||% df$Target_LR),
                    comparison_group = col,
                    correlation = if_else(is.na(cor_val), 0, cor_val)
                )
            })
            do.call(rbind, cor_results)
        }) %>%
        bind_rows()

    # plot the correlations
    plot_cooraltion_df <-
        site_specific %>%
        pivot_wider(names_from = comparison_group,
            values_from = correlation,
            values_fill = 0) %>%
        arrange(factor(pathway_or_group,
                    levels = if (site == "prim") unique(unlist(prim_modules)) 
                             else unique(unlist(mets_modules)))) %>%
        column_to_rownames("pathway_or_group") %>%
        rename(patient = starts_with("patient_"),
                PDX = starts_with("xeno_"),
                Mouse = starts_with("mm_"),
                Dogs = starts_with("dogs_")) %>%
                select(Dogs, Mouse, PDX) %>%
        as.matrix()

    # plot the heatmap 
    # describe the color for the values
    my_colors <- c("#4d9fe7ff", "#ffffff", "#eb433dff")
    my_breaks <- c(-1, -0.3, 0.3, 1)
    my_values <- scales::rescale(my_breaks, from = c(-1, 1))
    # Map pathway_name to module and color
    module_map <- if (site == "prim") prim_modules else mets_modules
    module_color_df <- tibble(
        pathway_name = unlist(module_map),
        module = rep(names(module_map), lengths(module_map)),
        color = unname(module_colors[rep(names(module_map), lengths(module_map))])
    )

    # Prepare data for plotting
    plot_cooraltion_df_df <- as.data.frame(as.table(plot_cooraltion_df))
    plot_cooraltion_df_df$module <- module_color_df$module[match(plot_cooraltion_df_df$Var1, module_color_df$pathway_name)]
    plot_cooraltion_df_df$color <- module_color_df$color[match(plot_cooraltion_df_df$Var1, module_color_df$pathway_name)]

    # Colored y-axis labels
    pathway_label_colors <- module_color_df$color
    names(pathway_label_colors) <- module_color_df$pathway_name
    y_labels_colored <- sapply(
        rownames(plot_cooraltion_df),
        function(lab) {
            col <- pathway_label_colors[lab]
            if (is.na(col)) col <- "#000000"
            sprintf("<span style='color:%s'>%s</span>", col, lab)
        }
    )

    heatmap_LR <- 
        ggplot(plot_cooraltion_df_df, 
            aes(x = Var2, y = factor(Var1, levels = rev(rownames(plot_cooraltion_df))), fill = Freq)) +
            geom_tile(color = "white", linewidth = 0.5) +
            geom_text(aes(label = sprintf("%.2f", Freq)), size = 5, color = "black") +
            scale_fill_gradientn(colours = my_colors,
                                values = my_values,
                                limits = c(-1, 1),
                                name = "Spearman\nCorrelation",
                                guide = guide_colorbar(barwidth = 1, barheight = 15,
                                                      frame.colour = "black", ticks.colour = "black")) +
            labs(x = "Comparison Group",
                y = "Pathway",
                title = str_c("Correlation Heatmap of Pathways - ", site, " Site")) +
            theme_minimal(base_size = 15) +
            theme(axis.text.x = element_text(size = 15),
                axis.text.y = ggtext::element_markdown(size = 15),
                axis.title = element_text(size = 15),
                plot.title = element_text(size = 15, hjust = 0.5),
                legend.title = element_text(size = 15),
                legend.text = element_text(size = 15),
                panel.grid = element_blank(),
                panel.border = element_rect(color = "black", fill = NA, linewidth = 1)) +
            guides(fill = guide_colorbar(barwidth = 1, barheight = 15)) +
            scale_y_discrete(labels = y_labels_colored) +
            geom_point(data = module_color_df %>% distinct(module, color),
                aes(x = 1, y = -Inf, color = module),
                size = 5, shape = 15, inherit.aes = FALSE, show.legend = TRUE) +
            scale_color_manual(name = "Pathway Module",
                values = setNames(module_colors, names(module_colors)),
                guide = guide_legend(override.aes = list(size = 5, shape = 15),
                                    order = 1,
                                    title.position = "top",
                                    title.hjust = 0.5,
                                    label.position = "right",
                                    label.hjust = 0),
                breaks = names(module_colors),
                labels = names(module_colors)) +
            theme(legend.position = "right",
                 legend.box = "vertical",
                 legend.box.just = "left")

    ggsave(str_c("output/figures/cellchat/sharedgenes_modules/correlation_heatmap_pathways_",
                site, ".png"),
            heatmap_LR,
            width = 7,
            height = 12,
            bg = "white")
}





```








## matts permutation
```{r matt_permutation_cellchat_analysis}
run_cellchat <- function(sobject,
                        group.by="celltype",
                        species_db="human") {
    data.input <- 
        GetAssayData(sobject, assay="RNA", slot="data")  # log-normalized
    meta <- 
        data.frame(labels = sample(sobject[[group.by]][,1]), row.names=colnames(sobject))
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
    cellchat@DB <- if (species_db=="human") CellChatDB.human else CellChatDB.mouse
    future::plan("multisession", workers = 10) # do parallel
    cellchat <- 
        subsetData(cellchat) %>%
        identifyOverExpressedGenes() %>%
        identifyOverExpressedInteractions() %>%
        computeCommunProb() %>%
        filterCommunication(min.cells = 10) %>%
        computeCommunProbPathway() %>%
        aggregateNet() %>%
        netAnalysis_computeCentrality()
  return(cellchat)
}

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim",
                # "patient_mets",
                # "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects_permutation/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat_perm <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if(dir.exists(str_c("output/cellchat_objects_permutation/", group))==FALSE){
                dir.create(str_c("output/cellchat_objects_permutation/", group), recursive = TRUE)
            }
            qs::qsave(cellchat_perm, str_c("output/cellchat_objects_permutation/", group, "/", sample, "_AnnL2_whole", ".qs"))  
        }
    }
}


for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects_permutation/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR_per_group <- list()
    hist_list <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                                slot.name = "net") %>%
            mutate(sample = sample_name)
        hist_p <- 
            ggplot(pathways_and_lr_prob, aes(x = prob)) +
                geom_histogram(bins = 50, fill = "skyblue", color = "black") +
                labs(title = sample_name, x = "Interaction Probability", y = "Count") +
                theme_minimal() 
        hist_list[[sample_name]] <- hist_p
        # save to list
        pathways_LR_per_group[[sample_name]] <- pathways_and_lr_prob
    }

    pathways_LR_df_group <-
        do.call(rbind, pathways_LR_per_group) 

    pathways_LR_df_group %>%
        ggplot(aes(x = prob)) +
        geom_histogram(bins = 50, fill = "skyblue", color = "black") +
        facet_wrap(~ sample, ncol = 5, scales = "free_y")

    hist(pathways_LR_df_group$prob, breaks=50)
    
    All_pathways_and_Groups[[group]] <- pathways_LR_df_group
}

# plot the histogram of probabilities
all_probs <-
    patchwork::wrap_plots(hist_list, ncol=7) +
    plot_annotation(title ="PMets CellChat Interaction Probabilities",
                    theme = theme(plot.title = element_text(size = 20, hjust = 0.5)))

```