

## Run Nichenet and other analyses

```{r cell_cell_communication}
object_list <-
    tribble(~group1,                         ~group2,                       ~group3,
            "xeno_prim_mouse",              "xeno_prim_human_cancer_cells", "xeno_prim_cancer_normal",
            "xeno_mets_mouse",              "xeno_mets_human_cancer_cells", "xeno_mets_cancer_normal"
            )

# conver the xeno mouse stroma into human symbols
for (i in 1:nrow(object_list)) {
    group1 <- object_list$group1[i]
    group2 <- object_list$group2[i]
    group3 <- object_list$group3[i]
    object1 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group1,
                        ".qs"))
    raw_counts <-
        GetAssayData(object1,
                     slot = "counts")

    human_genes <-
        object1 %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object1@meta.data)
    object1 <-
        new_seurat_object %>%
        process_seurat()

    object2 <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group2,
                        ".qs"))
    combined_object <-
        merge(object1, object2) %>%
        JoinLayers() %>%
        process_seurat() %>%
        RunHarmony(group.by.vars = c("sample_name", "model"),
                    theta = c(12, 12),
                    lambda = c(0.1, 0.1)) %>%
        process_seurat(reduction = "harmony")

    combined_object$organism <- "human"
    combined_object$unique <- group3

    qs::qsave(combined_object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group3,
                    ".qs"))
}

# convert dog to human symbols
orthologs <-
    read_tsv("input/downloads/dog_human_gene_orthologs.txt")
for (group in c("dogs_prim",
                "dogs_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")

    number_of_ENSEMBL_genes <-
        sum(str_detect(rownames(raw_counts), "^ENSCAFG"))

    raw_counts_new <-
        raw_counts[rownames(raw_counts) %in% orthologs$dog_gene_name, ]
    rownames(raw_counts_new) <-
        orthologs$human_gene_ortholog[match(rownames(raw_counts_new), orthologs$dog_gene_name)]
    new_seurat_object <-
        CreateSeuratObject(counts = raw_counts_new) %>%
        AddMetaData(metadata = object@meta.data)
    newobject <-
        new_seurat_object %>%
        process_seurat()
    newobject$organism <- "human"
    qs::qsave(newobject,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

for (group in c("mm_prim",
                "mm_mets")) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    raw_counts <-
        GetAssayData(object,
                     slot = "counts")
    human_genes <-
        object %>%
        rownames() %>%
        nichenetr::convert_mouse_to_human_symbols() %>%
        as.character()
    new_raw_counts <- raw_counts
    rownames(new_raw_counts) <- human_genes
    new_raw_counts <-
        new_raw_counts[!is.na(rownames(new_raw_counts)), ]
    new_raw_counts <-
        new_raw_counts[!duplicated(rownames(new_raw_counts)), ]
    new_seurat_object <-
        CreateSeuratObject(counts = new_raw_counts) %>%
        AddMetaData(metadata = object@meta.data)
    object <-
        new_seurat_object %>%
        process_seurat()
    
    object$organism <- "human"
    qs::qsave(object,
              str_c("output/seurat_objects/final_tumor_vs_stroma/",
                    group,
                    "human_ortho.qs"))

}

# function for cellchat function
suppressPackageStartupMessages({
  library(CellChat); library(patchwork)
})
run_cellchat <- function(sobject,
                        group.by="celltype",
                        species_db="human") {
    data.input <- GetAssayData(sobject, assay="RNA", slot="data")  # log-normalized
    meta <- data.frame(labels = sobject[[group.by]][,1], row.names=colnames(sobject))
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
    cellchat@DB <- if (species_db=="human") CellChatDB.human else CellChatDB.mouse
    future::plan("multisession", workers = 10) # do parallel
    cellchat <- 
        subsetData(cellchat) %>%
        identifyOverExpressedGenes() %>%
        identifyOverExpressedInteractions() %>%
        computeCommunProb() %>%
        filterCommunication(min.cells = 10) %>%
        computeCommunProbPathway() %>%
        aggregateNet() %>%
        netAnalysis_computeCentrality()
        # computeNetSimilarity(type = "functional") %>%
        # netEmbedding(type = "functional") %>%
        # netClustering(type = "functional", do.parallel = FALSE) %>%
        # computeNetSimilarity(type = "structural") %>%
        # netEmbedding(type = "structural") %>%
        # netClustering(type = "structural", do.parallel = FALSE)
  return(cellchat)
}

# ann_level2 sample by sample

# cellchat at ann_level3 using all the pathways general
for (group in c(
                # "patient_prim",
                "patient_mets"
                # "mm_prim",
                # "mm_mets",
                # "xeno_prim_cancer_normal",
                # "xeno_mets_cancer_normal"
                # "dogs_primhuman_ortho",
                # "dogs_metshuman_ortho"
                # "mm_primhuman_ortho",
                # "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    for (sample in unique(object$sample_name)){
        if (!file.exists(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))) {
            sub_object <- subset(object, sample_name == sample)
            # Subset to max 500 cells per celltype (Ann_Level2)
            celltype_counts <- table(sub_object$Ann_Level3)
            sub_object <- SetIdent(sub_object, value = "Ann_Level3")
            cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
                ct_cells <- WhichCells(sub_object, idents = ct)
                if (length(ct_cells) > 100) {
                    sample(ct_cells, 100)
                } else {
                    ct_cells
                }
            }))
            sub_object <- 
                subset(object, cells = cells_to_keep)
            
            cellchat <-
                run_cellchat(sobject = sub_object,
                            group.by="Ann_Level2",
                            species_db=sub_object$organism[1])
            if (!dir.exists(str_c("output/cellchat_objects", "/", group))) {
                dir.create(str_c("output/cellchat_objects", "/", group),
                            recursive = TRUE)
            }
            qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs"))
        } else {
            print(str_c("output/cellchat_objects/", group, "/", sample, "_AnnL2_whole", ".qs already exists"))
        }
    }
}



# cellchat at ann_level3 using all the pathways general
for (group in c(
                "patient_prim",
                "patient_mets",
                "mm_prim",
                "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    # Subset to max 500 cells per celltype (Ann_Level2)
    celltype_counts <- table(object$Ann_Level3)
    object <- SetIdent(object, value = "Ann_Level3")
    cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
        ct_cells <- WhichCells(object, idents = ct)
        if (length(ct_cells) > 500) {
            sample(ct_cells, 500)
        } else {
            ct_cells
        }
    }))
    object <- 
        subset(object, cells = cells_to_keep)
    
    cellchat <-
        run_cellchat(sobject = object,
                     group.by="Ann_Level2",
                     species_db=object$organism[1])
    qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))
}

# cellchat at ann_level3 using all the pathways general
for (group in c(
                "patient_prim",
                "patient_mets",
                "mm_prim",
                "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    # Subset to max 500 cells per celltype (Ann_Level2)
    celltype_counts <- table(object$Ann_Level3)
    object <- SetIdent(object, value = "Ann_Level3")
    cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
        ct_cells <- WhichCells(object, idents = ct)
        if (length(ct_cells) > 500) {
            sample(ct_cells, 500)
        } else {
            ct_cells
        }
    }))
    object <- 
        subset(object, cells = cells_to_keep)
                                
    cellchat <-
        run_cellchat(sobject = object,
                     group.by="Ann_Level3",
                     species_db=object$organism[1])

    # save the cellchat object
    if (!dir.exists("output/cellchat_objects")) {
        dir.create("output/cellchat_objects")
    }
    qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_everything", ".qs"))
}


## for whole object at ann levele using the specific pathways
for (group in c(
                "patient_prim",
                "patient_mets",
                "mm_prim",
                "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))
    # Subset to max 500 cells per celltype (Ann_Level2)
    celltype_counts <- table(object$Ann_Level3)
    object <- SetIdent(object, value = "Ann_Level3")
    cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
        ct_cells <- WhichCells(object, idents = ct)
        if (length(ct_cells) > 500) {
            sample(ct_cells, 500)
        } else {
            ct_cells
        }
    }))
    object <- 
        subset(object, cells = cells_to_keep)
                                
    data.input <-
        GetAssayData(object,
                    assay = "RNA",
                    slot = "data") 
    labels <- object$Ann_Level2
    meta <- 
        data.frame(group = labels,
                    row.names = names(labels)) 
    cellchat <- 
        createCellChat(object = data.input,
                        meta = meta,
                        group.by = "group")

    # Load the ligand-receptor interaction database
    CellChatDB <- 
        if (object$organism[1] == "human") CellChatDB.human else CellChatDB.mouse

    # Set a subset of CellChatDB if interested in specific signaling pathways
    for (subset_db in c("Secreted Signaling", "ECM-Receptor", "Cell-Cell Contact")) {
        CellChatDB.use <- 
            subsetDB(CellChatDB, search = subset_db)
        # whatever you deice to use
        cellchat@DB <- CellChatDB.use
        
        # 3.Subset and pre-processing the expression data 
        # subset the expression data to use less RAM
        future::plan("multisession", workers = 5) # do parallel
        cellchat <-
            subsetData(cellchat) %>%
            identifyOverExpressedGenes() %>%
            identifyOverExpressedInteractions() %>%
            computeCommunProb() %>%
            filterCommunication(min.cells = 10) %>%
            computeCommunProbPathway() %>%
            aggregateNet() %>%
            netAnalysis_computeCentrality() %>%
            computeNetSimilarity(type = "functional") %>%
            netEmbedding(type = "functional") %>%
            netClustering(type = "functional", do.parallel = FALSE) %>%
            computeNetSimilarity(type = "structural") %>%
            netEmbedding(type = "structural") %>%
            netClustering(type = "structural", do.parallel = FALSE)

        # save the cellchat object
        if (!dir.exists("output/cellchat_objects")) {
            dir.create("output/cellchat_objects")
        }
        subset_db_name <- gsub(" ", "_", subset_db)
        qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_", subset_db_name, ".qs"))
    }
}


# for just TAMs and tumors
for (group in c(
                "patient_prim",
                "patient_mets",
                "mm_prim",
                "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal"
            )) {
    object <-
        qs::qread(str_c("output/seurat_objects/final_tumor_vs_stroma/",
                        group,
                        ".qs"))

    celltypes <- 
        c("MP_Progenitor", "Fibrogenic", "Interactive", "Basal_Progenitor",
        "Proliferative", "COMA", "Scar_TAMs", "Osteoclast_TAMs", "Prolif_TAMs",
        "IFN_TAMs", "Fibrogenic_TAMs", "Inflam_TAMs","TAMs")
    #subset just TAMs and tumor cells
    object <- 
        subset(object, Ann_Level3 %in% celltypes)
    # Subset to max 500 cells per celltype (Ann_Level3)
    celltype_counts <- table(object$Ann_Level3)
    object <- SetIdent(object, value = "Ann_Level3")
    cells_to_keep <- unlist(lapply(names(celltype_counts), function(ct) {
        ct_cells <- WhichCells(object, idents = ct)
        if (length(ct_cells) > 500) {
            sample(ct_cells, 500)
        } else {
            ct_cells
        }
    }))
    object <- 
        subset(object, cells = cells_to_keep)
                                
    data.input <-
        GetAssayData(object,
                    assay = "RNA",
                    slot = "data")
    labels <- object$Ann_Level3
    meta <- 
        data.frame(group = labels,
                    row.names = names(labels)) 
    cellchat <- 
        createCellChat(object = data.input,
                        meta = meta,
                        group.by = "group")

    # Load the ligand-receptor interaction database
    CellChatDB <- 
        if (object$organism[1] == "human") CellChatDB.human else CellChatDB.mouse

    # Set a subset of CellChatDB if interested in specific signaling pathways
    for (subset_db in c("Secreted Signaling", "ECM-Receptor", "Cell-Cell Contact")) {
        CellChatDB.use <- 
            subsetDB(CellChatDB, search = subset_db)
        # whatever you deice to use
        cellchat@DB <- CellChatDB.use
        
        # 3.Subset and pre-processing the expression data 
        # subset the expression data to use less RAM
        future::plan("multisession", workers = 5) # do parallel
        cellchat <- subsetData(cellchat) %>%
            identifyOverExpressedGenes() %>%
            identifyOverExpressedInteractions() %>%
            computeCommunProb() %>%
            filterCommunication(min.cells = 10) %>%
            computeCommunProbPathway() %>%
            aggregateNet() %>%
            netAnalysis_computeCentrality() %>%
            computeNetSimilarity(type = "functional") %>%
            netEmbedding(type = "functional") %>%
            netClustering(type = "functional", do.parallel = FALSE) %>%
            computeNetSimilarity(type = "structural") %>%
            netEmbedding(type = "structural") %>%
            netClustering(type = "structural", do.parallel = FALSE)
        # save the cellchat object
        if (!dir.exists("output/TAMs_Tumor_cellchat_objects")) {
            dir.create("output/TAMs_Tumor_cellchat_objects")
        }
        subset_db_name <- gsub(" ", "_", subset_db)
        qs::qsave(cellchat, str_c("output/TAMs_Tumor_cellchat_objects/", group, "_", subset_db_name, ".qs"))
    }
}

```


### Plotting for cellchat


```{r cellchat_plots}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

    object_list[[group]] <- cellchat

    # 8. visualize the aggregated cell-cell communication network
    groupSize <- as.numeric(table(cellchat@idents))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
        dir.create(str_c("output/figures/cellchat/", group),
                    recursive = TRUE)
    }
    p1 <- netVisual_circle(cellchat@net$count,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Number of interactions")
    p2 <- netVisual_circle(cellchat@net$weight,
                            vertex.weight = groupSize, 
                            weight.scale = TRUE,
                            label.edge = FALSE,
                            title.name = "Interaction weights/strength")
    combined_plot <- 
        plot_grid(p1, p2, ncol = 1) +
        patchwork::plot_annotation(title = stringr::str_c(group," everything "))
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.pdf"),
        combined_plot,
        width = 15,
        height = 30
    )
    ggsave(str_c("output/figures/cellchat/", group, "/", "everything_circle_plots.png"),
        combined_plot,
        width = 15,
        height = 30
    )
    #  examine the signaling sent from each cell group
    mat <- cellchat@net$weight
    plot_list1 <- list()
    for (i in 1:nrow(mat)) {
        mat2 <- 
            matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))
        mat2[i, ] <- mat[i, ]
        plot_list1[[i]] <-
            netVisual_circle(mat2, 
                                vertex.weight = groupSize,
                                weight.scale = F, 
                            edge.weight.max = max(mat),
                            title.name = rownames(mat)[i]) 
    }
    combined_plot1 <- 
        plot_grid(plotlist = plot_list1, ncol = 3) +
        patchwork::plot_annotation(title = stringr::str_c(group," ", subset_db))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "outgoing_signaling.png"),
        combined_plot1,
        width = 21,
        height = 7 * length(plot_list1)/3
    )

    future::plan("multisession", workers = 10) # do parallel
    # 9. Identify the signaling roles of cell
    cellchat@netP[["pathways"]]
    # rank the pathways 
    ranked_pathways <-
        rankNet(cellchat, mode="single")
    ggsave(str_c("output/figures/cellchat/", group, "/everything_ranked_pathways.png"),
        ranked_pathways,
        width = 10,
        height = 15
    )
    # reveal all the ligand-receptor pairs for a signaling pathway
    extractEnrichedLR(cellchat, signaling = c(cellchat@netP[["pathways"]]),
                    geneLR.return = TRUE)

    # visualize the contribution of each LR pairs to the communication network
    netAnalysis_contribution(cellchat, 
                            signaling = c(cellchat@netP[["pathways"]]), 
                            title = "Contribution of each LR pairs")
    # visualize the contribution of each LR pairs to the communication network top5
    top5_ligand_receptor_pairs <-
        netAnalysis_contribution(cellchat, 
                                signaling = c(cellchat@netP[["pathways"]][1]))
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db, "top5_ligand_receptor_pairs.png"),
        top5_ligand_receptor_pairs,
        width = 10,
        height = 15
    )
    # 10. Visualize cell-cell communication mediated by specific signaling pathways
    extractEnrichedLR(cellchat, signaling = "COLLAGEN", geneLR.return = FALSE)
    netAnalysis_contribution(cellchat, signaling = "COLLAGEN")

    # Circle plot
    netVisual_aggregate(cellchat, signaling = "COLLAGEN", layout = "circle")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1")

    # Arrange so that tumor are on one side in the chord diagram
    # Define group.cellType so that tumor cell types are grouped together
    # Example: assign "Tumor" to tumor clusters, others as before
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive", "Stressed")
    other_clusters <- setdiff(levels(cellchat@idents), tumor_clusters)

    group.cellType <- c(
        rep("Tumor", length(tumor_clusters)),
        rep("Other", length(other_clusters)))
    names(group.cellType) <- c(tumor_clusters, other_clusters)

    chord_plot <-
        netVisual_chord_cell(cellchat, signaling = "COLLAGEN", 
            group = group.cellType, 
            title.name = paste0("COLLAGEN_", "signaling network"))

    # Chord diagram: define source and target cell types
    netVisual_chord_gene(cellchat, sources.use = 4, targets.use = c(5:6), 
                        lab.cex = 0.5,legend.pos.y = 30)

    netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4), targets.use = 8,
                        lab.cex = 0.5, legend.pos.x = 15)

    # Chord diagram: show LR pairs associated with certain signaling pathways
    netVisual_chord_gene(cellchat,
                         sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c("TAMs"),
                        signaling = c("COLLAGEN"),legend.pos.x = 8)

    # Hierarchy plot 
    # Define tumor clusters as vertex.receiver for hierarchy plot
    tumor_clusters <- c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                        "COMA", "Fibrogenic", "Interactive")
    vertex.receiver <- which(levels(cellchat@idents) %in% tumor_clusters)

    netVisual_aggregate(cellchat, signaling = "COLLAGEN", 
                        vertex.receiver = vertex.receiver, layout = "hierarchy")
    netVisual_individual(cellchat, signaling = "COLLAGEN", 
                        pairLR.use = "COL1A1_ITGA1_ITGB1", 
                        vertex.receiver = vertex.receiver, 
                        layout = "hierarchy")

    # Heatmap for sender receiver pairs for a specific signaling pathway
    netVisual_heatmap(cellchat, signaling = "COLLAGEN", color.heatmap = "Reds")

    # bubble plot 
    # bubble plot: show all LR pairs from source to target cell groups
    netVisual_bubble(cellchat, sources.use = c("Basal_Progenitor", "Proliferative", "MP_Progenitor",
                                        "COMA", "Fibrogenic", "Interactive", "Stressed"),
                        targets.use = c(1:10), 
                    remove.isolate = FALSE) 

    # bubble plot: show LR pairs associated with certain signaling pathways
    netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:12), 
                    signaling = c("COLLAGEN"), remove.isolate = FALSE)
                
    # 1. Compute the network centrality scores
    cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP")

    # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- netAnalysis_signalingRole_scatter(cellchat) + coord_fixed()
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_aggregated_network.png"),
        aggregated_network,
        width = 7,
        height = 7
    )

    # Scatter plot to Visualize selected communication networks
    netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    # Heatmap to visualize dominant cell types for each signaling pathway
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing", height = 11)
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming", height = 11)

    # Visualize selected outgoing/incoming signals and contributing cell types
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing",
                                        signaling = c("COLLAGEN"))
    netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming",
                                        signaling = c("COLLAGEN"))

    # Heatmap to visualize major signaling roles of different cell groups
    netAnalysis_signalingRole_network(cellchat, signaling = "FN1", width = 10, 
                                    height = 5, font.size = 10)

    # 2. Identify global communication patterns to explore how multiple cell types 
    # and signaling pathways coordinate
    # Identify and visualize outgoing communication pattern of secreting cells
    selectK(cellchat, pattern = "outgoing") # infer the number of patterns, NMF
    nPatterns = 4 # a suitable number of patterns is the one begin to drop suddenly.
    cellchat <- identifyCommunicationPatterns(cellchat, pattern = "outgoing",
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "outgoing") # river plot
    netAnalysis_dot(cellchat, pattern = "outgoing") # dot plot

    ## Identify and visualize incoming communication pattern of target cells
    selectK(cellchat, pattern = "incoming")
    nPatterns = 4
    cellchat <- identifyCommunicationPatterns(cellchat,pattern = "incoming", 
                    k = nPatterns, width = 5, height = 9)

    netAnalysis_river(cellchat, pattern = "incoming") # river plot
    netAnalysis_dot(cellchat, pattern = "incoming") # dot plot

    # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)

    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "functional", nCol = 2)

    # Identify signaling groups based on structure similarity
    # multimeric ligand-receptor complexes, soluble agonists and antagonists, 
    # stimulatory and inhibitory co-ligands and co-receptors
    cellchat <- computeNetSimilarity(cellchat, type = "structural")
    cellchat <- netEmbedding(cellchat, type = "structural")
    cellchat <- netClustering(cellchat, type = "structural",do.parallel = FALSE)

    # Visualization in 2D-space
    structural_gene_groups <-
        netVisual_embedding(cellchat, type = "structural", label.size = 3.5)
    ggsave(str_c("output/figures/cellchat/", group, "/", subset_db_name, "_structural_gene_groups.png"),
        structural_gene_groups,
        width = 7,
        height = 7
    )
    netVisual_embeddingZoomIn(cellchat, type = "structural", nCol = 2)
}



object_list <- list()
collagen_bubble <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))

     # Scatter plot to visualize aggregated communication networks for each cell type, with repelled labels
    aggregated_network <- 
        netAnalysis_signalingRole_scatter(cellchat) +
        coord_fixed() +
        ggtitle(str_c(group," aggregated network"))
    if (!dir.exists(str_c("output/figures/cellchat/", group))) {
    dir.create(str_c("output/figures/cellchat/", group),
                recursive = TRUE)
    }
    ggsave(str_c("output/figures/cellchat/", group, "/", "ann2_aggregated_network.png"),
        aggregated_network,
        width = 10,
        height = 10)

    # Visualize selected outgoing/incoming signals and contributing cell types
        # Scatter plot to Visualize selected communication networks
    collagen_bubble[[group]] <-
        netAnalysis_signalingRole_scatter(cellchat, signaling = "COLLAGEN")

    ggsave(str_c("output/figures/cellchat/", group, "/", "collagen_bubble.png"),
        collagen_bubble[[group]],
        width = 10,
        height = 10)
    
     # 3. Groups signaling pathways based on their functional/structural similarities
    # Identify signaling groups based on functional similarity
    cellchat <- computeNetSimilarity(cellchat, type = "functional")
    cellchat <- netEmbedding(cellchat, type = "functional")
    cellchat <- netClustering (cellchat, type = "functional", do.parallel = FALSE)
    # Visualization in 2D-space based on the functional similarity
    functional_gene_groups <-
        netVisual_embedding(cellchat, type = "functional", label.size = 3.5) +
        ggtitle(str_c(group," functional gene groups"))
    ggsave(str_c("output/figures/cellchat/", group, "/", "functional_gene_groups.png"),
        functional_gene_groups,
        width = 7,
        height = 7
    )

    png(filename = str_c("output/figures/cellchat/", group, "/", "collagen_network_heatmap.png"),
        width = 1000, height = 500, res = 300)
    netAnalysis_signalingRole_network(cellchat, signaling = "COLLAGEN", width = 10, height = 5, font.size = 10)

    dev.off()
}

```


## comparative cellchat analysis

```{r cellchat_comparative analysis}

# plot for the cellchat objects
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))
    
    # qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs")) 

    object_list[[group]] <- cellchat
            }

# rank the pathways and compare across groups
rankNet(object_list$mm_metshuman_ortho, mode="single")
rankNet(mergeCellChat(list(object_list$patient_prim,
                            object_list$mm_primhuman_ortho),
        add.names=c("patient","xeno")),
        mode="comparison",
        stacked = TRUE)
rankNet(mergeCellChat(list(object_list$mm_primhuman_ortho,
                            object_list$mm_metshuman_ortho),
        add.names=c("patient","xeno", "dog")),
        mode="comparison",
        stacked = FALSE)

get_pathway_flow <- function(cc,
                             dataset_name) {
    flows <- 
        apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE))
    data.frame(pathway = names(flows),
            information_flow = as.numeric(flows),
            dataset = dataset_name,
            stringsAsFactors = FALSE)
}

# Collect all datasets and perform PCA for each dataset
df_list <- 
    Map(get_pathway_flow, object_list,
    names(object_list))
df_all <-
    do.call(rbind, df_list) %>%
    as_tibble() %>%
    as.data.frame()
# Pivot to wide format: rows = pathway, columns = dataset, values = information_flow
df_wide <- df_all %>%
    select(pathway, dataset, information_flow) %>%
    tidyr::pivot_wider(names_from = dataset,
                        values_from = information_flow,
                        values_fill = 0)
# Set rownames to pathway and remove pathway column
mat_t <- 
    as.data.frame(df_wide) %>%
    column_to_rownames("pathway") %>%
    t()

# Scale and run PCA
pca_res <- prcomp(mat_t, scale. = TRUE)

# PCA plot: one dot per group (dataset)
pca_df <- as.data.frame(pca_res$x)
pca_df$group <- rownames(pca_df)

library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, label = group)) +
    geom_point(size = 3) +
    geom_text(vjust = -0.5, size = 3) +
    labs(title = "PCA of Pathway Information Flow (one dot per group)",
            x = "PC1", y = "PC2") +
    theme_minimal()

# the pathways that drive the differences between groups
loading_scores_df <-
    pca_res$rotation %>%
    as.data.frame() %>%
    rownames_to_column("pathway")



# Function to compare pathways between two CellChat objects (e.g. primary vs. mets)
compare_pathways <- function(cc_primary,
                            cc_mets) {
                        
    info_primary <- 
        cc_primary@netP$pathways %>% 
        data.frame(pathway = .,
                flow = apply(cc_primary@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    info_mets <- 
        cc_mets@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc_mets@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))

    merged <- 
        merge(info_primary, info_mets, by="pathway", suffixes = c("_prim", "_mets"))
    merged$diff_mets_up <- merged$flow_mets - merged$flow_prim
    merged$diff_prim_up <- merged$flow_prim - merged$flow_mets

    merged
}

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    patient_diff <-
        compare_pathways(cc_primary = object_list[[group_prim]],
                        cc_mets = object_list[[group_mets]])

    # Sort and visualize
    # Top 10 pathways enriched in mets (mets > primary)
    top_diff_mets_up <-
        head(patient_diff[order(-patient_diff$diff_mets_up), ], 10)

    # Top 10 pathways enriched in primary (primary > mets)
    top_diff_prim_up <-
        head(patient_diff[order(-patient_diff$diff_prim_up), ], 10)

    # Barplot of top pathways enriched in mets (mets > primary)
    top_diff_mets_up$group <- "Metastasis"
    # Barplot of top pathways enriched in primary (primary > mets)
    top_diff_prim_up$group <- "Primary"

    # Combine top pathways for plotting
    top_diff_combined <- rbind(
        top_diff_mets_up %>% dplyr::select(pathway, flow_mets, flow_prim, group),
        top_diff_prim_up %>% dplyr::select(pathway,  flow_mets, flow_prim, group))

    # Reshape to long format for ggplot
    top_diff_long <-
        top_diff_combined %>%
        tidyr::pivot_longer(cols = c(flow_prim, flow_mets),
                            names_to = "condition",
                            values_to = "information_flow") %>%
        mutate(condition = ifelse(condition == "flow_prim", "Primary", "Metastasis")) %>%
        arrange(desc(group), information_flow) %>%
        mutate(pathway = factor(pathway, levels = unique(pathway)))

    ggplot(top_diff_long,
                    aes(x = information_flow, y = pathway,
                            fill = condition)) +
        geom_bar(stat = "identity", position = "dodge") +
        labs(title = "Top 10 Differential Pathways: Metastasis vs. Primary",
                x = "Information Flow", y = "Pathway") +
        scale_fill_manual(values = c("Metastasis" = "#E41A1C", "Primary" = "#377EB8")) +
        theme_minimal()

    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "_top_diff_pathways.png"),
        width = 10,
        height = 10,
        bg = "white"
    )
}



# look at top five pathways for everything
pathways_list <- list()

for (item in names(object_list)) {
    cc <- object_list[[item]]
    top_pathways <-
        cc@netP$pathways %>%
        data.frame(pathway = .,
                flow = apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    top5 <-
        head(top_pathways[order(-top_pathways$flow), ], 5) %>%
        mutate(group = item)

    pathways_list[[item]] <- top5
}

pathwys_df <-
    do.call(rbind, pathways_list) %>%
    as_tibble() %>%
    as.data.frame()

# Define plot_cols as a named vector, e.g.:
# plot_cols <- c("patient_prim"="#1f77b4", "patient_mets"="#ff7f0e", ...)
top5_all <-
    ggplot(pathwys_df,
    aes(x = flow, y = pathway, fill = group)) +
    geom_bar(stat = "identity",position = position_dodge(preserve = "single", width = 0.8), width = 0.7) +
    labs(title = "Top 5 Pathways per Group",
        x = "Information Flow", y = "Pathway") +
    scale_fill_manual(values = plot_cols) +
    theme_minimal()

ggsave("output/figures/cellchat/top5_pathways_all.png",
    top5_all,
    width = 10,
    height = 10,
    bg = "white"
)


cell_cols <- list(
    "Tumor" = "#D43F3AFF",           "Normal" = "#EEA236FF",
    "Unknown" = "#357EBDFF",         "Host" = "#EEA236FF",
    "CAFs" = "#5CB85CFF",            "Osteoblasts" = "#B8B8B8FF",
    "Pericytes" = "#9632B8FF",       "Neuronal" = "#46B8DAFF",
    "Chondrocytes" = "#90302DFF",    "T_cells" = "#A66D04FF",
    "B_cells" = "#2D577FFF",         "NK_cells" = "#3E7E3EFF",
    "TAMs" = "#7D7D7DFF",            "DC" = "#6D1D87FF",
    "Mast" = "#097F9AFF",            "Monocytes" = "#FF6E6AFF",
    "Endothelial_cells" = "#FFBB70FF","MP_Progenitor" = "#68A4E3FF",
    "Fibrogenic" = "#79D379FF",      "Basal_Progenitor" = "#CDCDCDFF",
    "Proliferative" = "#BF6BE2FF",   "Interactive" = "#69D1F3FF",
    "COMA" = "#DB00FF",              "Fibroblasts" = "#00B3FF",
    "Alv_Macrophages" = "#00FFD1",   "Epithelial_cells" = "#0029FF",
    "Neutrophils" = "#FF00D6",       "Smooth_muscle" = "#00FF47",
    "Erythrocytes" = "#00FFE0",      "MSC" = "#FFE500",
    "Muscle_cells" = "#00D1FF",      "ILCs" = "#FF7A00",
    "Basal" = "#FFB300",             "Progenitor" = "#0099FF",
    "Epithelial_Endothelial" = "#EEA236FF", "Immune_Lymphoid" = "#357EBDFF",
    "Immune_Myeloid" = "#5CB85CFF",  "Mesenchymal" = "#B8B8B8FF"
)


### merge by cellchat function testing if the net number and weight of interaciton change by merging
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # Example: Patient primary vs. patient mets
    object_list_sub <-
        list(object_list[[group_prim]],
             object_list[[group_mets]]) %>%
        setNames(c(group_prim, group_mets))
    cellchat <-
        mergeCellChat(object.list = object_list_sub,
                      add.names = names(object_list_sub),
                      merge.data = FALSE,
                      cell.prefix = FALSE)

    # comapre fropm merged
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "count")
    compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "weight")

    # 2. Compare the total number of interactions and interaction strength
    # Calculate total number of interactions for each group
    interaction_sums <- 
        sapply(object_list_sub, function(x) sum(x@net$count))
    interaction_sum_df <- 
        data.frame(
        group = names(interaction_sums),
        total_interactions = as.numeric(interaction_sums))

    # Barplot individually
    library(ggplot2)
    interaction_df$group <-
        factor(interaction_df$group,
                levels = c("patient_prim", setdiff(interaction_df$group, "patient_prim")))
    ggplot(interaction_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Number of Interactions per Group",
             x = "Group", y = "Total Interactions") +
        theme_minimal() +
        theme(legend.position = "none")
    
    # weight     
    interaction_weight <- 
        sapply(object_list_sub, function(x) sum(x@net$weight))
    interaction_weight_df <- 
        data.frame(
        group = names(interaction_weight),
        total_interactions = as.numeric(interaction_weight))
    interaction_weight_df$group <-
        factor(interaction_weight_df$group,
                levels = c("patient_prim", setdiff(interaction_weight_df$group, "patient_prim")))
    ggplot(interaction_weight_df, aes(x = group, y = total_interactions, fill = group, label = total_interactions)) +
        geom_bar(stat = "identity", width = 0.6) +
        geom_text(aes(label = total_interactions), vjust = -0.5, size = 4) +
        labs(title = "Total Interaction Weights per Group",
             x = "Group", y = "Total Interaction Weights") +
        theme_minimal() +
        theme(legend.position = "none")

}


# merge everything
merged_all <-
    mergeCellChat(object.list = object_list,
                  add.names = names(object_list),
                  cell.prefix = TRUE)
# compare the total number of interactions and interaction strength
gg1<-
    compareInteractions(merged_all, show.legend = F, group = c(1:8)) +
        theme(axis.text.x = element_blank())
gg2 <-
    compareInteractions(merged_all, show.legend = F, group = c(1:8), measure = "weight") +
     theme(axis.text.x = element_text(angle = 45, hjust = 1))

combined <-
    patchwork::wrap_plots(gg1 + xlab(NULL), gg2, ncol = 1)

ggsave("output/figures/cellchat/merged_everything_compare_interactions.png",
    combined,
    width = 10,
    height = 10
)

```




## Focus on pathways
```{r cellchat_pathway_analysis}
object_list <- list()
for (group in c(
                "patient_prim",
                "patient_mets",
                # "mm_prim",
                # "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cellchat <- 
        qs::qread(str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs"))
    
    # qs::qsave(cellchat, str_c("output/cellchat_objects/", group, "_annlevel2_everything", ".qs")) 

    object_list[[group]] <- cellchat
            }

# pathways to focus on
pathways <- 
    c("COLLAGEN", "FN1", "LAMININ")

df_list <- lapply(names(object_list), function(name) {
    obj <- object_list[[name]]
    # sum interaction strength by pathway
    pathways_flow <-
        obj@netP$pathways %>%
        data.frame(pathway = .,
                    flow = apply(obj@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE)))
    pathways_flow_filter <-
        pathways_flow %>%
        filter(pathway %in% pathways) %>%
        mutate(group = name) %>%
        select(group, flow) %>%
        rownames_to_column("pathway")

    return(pathways_flow_filter)
})

df_all <-
    bind_rows(df_list) %>%
        mutate(group = factor(group, levels = c(
            "patient_prim",
            "patient_mets",
            "xeno_prim_cancer_normal",
            "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",
            "dogs_metshuman_ortho",
            "mm_primhuman_ortho",
            "mm_metshuman_ortho"
        ))) %>%
        arrange(group)

ggplot(df_all, aes(x = group, y = flow, fill = pathway)) +
    geom_bar(stat = "identity", position = "dodge") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ylab("Aggregated Interaction Strength") +
    ggtitle("Collagen, FN1, Laminin signaling across osteosarcoma conditions")

df_matrix <-
    df_all %>%
    pivot_wider(names_from = group, values_from = flow) %>%
    column_to_rownames("pathway")

pheatmap::pheatmap(df_matrix, 
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         display_numbers = TRUE,
         color = colorRampPalette(c("white", "red"))(100),
         main = "ECM Pathway Interaction Strength (CellChat)")


### pull the individual interactions
pathways.use <- c("COLLAGEN", "FN1", "LAMININ")

df.netP <-
    subsetCommunication(cellchat, slot.name = "netP")
pathways <- unique(df.netP$pathway_name)
print(pathways)

# returns a data.frame of LR interactions (or a list if geneLR.return=TRUE)
lr_df <- list()
lr_and_prob <- list()
pathways_and_lr <- list()
for (group in names(object_list)) {
    # pull the individual interactions without probabilities
    lr_df[[group]] <-
        extractEnrichedLR(object_list[[group]],
                          signaling = c("COLLAGEN", "FN1", "LAMININ"),
                          geneLR.return = FALSE)

    # pull the individual pathways with probabilities
    lr_and_prob[[group]] <-
        subsetCommunication(object_list[[group]],
                            signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
        arrange(desc(prob))
    
    # pull the indivvidual pathways with individual interactions and probabilities
     pathways_and_lr[[group]] <-
        subsetCommunication(object_list[[group]],
                            signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
        arrange(desc(prob))

}

# intersect

```

### multi sample by sample per group
```{r multi_sample_cellchat_analysis}

#function
get_pathway_flow <- function(cc,
                             dataset_name) {
    flows <- 
        apply(cc@netP$prob, 3, function(mat) sum(mat, na.rm = TRUE))
    data.frame(pathway = names(flows),
            information_flow = as.numeric(flows),
            dataset = dataset_name,
            stringsAsFactors = FALSE)
}

# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "mm_prim",
                "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
    }

    # Collect all datasets and perform PCA for each dataset
    df_list <- 
        Map(get_pathway_flow, cellchat_list,
        names(cellchat_list))
    df_all <-
        do.call(rbind, df_list) %>%
        as_tibble() %>%
        as.data.frame()
    # Pivot to wide format: rows = pathway, columns = dataset, values = information_flow
    df_wide <-
        df_all %>%
        select(pathway, dataset, information_flow) %>%
        tidyr::pivot_wider(names_from = dataset,
                            values_from = information_flow,
                            values_fill = 0)
    # Set rownames to pathway and remove pathway column
    mat_t <- 
        as.data.frame(df_wide) %>%
        column_to_rownames("pathway") %>%
        t()

    # Scale and run PCA
    pca_res <- prcomp(mat_t, scale. = TRUE)

    # PCA plot: one dot per group (dataset)
    pca_df <- as.data.frame(pca_res$x)
    pca_df$group <- rownames(pca_df)

    library(ggplot2)
    ggplot(pca_df, aes(x = PC1, y = PC2, label = group)) +
        geom_point(size = 3) +
        geom_text(vjust = -0.5, size = 3) +
        labs(title = "PCA of Pathway Information Flow (one dot per group)",
                x = "PC1", y = "PC2") +
        theme_minimal()

    # make average of each pathway and calculate sd
    avg_pathway <-
        df_all %>%
            group_by(pathway) %>%
            summarise(
                avg_information_flow = mean(information_flow),
                sd_information_flow = sd(information_flow),
                n = n(),
                se_information_flow = sd_information_flow / sqrt(n)
            ) %>%
            arrange(desc(avg_information_flow))

    # plot average with error bars for top 10 pathways
    # Boxplot with individual samples as dots for top 10 pathways
    top10_pathways <- head(avg_pathway$pathway, 10)
    df_top10 <- df_all %>% filter(pathway %in% top10_pathways)

    ggplot(df_top10, aes(x = reorder(pathway, -information_flow, FUN = median), y = information_flow)) +
        geom_boxplot(outlier.shape = NA, fill = "gray") +
        geom_jitter(width = 0.2, size = 2, alpha = 0.7, color = "blue") +
        labs(title = str_c("Pathway Information Flow (Top 10) - ", group),
             x = "Pathway", y = "Information Flow") +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))

    # normalized the pathways by average
    df_all_norm <-
        df_all %>%
        left_join(avg_pathway %>% select(pathway, avg_information_flow), by = "pathway")
    
    # pca plot of normalized
    df_wide_norm <-
        df_all_norm %>%
        select(pathway, dataset, information_flow, avg_information_flow) %>%
        mutate(norm_information_flow = information_flow / avg_information_flow) %>%
        select(pathway, dataset, norm_information_flow) %>%
        tidyr::pivot_wider(names_from = dataset,
                            values_from = norm_information_flow,
                            values_fill = 0)
    # Set rownames to pathway and remove pathway column
    mat_t_norm <- 
        as.data.frame(df_wide_norm) %>%
        column_to_rownames("pathway") %>%
        t()
    # Scale and run PCA
    pca_res_norm <- prcomp(mat_t_norm, scale. = TRUE)
    # PCA plot: one dot per group (dataset)
    pca_df_norm <- as.data.frame(pca_res_norm$x)
    pca_df_norm$group <- rownames(pca_df_norm)
    ggplot(pca_df_norm, aes(x = PC1, y = PC2, label = group)) +
        geom_point(size = 3) +
        geom_text(vjust = -0.5, size = 3) +
        labs(title = str_c("PCA of Normalized Pathway Information Flow - ", group),
                x = "PC1", y = "PC2") +
        theme_minimal()

    
    # filter for avg > 10 and plot heatmap
    df_all_norm_plot <-
        df_all_norm %>%
        filter(avg_information_flow > 10) %>%
        mutate(norm_information_flow = information_flow / avg_information_flow) %>%
        select(dataset, pathway, norm_information_flow)
    df_matrix <-
        df_all_norm_plot %>%
        pivot_wider(names_from = dataset, values_from = norm_information_flow) %>%
        column_to_rownames("pathway") %>%
        replace(is.na(.), 0) %>%
        as.matrix()
    pheatmap::pheatmap(df_matrix, 
             cluster_rows = TRUE, 
             cluster_cols = TRUE, 
             display_numbers = TRUE,
             color = colorRampPalette(c("blue", "white", "red"))(100),
             main = str_c("Normalized Pathway Interaction Strength - ", group))
    ggsave(str_c("output/figures/cellchat/", group, "_multisample_pathway_heatmap.png"),
        width = 10,
        height = 10,
        bg = "white"
    )
}


# now I want to look into specific interactions within the pathways across samples

# load the objects
for (group in c(
                "patient_prim",
                "patient_mets",
                "mm_prim",
                "mm_mets",
                "xeno_prim_cancer_normal",
                "xeno_mets_cancer_normal",
                "dogs_primhuman_ortho",
                "dogs_metshuman_ortho",
                "mm_primhuman_ortho",
                "mm_metshuman_ortho"
            )) {
    cell_chat_objs <-
        list.files(str_c("output/cellchat_objects/", group),
                pattern = "*.qs",
                full.names = TRUE)
    cellchat_list <- list()
    pathways_LR <- list()
    for (file_path in cell_chat_objs) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat

        # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = group) %>%
            arrange(desc(prob))
    }

    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))
    
    # plot heatmap of top interactions by group
    df_matrix <-
        pathways_LR_df %>%
        select(sample, interaction_name, prob) %>%
        group_by(interaction_name) %>%
        #filter(n() >= 3) %>%
        filter(prob > 10) %>%
        ungroup() %>%
        pivot_wider(names_from = sample, values_from = prob) %>%
        column_to_rownames("interaction_name") %>%
        replace(is.na(.), 0) %>%
        as.matrix() %>%
        t()
    pheatmap::pheatmap(df_matrix, 
             cluster_rows = TRUE, 
             cluster_cols = TRUE, 
             display_numbers = TRUE,
             color = colorRampPalette(c("blue", "white", "red"))(100),
             main = str_c("Pathway Interaction Strength - ", group))

    # run PCA
    pca_res <- prcomp(df_matrix, scale. = TRUE)
    pca_df <- as.data.frame(pca_res$x)
    pca_df$group <- rownames(pca_df)

    ggplot(pca_df, aes(x = PC1, y = PC2, label = group)) +
        geom_point(size = 3) +
        geom_text(vjust = -0.5, size = 3) +
        labs(title = str_c("PCA of Interaction Probabilities - ", group),
                x = "PC1", y = "PC2") +
        theme_minimal()

    # identify the top interactions driving the differences
    loading_scores_df <-
        pca_res$rotation %>%
        as.data.frame() %>%
        rownames_to_column("interaction_name")


    # boxplot of top 20 interactions across samples
    top_interactions <- 
        pathways_LR_df %>%
            group_by(interaction_name) %>%
            summarise(mean_prob = mean(prob)) %>%
            arrange(desc(mean_prob)) %>%
            head(20) %>%
            pull(interaction_name)

    # Filter to top interactions
    plot_df <- 
        pathways_LR_df %>%
            filter(interaction_name %in% top_interactions)

    # Boxplot with individual samples as dots
    ggplot(plot_df, aes(x = reorder(interaction_name, -prob, FUN = median), y = prob)) +
        geom_boxplot(outlier.shape = NA, fill = "lightgray") +
        geom_jitter(width = 0.2, size = 2, alpha = 0.7, color = "blue") +
        labs(title = paste("Top 20 Interactions in", group),
                    x = "Interaction",
                    y = "Probability") +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))  

}
```


## compare primary vs mets by pathways as a whole
```{r compare_pathways_primary_mets_as_whole}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

boxplot_list <- list()
## Analysis for the pathway and probabilities leve
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "netP") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(pathway_name, prob) %>%
            group_by(pathway_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # fill up the missing pathways with 0 prob for each sample
    fill_prob_prim_mets <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(pathway_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the mean prob for each pathway in both primary and mets separately
    total_number_primary <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
    total_number_mets <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

    mean_per_pathway_in_mets <-
        pathways_prob_df %>%
        filter(group == "Metastatic") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_mets) %>%  
        arrange(desc(mean_prob))
    mean_per_pathway_in_primary <-
        pathways_prob_df %>%
        filter(group == "Primary") %>%
        group_by(pathway_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_primary) %>%  
        arrange(desc(mean_prob))
    
    # jopin the two means and keep the higher one
    mean_per_pathway <-
        full_join(x = mean_per_pathway_in_primary,
                  y = mean_per_pathway_in_mets,
                  by = "pathway_name",
                  suffix = c("_prim", "_mets")) %>%
        mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
        select(pathway_name, mean_prob) %>%
        arrange(desc(mean_prob))
    
    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        fill_prob_prim_mets %>%
        filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway, by = "pathway_name") %>%
        mutate(norm_prob = prob / mean_prob) %>%
        select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
        group_by(pathway_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        group_by(pathway_name, group) %>%
        mutate(fold_change = mean(prob) / max(mean_prob)) %>%
        arrange(pathway_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(pathway_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(pathway_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "pathway_name")

    prob_filter <- median(pathways_prob_df$prob)
    chosen_pathways <- 
        pathways_prob_df_filtered %>%
        filter(mean_prob > prob_filter & fold_change < 0.8) %>%
        filter(padj < 0.1) %>%
        arrange(desc(prob)) %>%
        select(pathway_name, fold_change) %>%
        distinct()

    # finally plot the chosen pathways
    if (nrow(chosen_pathways) != 0) {
        plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(pathway_name %in% chosen_pathways$pathway_name) %>%
            mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
            ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
            geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
            scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
            labs(title = str_c("Top Pathways in ", group_prim, " vs ", group_mets),
                x = "Pathway",
                y = "Normalized Probability (by mean)") +
            theme_minimal() +
                        theme(
                            axis.text.x = element_text(angle = 45, hjust = 1),
                            panel.grid = element_blank(),
                            axis.line.x = element_line(),
                            axis.line.y = element_line())

        ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_pathways_boxplot.png"),
        plot_pathways,
        width = length(chosen_pathways$pathway_name) * 0.6 + 1,
        height = 6,
        limitsize = FALSE,
        bg = "white")
    }
}


# LR interactions
## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

boxplot_list <- list()
## Analysis for the pathway and probabilities leve
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_prob <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, prob) %>%
            group_by(interaction_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))
    }
    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        pathways_prob[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, prob) %>%
            group_by(interaction_name) %>%
            summarise(prob = sum(prob)) %>%
            ungroup() %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))
    }
    # this is for the specific interactions across primary and mets
    pathways_prob_df <-
        do.call(rbind, pathways_prob) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # fill up the missing pathways with 0 prob for each sample
    fill_prob_prim_mets <-
        pathways_prob_df %>%
        mutate(sample_group = paste(sample, group, sep = "-")) %>%
        select(interaction_name, sample_group, prob) %>%
        pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
        pivot_longer(-interaction_name, names_to = "sample_group", values_to = "prob") %>%
        separate(sample_group, into = c("sample", "group"), sep = "-")

    # calculate the mean prob for each pathway in both primary and mets separately
    total_number_primary <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
    total_number_mets <- 
        n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

    mean_per_pathway_in_mets <-
        pathways_prob_df %>%
        filter(group == "Metastatic") %>%
        group_by(interaction_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_mets) %>%  
        arrange(desc(mean_prob))
    mean_per_pathway_in_primary <-
        pathways_prob_df %>%
        filter(group == "Primary") %>%
        group_by(interaction_name) %>%
        arrange(desc(prob)) %>%
        summarise(mean_prob = sum(prob)/total_number_primary) %>%  
        arrange(desc(mean_prob))
    
    # jopin the two means and keep the higher one
    mean_per_pathway <-
        full_join(x = mean_per_pathway_in_primary,
                  y = mean_per_pathway_in_mets,
                  by = "interaction_name",
                  suffix = c("_prim", "_mets")) %>%
        mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
        select(interaction_name, mean_prob) %>%
        arrange(desc(mean_prob))
    
    # to calculate the pvalue
    myfun <- function(x) {
        x$pvalue <-
            t.test(prob ~ group, data = x)$p.value
        return(x)
    }

    # now filter pathways for primary
    pathways_prob_df_filtered <- 
        fill_prob_prim_mets %>%
        filter(interaction_name %in% mean_per_pathway$interaction_name) %>%
        arrange(desc(prob)) %>%
        left_join(mean_per_pathway, by = "interaction_name") %>%
        mutate(norm_prob = prob / mean_prob) %>%
        select(sample, group, interaction_name, prob, mean_prob, norm_prob) %>%
        group_by(interaction_name) %>%
        group_split() %>%
        map(~ myfun(.x)) %>%
        bind_rows() %>%
        group_by(interaction_name, group) %>%
        mutate(fold_change = mean(prob) / max(mean_prob)) %>%
        arrange(interaction_name) %>%
        ungroup()

    pull_path_pval <-
        pathways_prob_df_filtered %>%
        select(interaction_name, pvalue) %>%
        distinct() %>%
        mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
        select(interaction_name, padj)

    # put the padj baclk to the pathways_prob_df_filtered
    pathways_prob_df_filtered <-
        pathways_prob_df_filtered %>%
        left_join(pull_path_pval, by = "interaction_name")

    prob_filter <- mean(pathways_prob_df$prob)
    chosen_pathways <- 
        pathways_prob_df_filtered %>%
        filter(mean_prob > prob_filter & fold_change < 0.8) %>%
        filter(padj < 0.1) %>%
        arrange(desc(prob)) %>%
        select(interaction_name, fold_change) %>%
        distinct()

    # finally plot the chosen pathways
    if (nrow(chosen_pathways) != 0) {
        plot_pathways <-
            pathways_prob_df_filtered %>%
            filter(interaction_name %in% chosen_pathways$interaction_name) %>%
            mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
            ggplot(aes(x = reorder(interaction_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
            geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
            geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
            scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
            scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
            labs(title = str_c("Top LR in ", group_prim, " vs ", group_mets),
                x = "Pathway",
                y = "Normalized Probability (by mean)") +
            theme_minimal() +
                        theme(
                            axis.text.x = element_text(angle = 45, hjust = 1),
                            panel.grid = element_blank(),
                            axis.line.x = element_line(),
                            axis.line.y = element_line())

        ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/prim_vs_mets_sig_LR_boxplot.png"),
        plot_pathways,
        width = length(chosen_pathways$interaction_name) * 0.5 + 1,
        height = 6,
        limitsize = FALSE,
        bg = "white")
    }
}

```


## Compare prim vs mets pathways tumor as sender and specific celltype as receiver
```{r compare_pathways_primary_mets_specific_receiver}

## compare_pathway networks between primary and mets
# but this time set tumor as sending and normal as receiving

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor",
      "Proliferative", "COMA", "MP_Progenitor")

receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

boxplot_list <- list()
## Analysis for the pathway and probabilities leve
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # loop for the receiver celltypes
    for (receiver_cell in receiver_celltypes) {
        # list for both primary and mets
        cellchat_list <- list()
        pathways_prob <- list()
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            
            target_cells <- receiver_cell
            
            # filter to LR and pathways and prob
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }
        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "netP") %>%
                arrange(desc(prob))
            target_cells <- receiver_cell
            pathways_prob[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(pathway_name, prob) %>%
                group_by(pathway_name) %>%
                summarise(prob = sum(prob)) %>%
                ungroup() %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
        # this is for the specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_prob) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))
        
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {
            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(pathway_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-pathway_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])

            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(pathway_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "pathway_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(pathway_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(pathway_name %in% mean_per_pathway$pathway_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "pathway_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, pathway_name, prob, mean_prob, norm_prob) %>%
                    group_by(pathway_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(pathway_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(pathway_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(pathway_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(pathway_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "pathway_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(pathway_name, fold_change) %>%
                    distinct()

                # finally plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(pathway_name %in% chosen_pathways$pathway_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(pathway_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Pathways in ", receiver_cell, " in ",  group_prim, " vs ", group_mets),
                            x = "Pathway",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())
                                    
                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                            dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                            recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_pathways_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant pathway found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    }
}





```



### I want tumor to be the sender and stroma to be the receiver
### then look at the top ligands from tumor to stroma and see what target genes they
### might be activating using nichenet
```{r tumor_to_stroma_cellchat_nichenet}

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

ligand_source <- 
    c("Interactive", "Fibrogenic", "Basal_Progenitor", "Proliferative", "COMA", "MP_Progenitor")


receiver_celltypes <- c(
    "CAFs", "Pericytes", "T_cells", "B_cells", "NK_cells",
    "TAMs", "DC", "Monocytes", "Endothelial_cells",
    "Alv_Macrophages", "Epithelial_cells", "Mast_cells", "Neutrophils"
)

## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()

    for (receiver_cell in receiver_celltypes) {
        # get the pathways and lr with prob for primary
        cell_chat_prim <-
            list.files(str_c("output/cellchat_objects/", group_prim),
                    pattern = "*.qs",
                    full.names = TRUE)

        for (file_path in cell_chat_prim) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))

            target_cells <- receiver_cell

            # filter to LR and pathways and prob
            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Primary") %>%
                arrange(desc(prob))
        }

        # get the metastatic pathways and lr with prob
        cell_chat_mets <-
            list.files(str_c("output/cellchat_objects/", group_mets),
                    pattern = "*.qs",
                    full.names = TRUE)
        for (file_path in cell_chat_mets) {
            sample_name <- str_replace(basename(file_path), ".qs", "")
            cellchat <- qs::qread(file_path)
            cellchat_list[[sample_name]] <- cellchat
            # filter to LR and pathways and prob
            # pull the individual interactions without probabilities
            pathways_and_lr_prob <-
                subsetCommunication(cellchat,
                                #signaling = c("COLLAGEN","FN1", "LAMININ"),
                                slot.name = "net") %>%
                arrange(desc(prob))
            # target_cells <-
            #     setdiff(as.vector(unique(pathways_and_lr_prob$target)), ligand_source)
            target_cells <- receiver_cell

            pathways_LR[[sample_name]] <-
                pathways_and_lr_prob %>%
                filter(source %in% ligand_source & target %in% target_cells) %>%
                select(interaction_name, prob) %>%
                group_by(interaction_name) %>%
                summarise(prob = sum(prob), .groups = "drop") %>%
                mutate(sample = sample_name, group = "Metastatic") %>%
                arrange(desc(prob))
        }
    
        # this is for the specific interactions across primary and mets
        # specific interactions across primary and mets
        pathways_prob_df <-
            do.call(rbind, pathways_LR) %>%
            as_tibble() %>%
            as.data.frame() %>%
            arrange(desc(prob))

        # only continue if there are both primary and mets samples
        if (length(unique(pathways_prob_df$group)) == 2 & nrow(pathways_prob_df) > 4) {

            # fill up the missing pathways with 0 prob for each sample
            fill_prob_prim_mets <-
                pathways_prob_df %>%
                mutate(sample_group = paste(sample, group, sep = "-")) %>%
                select(interaction_name, sample_group, prob) %>%
                pivot_wider(names_from = sample_group, values_from = prob, values_fill = 0) %>%
                pivot_longer(-interaction_name, names_to = "sample_group", values_to = "prob") %>%
                separate(sample_group, into = c("sample", "group"), sep = "-")

            # calculate the mean prob for each pathway in both primary and mets separately
            total_number_primary <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Primary"])
            total_number_mets <- 
                n_distinct(pathways_prob_df$sample[pathways_prob_df$group == "Metastatic"])
            
            # only proceed if total number of primary and mets samples are both > 1
            if (total_number_primary > 1 & total_number_mets > 1) {
                mean_per_pathway_in_mets <-
                    pathways_prob_df %>%
                    filter(group == "Metastatic") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_mets) %>%  
                    arrange(desc(mean_prob))
                mean_per_pathway_in_primary <-
                    pathways_prob_df %>%
                    filter(group == "Primary") %>%
                    group_by(interaction_name) %>%
                    arrange(desc(prob)) %>%
                    summarise(mean_prob = sum(prob)/total_number_primary) %>%  
                    arrange(desc(mean_prob))
                
                # jopin the two means and keep the higher one
                mean_per_pathway <-
                    full_join(x = mean_per_pathway_in_primary,
                            y = mean_per_pathway_in_mets,
                            by = "interaction_name",
                            suffix = c("_prim", "_mets")) %>%
                    mutate(mean_prob = pmax(replace_na(mean_prob_prim, 0), replace_na(mean_prob_mets, 0))) %>%
                    select(interaction_name, mean_prob) %>%
                    arrange(desc(mean_prob))
                
                # to calculate the pvalue
                myfun <- function(x) {
                    x$pvalue <-
                        t.test(prob ~ group, data = x)$p.value
                    return(x)
                }

                # now filter pathways for primary
                pathways_prob_df_filtered <- 
                    fill_prob_prim_mets %>%
                    filter(interaction_name %in% mean_per_pathway$interaction_name) %>%
                    arrange(desc(prob)) %>%
                    left_join(mean_per_pathway, by = "interaction_name") %>%
                    mutate(norm_prob = prob / mean_prob) %>%
                    select(sample, group, interaction_name, prob, mean_prob, norm_prob) %>%
                    group_by(interaction_name) %>%
                    group_split() %>%
                    map(~ myfun(.x)) %>%
                    bind_rows() %>%
                    group_by(interaction_name, group) %>%
                    mutate(fold_change = mean(prob) / max(mean_prob)) %>%
                    arrange(interaction_name) %>%
                    ungroup()

                pull_path_pval <-
                    pathways_prob_df_filtered %>%
                    select(interaction_name, pvalue) %>%
                    distinct() %>%
                    mutate(padj =  p.adjust(pvalue, method = "BH")) %>%
                    select(interaction_name, padj)

                # put the padj baclk to the pathways_prob_df_filtered
                pathways_prob_df_filtered <-
                    pathways_prob_df_filtered %>%
                    left_join(pull_path_pval, by = "interaction_name")

                prob_filter <- median(pathways_prob_df$prob)
                chosen_pathways <- 
                    pathways_prob_df_filtered %>%
                    filter(mean_prob > prob_filter & fold_change < 0.8) %>%
                    filter(padj < 0.1) %>%
                    arrange(desc(prob)) %>%
                    select(interaction_name, fold_change) %>%
                    distinct()

                # plot the chosen pathways
                if (nrow(chosen_pathways) != 0) {
                    plot_pathways <-
                        pathways_prob_df_filtered %>%
                        filter(interaction_name %in% chosen_pathways$interaction_name) %>%
                        mutate(group = factor(group, levels = c("Primary", "Metastatic"))) %>%
                        ggplot(aes(x = reorder(interaction_name, -norm_prob, FUN = median), y = norm_prob, fill = group)) +
                        geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75)) +
                        geom_jitter(aes(color = group), position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75), size = 1, alpha = 0.7) +
                        scale_fill_manual(values = c("Primary" = "#87c9ffff", "Metastatic" = "#f87478ff")) +
                        scale_color_manual(values = c("Primary" = "#0088f7ff", "Metastatic" = "#f70004ff")) +
                        labs(title = str_c("Top Interactions from Tumor to ", receiver_cell," in ",group_prim, " vs ", group_mets),
                            x = "Interaction",
                            y = "Normalized Probability (by mean)") +
                        theme_minimal() +
                                    theme(
                                        axis.text.x = element_text(angle = 45, hjust = 1),
                                        panel.grid = element_blank(),
                                        axis.line.x = element_line(),
                                        axis.line.y = element_line())

                    if (!dir.exists(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets))) {
                        dir.create(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets),
                        recursive = TRUE)
                    }
                    ggsave(str_c("output/figures/cellchat/", group_prim, "_vs_", group_mets, "/tumor_to_", receiver_cell, "_LR_boxplot.png"),
                    plot_pathways,
                    width = max(length(chosen_pathways$interaction_name) * 0.75 + 1, 6),
                    height = 6,
                    bg = "white")
                } else {
                    message("No significant interactions found for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
                }
            } else {
                message("Not enough samples in either primary or metastatic group for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
            }
        } else {
            message("Not enough groups or interactions for tumor as sender and ", receiver_cell, " in ", group_prim, " vs ", group_mets)
        }
    } 
}


## this analysis is to identify how Tumor cells reprogram the AT cells in the mets

```














## Leverage Nichenet to identify dowstream
```{r nichenet_downstream_analysis}


# what are the downstream activation of each pathways? could grab the 
# top ligand from the cellchat and then use nichenet to predict the target genes
# then test if the target genes are differentially expressed in mets vs primary
ligand_target_matrix <-
    readRDS("input/nichenet_analysis/ligand_target_matrix_nsga2r_final.rds")
    # Convert the ligand_target_matrix to a long data frame for ggplot

ligand_target_long <- 
    as.data.frame(as.matrix(ligand_target_matrix)) %>%
    rownames_to_column("ligand") %>%
    pivot_longer(-ligand, names_to = "target", values_to = "value")

ggplot(ligand_target_long, aes(x = value)) +
    geom_histogram(bins = 200, fill = "skyblue", color = "black") +
    geom_vline(xintercept = 0.0075, color = "red", linetype = "dashed", size = 1) +
    labs(title = "Histogram of Ligand-Target Matrix Values",
            x = "Values", y = "Frequency") +
    theme_minimal() +
    xlim(c(0, 0.1))

lig <- "FN1"
targets <-
    ligand_target_matrix[lig, ] %>%
    as.data.frame() %>%
    rownames_to_column("target") %>%
    rename(score = 2) %>%
    arrange(desc(score)) %>%
    head(10) %>%
    mutate(ligand = lig)
downstream_genes <- targets$target

prim <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_prim.qs") %>%
    subset(Ann_Level2 == "TAMs")

mets <-
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs") %>%
    subset(Ann_Level2 == "TAMs")

combine <-
    merge(prim, mets) %>%
    JoinLayers() %>%
    process_seurat()
VlnPlot(combine,
        group.by = "unique",
        #split.by = "Ann_Level3",
        ncol = 6,
        features = downstream_genes,
        pt.size = 0.1)

## compare_pathway networks between primary and mets
groups_by <-
    tribble(~primary,                    ~ mets,
            "patient_prim",               "patient_mets",
            "mm_primhuman_ortho",         "mm_metshuman_ortho",
            "xeno_prim_cancer_normal",    "xeno_mets_cancer_normal",
            "dogs_primhuman_ortho",        "dogs_metshuman_ortho")

## analysis for interactions and probabilities level
for (i in 1:nrow(groups_by)) {
    group_prim <- groups_by$primary[i]
    group_mets <- groups_by$mets[i]

    # list for both primary and mets
    cellchat_list <- list()
    pathways_LR <- list()
    # get the pathways and lr with prob for primary
    cell_chat_prim <-
        list.files(str_c("output/cellchat_objects/", group_prim),
                pattern = "*.qs",
                full.names = TRUE)

    for (file_path in cell_chat_prim) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        # filter to LR and pathways and prob
        pathways_LR[[sample_name]] <-
           pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Primary") %>%
            arrange(desc(prob))  
    }

    # get the metastatic pathways and lr with prob
    cell_chat_mets <-
        list.files(str_c("output/cellchat_objects/", group_mets),
                pattern = "*.qs",
                full.names = TRUE)
    for (file_path in cell_chat_mets) {
        sample_name <- str_replace(basename(file_path), ".qs", "")
        cellchat <- qs::qread(file_path)
        cellchat_list[[sample_name]] <- cellchat
        # filter to LR and pathways and prob
         # pull the individual interactions without probabilities
        pathways_and_lr_prob <-
            subsetCommunication(cellchat,
                            #signaling = c("COLLAGEN","FN1", "LAMININ"),
                            slot.name = "net") %>%
            arrange(desc(prob))
        pathways_LR[[sample_name]] <-
            pathways_and_lr_prob %>%
            select(interaction_name, pathway_name, prob) %>%
            group_by(interaction_name, pathway_name) %>%
            summarise(prob = sum(prob), .groups = "drop") %>%
            mutate(sample = sample_name, group = "Metastatic") %>%
            arrange(desc(prob))  
    
    }
    # this is for the specific interactions across primary and mets
    # specific interactions across primary and mets
    pathways_LR_df <-
        do.call(rbind, pathways_LR) %>%
        as_tibble() %>%
        as.data.frame() %>%
        arrange(desc(prob))

    # filter the pathways interested
    interested_pathways <-
        c("FN1", "LAMININ")

    pathways_LR_df_interested <-
        pathways_LR_df %>%
        filter(pathway_name %in% interested_pathways) %>%
        arrange(desc(prob))

    # identify the top downstream activated genes for each top ligand using nichenet
    top_ligands <-
        pathways_LR_df_interested %>%
        distinct(interaction_name) %>%
        separate(interaction_name, into = c("ligand", "receptor"), sep = "_") %>%
        distinct(ligand) %>%
        pull(ligand)

    top_targets <- list()
    for (lig in top_ligands) {
        if (lig %in% rownames(ligand_target_matrix)) {
            targets <-
                ligand_target_matrix[lig, ] %>%
                as.data.frame() %>%
                rownames_to_column("target") %>%
                rename(score = 2) %>%
                arrange(desc(score)) %>%
                head(20) %>%
                mutate(ligand = lig)
            top_targets[[lig]] <- targets

        }



}













```



















## spatial nichenet

```{r spatial_nichenet_analysis}

average_spatial_leestat <- 
    read_tsv("/gpfs0/home2/gdrobertslab/lab/Analysis/Matt/24_Osteo_atlas/output/spacexr/granular_references/lee_perms/average_lee_stats.tsv") 

not_correlated <-
    average_spatial_leestat %>%
    filter(group != "Correlated")

ggplot(data.frame(value = correlated$lee_stat), aes(x = value)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black") +
    ggtitle("Histogram of Correlated Lee Stat Values") +
    xlab("Lee Stat")


df_pairs <-
    average_spatial_leestat %>%
    rownames_to_column("Cell1") %>%
    pivot_longer(-Cell1, names_to = "Cell2", values_to = "LeeStat") %>%
    filter(Cell1 != Cell2)

# Select top 10% values
threshold <- quantile(df_pairs$LeeStat, 0.95)

top_pairs <- df_pairs %>% filter(LeeStat >= threshold)
high_cells <- top_pairs %>%
  gather(CellRole, Cell, Cell1:Cell2) %>%
  group_by(Cell) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))

# Option 1: Use a fixed LeeStat threshold (e.g., 0.1)
fixed_threshold <- 0.2
top_pairs_fixed <- df_pairs %>% filter(LeeStat >= fixed_threshold)
high_cells_fixed <- 
    top_pairs_fixed %>%
    gather(CellRole, Cell, Cell1:Cell2) %>%
    group_by(Cell) %>%
    summarise(Count = n()) %>%
    arrange(desc(Count))











# Plot a histogram for each column in average_spatial_leestat using ggplot2
library(ggplot2)
library(cowplot)

hist_list <- list()
for (col in colnames(average_spatial_leestat)) {
    df <- data.frame(value = average_spatial_leestat[[col]])
    hist_list[[col]] <-
        ggplot(df, aes(x = value)) +
        geom_histogram(bins = 30, fill = "skyblue", color = "black") +
        ggtitle(paste("Histogram of", col)) +
        xlab(col)
}

hists <-
    plot_grid(plotlist = hist_list, ncol = 3)
ggsave("output/figures/cellchat/average_spatial_leestat_histograms.png",
    hists,
    width = 15,
    height = 45
)

# Combine all values into a single vector and plot as one histogram
average_spatial_leestat_long <- 
    average_spatial_leestat %>%
    tibble::rownames_to_column("cell_type_1") %>%
    tidyr::pivot_longer(-cell_type_1, names_to = "cell_type_2", values_to = "value")

all_values <- average_spatial_leestat_long$value

# Plot a histogram of all values combined
ggplot(data.frame(value = all_values), aes(x = value)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "black") +
    ggtitle("Histogram of All Values in average_spatial_leestat") +
    xlab("Value")

median_value <- median(average_spatial_leestat_long$value, na.rm = TRUE)

celltypes_for_callchat <-






# Install the NNLM package
devtools::install_github("linxihui/NNLM")
# Install SpaTalk
devtools::install_github("ZJUFanLab/SpaTalk")

library(NNLM)
library(SpaTalk)

if (!dir.exists("output/spatial_objects/")) {
    dir.create("output/spatial_objects/",
    recursive = TRUE)
}

spatial_objects <- 
   qs::qread("output/spatial_objects/spatial_list_level3_annotations.qs")

scObj <- 
    qs::qread("output/seurat_objects/final_tumor_vs_stroma/patient_mets.qs")
sc_data <- GetAssayData(scObj, assay = "RNA", slot = "data")

for (item in names(spatial_objects)) {
    object <- spatial_objects[[item]]

    celltypes <- c(
        "myCAFs", "Pericytes", "Adv_Fibroblasts", "apCAFs", "Neuronal", "CD4_T",
        "CD8_T", "Prolif_T", "NK_cells", "T_Reg", "Naive_T", "Plasma_B",
        "Memory_B", "Inflam_TAMs", "Mast", "DC2", "TAMs", "Scar_TAMs",
        "Monocytes", "Prolif_TAMs", "DC1", "IFN_TAMs", "Fibrogenic_TAMs",
        "Alv_Macrophages", "Osteoclast_TAMs", "Endothelial_Vein",
        "Endothelial_Capillary", "Endothelial_Artery", "AT2",
        "Endothelial_Lymphatic", "Endothelial_Activated", "Capillary_Aerocyte",
        "Endothelial_Prolif", "Ciliated_cells", "AT1", "Basal_Progenitor",
        "Fibrogenic", "MP_Progenitor", "Proliferative", "Interactive", "COMA")
    
    # Subset just the cell types of interestprop_mat <- object@meta.data[, celltypes]
    prop_mat <- object@meta.data[, celltypes]
    rownames(prop_mat) <- rownames(object@meta.data)

        # Create SpaTalk object
    st_obj <- 
        createSpaTalk(st_data = prop_mat,        # Deconvolution results
                        st_meta = object@meta.data[, c("x", "y")],  # Spatial coordinates
                        species = "Human",         # Adjust if using mouse data
                        if_st_is_sc = FALSE,       # Indicate spot-based data
                        spot_max_cell = 30         # Recommended for 10x 55um data
                        )



    # --------------------------------------
# INPUTS
# --------------------------------------
# prop_mat: spots  celltypes (from deconvolution)
#           rows = spot IDs, cols = cell types, values = proportion [0-1]
# ref_expr: genes  celltypes (reference scRNA-seq average expression)
#           rows = gene symbols, cols = cell types
# meta:     data.frame with rownames = spots, and extra info (e.g. sample, region)

# Example: ensure order matches

    prop_mat <- object@meta.data[, celltypes]
    # Assign each spot the dominant cell type
    meta <- data.frame(celltype = celltypes[max.col(prop_mat, ties.method = "first")])
    rownames(meta) <- rownames(prop_mat)

# --------------------------------------
# 1. Build pseudo-expression matrix
# --------------------------------------
# E_spot_gene = prop * ref expression
pseudo_expr <- as.matrix(prop_mat) %*% t(as.matrix(ref_expr))
# Now: spots  genes

pseudo_expr <- t(pseudo_expr)  # make it genes  spots (CellChat expects genes  cells)

# --------------------------------------
# 2. Create CellChat object
# --------------------------------------
cellchat <- createCellChat(object = pseudo_expr, meta = meta, group.by = "celltype")

# Use the appropriate database
CellChatDB <- CellChatDB.human  # or .mouse
cellchat@DB <- CellChatDB

# --------------------------------------
# 3. Run pipeline
# --------------------------------------
cellchat <- subsetData(cellchat) # subset the ligandreceptor genes
cellchat <- computeCommunProb(cellchat, type = "triMean")
cellchat <- filterCommunication(cellchat, min.cells = 10)
cellchat <- computeCommunProbPathway(cellchat)
cellchat <- aggregateNet(cellchat)

# --------------------------------------
# 4. Visualize
# --------------------------------------
netVisual_circle(cellchat@net$count, 
                 vertex.label = levels(cellchat@idents),
                 title.name = "Tumorstroma Pseudo LR Network")





    # Prepare input data for CelChat analysis
    data.input = GetAssayData(cortex, slot = "data", assay = "SCT") # SCT normalized
    meta = data.frame(labels = Idents(cortex), row.names = names(Idents(cortex))) 

    # load spatial imaging information: Spatial locations of spots 
    spatial.locs = GetTissueCoordinates(cortex, scale = NULL, 
                                        cols = c("imagerow", "imagecol")) 

    # Scale factors and spot diameters of the full resolution images 
    scale.factors = jsonlite::fromJSON(txt = file.path(
    "../Desktop/Video_Tutorials/Cellchat/Mouse_Brain_Sagittal_Anterior/spatial/", 
    'scalefactors_json.json'))
    scale.factors = list(spot.diameter = 65, 
        spot = scale.factors$spot_diameter_fullres, 
        fiducial = scale.factors$fiducial_diameter_fullres, 
        hires = scale.factors$tissue_hires_scalef, 
        lowres = scale.factors$tissue_lowres_scalef)   

    # Create a CellChat object
    cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels",
                            datatype = "spatial", coordinates = spatial.locs, 
                            scale.factors = scale.factors)

    cellchat

    # use Secreted Signaling from CellChatDB for cell-cell communication analysis
    cellchat@DB <- subsetDB(CellChatDB.mouse, search = "Secreted Signaling")

    # subset the expression data of signaling genes for saving computation cost
    cellchat <- subsetData(cellchat)

    # Pre-processing
    cellchat <- identifyOverExpressedGenes(cellchat)
    cellchat <- identifyOverExpressedInteractions(cellchat)

    # Compute the communication probability and infer cellular communication network
    cellchat <- computeCommunProb(cellchat, type = "truncatedMean", trim = 0.1, 
            distance.use = TRUE, interaction.length = 200, scale.distance = 0.01)

    # Filter out the cell-cell communication if number of cells <10 in a group
    cellchat <- filterCommunication(cellchat, min.cells = 10)

    cellchat <- computeCommunProbPathway(cellchat)

    cellchat <- aggregateNet(cellchat)

    # visualize the aggregated cell-cell communication network using Circle plot
    groupSize <- as.numeric(table(cellchat@idents))
    par(mfrow = c(1,2), xpd=TRUE)
    netVisual_circle(cellchat@net$count, vertex.weight = rowSums(cellchat@net$count), 
            weight.scale = T, label.edge= F,  arrow.size = 0.1, 
            title.name = "Number of interactions")
    netVisual_circle(cellchat@net$weight, vertex.weight = rowSums(cellchat@net$weight), 
            weight.scale = T, label.edge= F, arrow.size = 0.1,
            title.name = "Interaction weights/strength")

    # selected cell-cell communication network
    par(mfrow=c(1,1))
    netVisual_aggregate(cellchat, signaling = c("NPY"), layout = "circle", 
                        arrow.size = 0.1)
    netVisual_aggregate(cellchat, signaling = c("SEMA3"), layout = "circle", 
                        arrow.size = 0.1)

    # Compute the network centrality scores
    cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP")

    # Visualize the computed centrality scores using heatmap
    netAnalysis_signalingRole_network(cellchat, signaling = c("SEMA3"), 
                                    width = 8, height = 2.5, font.size = 10)

    # Spatial plot
    netVisual_aggregate(cellchat, signaling = c("SEMA3"), layout = "spatial", 
                        edge.width.max = 2, vertex.size.max = 1, alpha.image = 0.2, 
                        vertex.label.cex = 3.5)

    saveRDS(cellchat, file = "cellchat_visium_mouse_cortex.rds")

}


```
