---
title: "Osteosarcoma scAtlas"
output: 
    html_document:
        code_folding: hide
always_allow_html: true
---

```{r setup, include=FALSE}
library(rrrSingleCellUtils)
library(Seurat)
library(ggrepel)
library(tidyverse)
library(stringr)
library(harmony)
library(cowplot)
library(clustree)
library(data.table)
library(hdf5r)
library(Rmagic)
library(scATOMIC)
library(SCEVAN)
library(knitr)
```

# load in functions
```{r, child='function_atlas.Rmd'}
```

```{r setup2, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE,
                      cache.lazy = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

## Read metadata 
```{r, cache.vars="all_samples_csv"}
all_samples_csv <- read_tsv("allsample_details.txt")

all_samples_csv$sp_pattern <-
    str_replace_all(all_samples_csv$sp_pattern, "nothing", "")

# #for the sake of presentation, I will just have patient data
all_samples_csv <- filter(all_samples_csv,
                          unique == "patient_prim" | unique =="patient_mets")

```

## reading data and make prepreocessed seurat objects
The code will first look if the h5 files exist in each repo. If exists, the
seurat object is made and saved. 
```{r, fig.width = 10, fig.height = 10, fig.align = "center", echo = FALSE, eval = FALSE}
#Seurat objects and save individual qs object

parallel::mclapply(seq_len(nrow(all_samples_csv)), function(i){
    sample_name <- all_samples_csv$sample_name[i]
    species <- all_samples_csv$species[i]
    data_source <- all_samples_csv$data_source[i]
    sp_pattern <- all_samples_csv$sp_pattern[i]
    organism <- all_samples_csv$organism[i]
    SJ_path <- "/gpfs0/home2/gdrobertslab/lab/ExternalData/Patel_lab/"
    NCH_path <- "/gpfs0/home2/gdrobertslab/lab/Counts_2/"
    NCI_path <- "/gpfs0/home2/gdrobertslab/lab/ExternalData/McEachron_lab/03_FilteredMatricesH5/"
    path_h5 <- NULL

    #check if the object already exists
    dir <- str_c("output/seurat_objects/sobj_preprocess")
    sobject <- str_c(sample_name, "_", organism, ".qs")
    if (file.exists(str_c(dir, "/", sobject))) {
        print(str_c(sobject, " already exists"))
    } else {
        if (data_source == "NCH" || data_source == "GEO") {
            if (file.exists(str_c(NCH_path, sample_name))) {
                path_h5 <- paste0(path_10x = NCH_path,
                                        sample_name,
                                        "/filtered_feature_bc_matrix.h5")
            } else {
                print(str_c(sample_name, " folder does not exist and hence cannot make seurat object"))
            }
        } else if (data_source == "SJ") {
            if (file.exists(str_c(SJ_path, sample_name))) {
                path_h5 <- paste0(path_10x = SJ_path,
                                        sample_name,
                                        "/filtered_feature_bc_matrix.h5")
            } else {
                print(str_c(sample_name, " folder does not exist and hence cannot make seurat object"))
            }
        } else if (data_source == "NCI-POB") {
            if (file.exists(str_c(NCI_path, sample_name, "_filtered_feature_bc_matrix.h5"))) {
                path_h5 <- paste0(path_10x = NCI_path,
                                        sample_name,
                                        "_filtered_feature_bc_matrix.h5")
            } else {
                print(str_c(sample_name, " folder does not exist and hence cannot make seurat object"))
            }
        }
        if (!is.null(path_h5)) {
            sobj <- rrrSingleCellUtils::tenx_load_qc(h5_file = path_h5,
                                                    species_pattern = sp_pattern,
                                                    violin_plot = FALSE,
                                                    min_cells = 1,
                                                    min_features = 1)
            sobj <- process_seurat(sobj)
            sobj$sample_name <- all_samples_csv$sample_name[i]
            sobj$tumor_type <- all_samples_csv$tumor_type[i]
            sobj$data_type <- all_samples_csv$data_type[i]
            sobj$data_source <- all_samples_csv$data_source[i]
            sobj$organism <- all_samples_csv$organism[i]
            sobj$location <- all_samples_csv$location[i]
            sobj$method <- all_samples_csv$method[i]
            sobj$unique <- all_samples_csv$unique[i]
            sobj$model <- all_samples_csv$model[i]
            sobj$CL_or_PDX <- all_samples_csv$CL_or_PDX[i]

            if (!is.null(sobj)) {
                qs::qsave(sobj, str_c(dir, "/", sobject))
            }
            print(str_c(sobject, " made and saved"))
        }
    }
}, mc.cores = parallelly::availableCores())

```


# Count cells per sample before the QC
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}

single_sobjs <- list.files(path = "output/seurat_objects/sobj_preprocess/",
                          full.names = FALSE)
counts <- tibble()
for (item in single_sobjs){
    sobj <- qs::qread(str_c("output/seurat_objects/sobj_preprocess/",
                            item))
    sobj$ncount_med <- median(sobj$nCount_RNA)
    unique <- sobj@meta.data$unique %>%
        head(n=1)
    Hmeta_data <- sobj@meta.data %>%
        as.data.table

    counts <- Hmeta_data[, .N, by = c("sample_name", "unique", "ncount_med")] %>%
        dplyr::rename(N_cells = N) %>%
        rbind(counts) %>% 
        arrange(unique)
}

DT::datatable(arrange(counts, unique))

```

# Test for each individual QC
```{r, eval = FALSE}

# try_cutoff <- tribble(~feature,     ~min_val, ~max_val,
#                       "nCount_RNA", 0,        40000,
#                       "percent.mt", 0,        20)
# features <- c("nFeature_RNA", "nCount_RNA", "percent.mt")

# sobj <- qs::qread(str_c("output/seurat_objects/sobj_preprocess/",
#                         "S0246",
#                         "_mouse.qs"))

# feature_hist(sobject = sobj,
#         features = features,
#         cutoff_table = try_cutoff) +
#         ggtitle(str_c("plot for ", 
#                         sobj$sample_name))


# sobj <- subset(sobj,
#               nCount_RNA > 500 &
#               nCount_RNA < 100000 &
#               percent.mt < 20) %>%
#     process_seurat()

# ncol(sobj)

# DimPlot(sobj)

# ann_sobj <- annotate(sobject = sobj,
#                          species = sobj$organism[1],
#                          aggr_ref = TRUE)

# DimPlot(ann_sobj, group.b = "annotations")

```

# Run QC and create merged Seurat Object
Will apply QC of ncount_min > 500 and number of cells > 200 cells per sample 
to be included into the merged seurat object per each group of patient_primary,
patient_metastatic, mouse_primary, mouse_metastatic, xenograft_primary_human,
xenograft_primary_mouse, xenograft_metastatic_human, and xenograft_metastatic_mouse
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
#harmony parameers
harmony_params <-
    list(patient_prim = list(group_by = c("sample_name", "method", "data_source"), 
                             theta = c(7, 7, 7)),
        patient_mets = list(group_by = c("sample_name", "method", "data_source"), 
                            theta = c(7, 7, 7)),
        xeno_prim_human = list(group_by = c("sample_name", "method", "data_source"),
                               theta = c(7, 7, 7)),
        xeno_mets_human = list(group_by = c("sample_name", "method", "data_source"),
                               theta = c(7, 7, 7)),
        xeno_prim_mouse = list(group_by = c("sample_name", "method", "data_source"),
                                theta = c(7, 7, 7)),
        xeno_mets_mouse = list(group_by = c("sample_name", "method", "data_source"),
                               theta = c(7, 7, 7)),
        mm_prim = list(group_by = c("sample_name", "model", "location"),
                       theta = c(7, 7, 7)),   
        mm_mets = list(group_by = c("sample_name", "model", "location"),
                       theta = c(7, 7, 7)),
        normal_bone = list(group_by = c("sample_name"),
                           theta = c(7)))

#run QC and merge seurat objects
#parallel::mclapply(unique(all_samples_csv$unique), function(group) 
for (group in unique(all_samples_csv$unique)){
    single_sobjs <- list.files(path = "output/seurat_objects/sobj_preprocess/",
                              full.names = FALSE)
    tmp_df <- subset(all_samples_csv, subset = (unique == group))
    temp_list <- list()
    nCount_min <- 500
    for (i in seq_len(nrow(tmp_df))) {
        sample_name <- tmp_df$sample_name[i]
        ncount_max <- tmp_df$ncount_max[i]
        mt_percent <- tmp_df$mt_percent[i]
        organism <- tmp_df$organism[i]
        dir <- str_c("output/seurat_objects/sobj_preprocess")
        sobject <- str_c(sample_name, "_", organism, ".qs")

        #check if the single seurat object exists and run QC
        if (file.exists(str_c(dir, "/", sobject))) {
            sobj <- qs::qread(str_c(dir, "/", sobject)) %>%
                process_seurat()
            Hmeta_data <- sobj@meta.data %>%
                    as.data.table
            counts <- Hmeta_data[, .N, by = "sample_name"]
            counts_after <- Hmeta_data %>%
                filter(nCount_RNA > nCount_min &
                    nCount_RNA < tmp_df$ncount_max[i] &
                    percent.mt < tmp_df$mt_percent[i]) %>%
                nrow()

            #QC for each sample preprocessed sobj and select for ones that have 200 cells atleast
            #if the cells are more than 5000, subset to 5000
            if (counts_after >= 200) {
                sobj <- subset(sobj,
                            nCount_RNA > nCount_min &
                            nCount_RNA < tmp_df$ncount_max[i] &
                            percent.mt < tmp_df$mt_percent[i])
                temp_list[[sample_name]] <- sobj
                set.seed(63274528)
                temp_list[[sample_name]] <- subset(x = temp_list[[sample_name]],
                                                    cells = sample(Cells(temp_list[[sample_name]]),
                                                            min(5000, length(Cells(temp_list[[sample_name]])))))
            } else {
                print(str_c(sample_name,
                            " has ",
                            counts_after,
                            " cells which is less than 200, hence discarded"))
            }
        } else {
            print(str_c(sample_name, " does not exist in the prepreocess folder"))
        }
    }
    merged_sobj <- merge(x = temp_list[[1]],
                        y = temp_list[2:length(temp_list)],
                        add.cell.id = names(temp_list)) %>%
        JoinLayers() %>%
        process_seurat()

    qs::qsave(merged_sobj, str_c("output/seurat_objects/comb_sobjs/",
                                    group,
                                    ".qs"))
    #run harmony
    run_harmony <- 
        RunHarmony(object = merged_sobj,
                    group.by.vars = harmony_params[[group]]$group_by,
                    theta = harmony_params[[group]]$theta)

    #optimize resolution, silhouette score does not work for large dataset
    min_cell_silhouette <- 65000
    n_cells <- length(Cells(run_harmony))
    keep_n_cells <- min(min_cell_silhouette, n_cells)
    set.seed(63249528)
    res_score <-
        optimize_silhouette(sobject = run_harmony[, sample(1:n_cells, keep_n_cells)],
                            test_res = seq(0.1, 0.9, by = 0.1),
                            summary_plot = FALSE,
                            reduction = "harmony") %>%
        filter(sil_vals == max(sil_vals)) %>%
        slice_head(n=1) %>%
        dplyr::pull(res_vals)

    harmony_obj <- 
        run_harmony %>% 
        process_seurat(reduction = "harmony",
                       resolution = res_score)

    qs::qsave(harmony_obj, str_c("output/seurat_objects/harmony_sobjs/",
                                    group,
                                    ".qs"))
}

```


# Count the number of cells per sample post QC
some of the samples are discarded as the ncountmin was set 500 and number of 
cells limit was set to 200 cells and above per sample. The upper cutoff was set 
as 5000 max cells per sample for similar dataset representation 
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
counts_afterQC <- tibble()

for (group in unique(all_samples_csv$unique)) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              group,
                              ".qs"))
    #DimPlot(object)
    #extract meta data
    Hmeta_data <- object@meta.data %>%
        as.data.table
    counts_afterQC <- Hmeta_data[, .N, by = c("sample_name", "unique")] %>% 
        rename(N_cells = N) %>%
        rbind(counts_afterQC) %>%
        arrange(unique)
}

DT::datatable(arrange(counts_afterQC, unique, desc(N_cells)))

```


# Data Integration Plots {.tabset}
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
BI_clusters <- list()
BI_method <- list()
BI_data_source <- list()

AI_clusters <- list()
AI_method <- list()
AI_data_source <- list()

for (group in unique(all_samples_csv$unique)){
    before_harmo_obj <- qs::qread(str_c("output/seurat_objects/comb_sobjs/",
                                        group,
                                        ".qs"))
    BI_clusters[[group]] <- plot_my_stuff(before_harmo_obj, "sample_name")
    BI_method[[group]] <- plot_my_stuff(before_harmo_obj, "method")
    BI_data_source[[group]] <- plot_my_stuff(before_harmo_obj, "data_source")

    harmo_obj <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                                group,
                                ".qs"))
    #optimize resolution, silhouette score does not work for large dataset
    min_cell_silhouette <- 65000
    n_cells <- length(Cells(harmo_obj))
    keep_n_cells <- min(min_cell_silhouette, n_cells)
    set.seed(63249528)
    res_score <-
        optimize_silhouette(sobject = harmo_obj[, sample(1:n_cells, keep_n_cells)],
                            test_res = seq(0.1, 0.9, by = 0.1),
                            summary_plot = FALSE,
                            reduction = "harmony") %>%
        filter(sil_vals == max(sil_vals)) %>%
        slice_head(n=1) %>%
        dplyr::pull(res_vals)
    print(str_c("Optimized resolution for ", group, " is ", res_score))

    AI_clusters[[group]] <- plot_my_stuff(harmo_obj, what = "sample_name")
    AI_method[[group]] <- plot_my_stuff(harmo_obj, "method")
    AI_data_source[[group]] <- plot_my_stuff(harmo_obj, "data_source")

}

```


## Plots for patient_prim before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
BI_clusters$patient_prim
BI_method$patient_prim
BI_data_source$patient_prim
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
AI_clusters$patient_prim
AI_method$patient_prim
AI_data_source$patient_prim
```

## Plots for patient_mets before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
BI_clusters$patient_mets
BI_method$patient_mets
BI_data_source$patient_mets
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
AI_clusters$patient_mets
AI_method$patient_mets
AI_data_source$patient_mets
```

## Plots for Xeno_prim_human before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
BI_clusters$xeno_prim_human
BI_method$xeno_prim_human
BI_data_source$xeno_prim_human
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
AI_clusters$xeno_prim_human
AI_method$xeno_prim_human
AI_data_source$xeno_prim_human
```

## Plots for Xeno_prim_mouse before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
BI_clusters$xeno_prim_mouse
BI_method$xeno_prim_mouse
BI_data_source$xeno_prim_mouse
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
AI_clusters$xeno_prim_mouse
AI_method$xeno_prim_mouse
AI_data_source$xeno_prim_mouse
```

## Plots for xeno_mets_human before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
BI_clusters$xeno_mets_human
BI_method$xeno_mets_human
BI_data_source$xeno_mets_human
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
AI_clusters$xeno_mets_human
AI_method$xeno_mets_human
AI_data_source$xeno_mets_human
```

## Plots for xeno_mets_mouse before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
BI_clusters$xeno_mets_mouse
BI_method$xeno_mets_mouse
BI_data_source$xeno_mets_mouse
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
AI_clusters$xeno_mets_mouse
AI_method$xeno_mets_mouse
AI_data_source$xeno_mets_mouse
```

## Plots for mm_prim before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
BI_clusters$mm_prim 
BI_method$mm_prim 
BI_data_source$mm_prim 
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
AI_clusters$mm_prim 
AI_method$mm_prim 
AI_data_source$mm_prim 
```

## Plots for mm_mets  before and after harmony integration
### Before Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
BI_clusters$mm_mets  
BI_method$mm_mets  
BI_data_source$mm_mets  
```

### After Integration
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
AI_clusters$mm_mets  
AI_method$mm_mets  
AI_data_source$mm_mets  
```

# Clustering and setting the right resolution {.tabset}
used silhouette score and clustree method for right resolution
```{r, fig.width = 10, fig.height = 10, fig.align = "center", echo = FALSE}
clustrees <- list()
silhouette_scores <- list()

for (group in unique(all_samples_csv$unique)) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              group,
                              ".qs"))

    resolution_range <- seq(from = 0, to = 1, by = 0.1)
    clustree_sobj <- FindClusters(object,
                                  resolution = resolution_range)
    tree <- clustree::clustree(clustree_sobj,
                               prefix = "RNA_snn_res.")

    clustrees[[group]] <- tree

    #optimize resolution, silhouette score does not work for large dataset
    min_cell_silhouette <- 65000
    n_cells <- length(Cells(object))
    keep_n_cells <- min(min_cell_silhouette, n_cells)
    set.seed(63249528)
    res_score <-
        optimize_silhouette(sobject = object[, sample(1:n_cells, keep_n_cells)],
                            test_res = seq(0.1, 0.9, by = 0.1),
                            summary_plot = FALSE,
                            reduction = "harmony") %>%
        filter(sil_vals == max(sil_vals)) %>%
        slice_head(n=1) %>%
        dplyr::pull(res_vals)
    print(str_c("Optimized resolution for ", group, " is ", res_score))

    silhouette_scores[[group]] <- res_score
}

```

## Clustering patient prim
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
clustrees$patient_prim
silhouette_scores$patient_mets

```

## Clustering patient mets
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
clustrees$patient_mets
silhouette_scores$patient_mets

```

# Annotate via Recurlstering all the datasets 
The anotate function was build by compliling publicly available reference 
comprising of lung, blood, and other primary cells for both human and mouse. 
Once the clustering resolution was set, we mount each seurat object for
celltype annotation using the annotate function. Then final celltype is
assigned by highest number of celltype per each seurat cluster
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval  = FALSE}

# DimPlot(new_ann_sobj, group.by = c("new_annot", "seurat_clusters"), raster=FALSE, shuffle = T)

# cancer_features <- c("COL1A1", "COL1A2", "SATB2", "RUNX2")

# fibroblast_markers <- c("LOXL1", "LUM", "COL5A1", "FBLN1", "FBLN2")

# immune_markers <- c("CD8A", "CD4", "CD3A", "KIR", "GGMB")

# proliferation <- c("MKI67", "PCNA", "MCM2")

# FeaturePlot(object, features = cancer_features)

# rrrSingleCellUtils::r_feature_plot(ann_sobj,
#                                    features = c("percent.mt", "nCount_RNA", "nFeature_RNA"))

for (group in unique(all_samples_csv$unique)){
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              group,
                              ".qs"))
    ann_sobj <- annotate(sobject = object,
                         species = object$organism[1],
                         aggr_ref = TRUE)

    Idents(ann_sobj) <- ann_sobj$seurat_clusters
    clust_info <- tibble()
    for (cluster in unique(ann_sobj$seurat_clusters)) {
        subset_object <- subset(ann_sobj, ident = cluster)
        subset_object <- process_seurat(subset_object)
        if (length(unique(subset_object$sample_name)) > 1 && ncol(subset_object) > 50 ) {
            subset_object <- RunHarmony(subset_object,
                                        group.by.vars = "sample_name") %>%
                process_seurat(reduction = "harmony")
        } else {
            subset_object <- subset_object
        }

        subset_object$re_cluster <- str_c(cluster, ".", subset_object$seurat_clusters)
        print(str_c("Done reclustering ", group, " ", cluster))
        clust_info <- subset_object@meta.data %>%
                as.data.frame() %>% 
                select(re_cluster) %>%
                rbind(clust_info)
    }
    ann_sobj <- AddMetaData(ann_sobj, metadata = clust_info)
    ann_sobj$new_annot_clust <- ann_sobj$re_cluster
    cluster_celltypes <-
        table(ann_sobj$re_cluster, ann_sobj$annotations) %>% 
        as.data.frame() %>% 
        group_by(Var1) %>%
        arrange(desc(Freq), .by_group = TRUE) %>%
        slice_head(n=1)
    for (item in seq_len(nrow(cluster_celltypes))) {
        seurat_clust <- str_c("^", cluster_celltypes$Var1[item], "$") %>%
            as.character()
        celltype <- cluster_celltypes$Var2[item] %>%
            as.character()
        ann_sobj$new_annot_clust <- str_replace_all(string = ann_sobj$new_annot_clust,
                                                    pattern = seurat_clust,
                                                    replacement = celltype)
    }
    qs::qsave(x = ann_sobj, 
              file = str_c("output/seurat_objects/harmony_sobjs/",
                                       group,
                                       ".qs"))
}


```

# Make plots for annotated datasets {.tabset}
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
singler_annotation <- list()
anotation_cluster_assignment <- list()
feature_plots <- list()

for (group in unique(all_samples_csv$unique)) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              group,
                              ".qs"))
    singler_annotation[[group]] <- plot_my_stuff(object, what = "annotations")
    anotation_cluster_assignment[[group]] <- plot_my_stuff(object, "new_annot_clust")

    if (object$organism[1] == "human") {
        feature_plots[[group]] <- FeaturePlot(object,
                                              features = c("COL1A1", "COL1A2", "SATB2", "RUNX2"))
    } else {
        feature_plots[[group]] <- FeaturePlot(object,
                                              features = c("Col1a1", "Col1a2", "Satb2", "Runx2"))
    }
}
```

## Patient prim 
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
singler_annotation$patient_prim
anotation_cluster_assignment$patient_prim
feature_plots$patient_prim
```

## Patient mets
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
singler_annotation$patient_mets
anotation_cluster_assignment$patient_mets
feature_plots$patient_mets
```

# Cancer cells vs normal cells using SCEVAN
Single CEll Variational Aneuploidy aNalysis
When run, the result is in three metadata column:
class: with tumor (blue) vs normal celltype(green), and (filtered (red): low quality cells i think)
subclone: clones numbered like a seurat clusters
SCEVAN starts from the raw count matrix removing irrelevant genes and cells. 
Identification of a small set of highly confident normal cells.
Relative gene expression obtained from removal of the baseline inferred from confident normal cells. 
Edge-preserving nonlinear diffusion filtering of relative gene expression. 
Segmentation with a variational region-growing algorithm. 
Identification of normal cells as those in the cluster containing the majority of confident normal cells. 
Segments are then classified in five copy number states.
Analysis of subclones including clone tree, pathway activities, but it can be turned off

```{r, fig.width = 10, fig.height = 10, fig.align = "center", echo = FALSE, eval = FALSE}

scevan_plots <- list()

for (group in unique(all_samples_csv$unique)) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              group,
                              ".qs"))
    if (ncol(object) > 10000) {
        object <- subset(x = object,
                                cells = sample(Cells(object),
                                        min(10000, length(Cells(object)))))
    } else {
        object <- object
    }

    count_mtx <- object@assays$RNA$counts
    results <- SCEVAN::pipelineCNA(count_mtx,
                                   organism = object$organism[1],
                                   par_cores = parallelly::availableCores(),
                                   plotTree = FALSE,
                                   SUBCLONES = FALSE)
    scv_object <- Seurat::AddMetaData(object, metadata = results)

    scevan_plots[[group]] <- plot_my_stuff(scv_object, "class")

    SCEVAN_annot <- table(scv_object$class)
    print(SCEVAN_annot)

    qs::qsave(scv_object, str_c("output/SCEVAN/",
                              group,
                              ".qs"))
}

```

# Cancer cells vs normal cells using scATOMIC 
The result comes with the annotation of cell types including for both cancer type 
and the normal cell types. Also outputs for each cell:
Classification_confidence: confident, low_confidence on annotation
pan_cancer_cluster: either cancer or normal
scATOMIC_pred : celltype annotation
```{r, fig.width = 10, fig.height = 10, fig.align = "center", echo = FALSE, eval = FALSE}

scATOMIC_plots <- list()

for (group in unique(all_samples_csv$unique)) {
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              group,
                              ".qs"))
    if (ncol(object) > 10000) {
        object <- subset(x = object,
                                cells = sample(Cells(object),
                                        min(10000, length(Cells(object)))))
    } else {
        object <- object
    }
    count_mtx <- object@assays$RNA$counts
    cell_predictions <- scATOMIC::run_scATOMIC(rna_counts = count_mtx,
                                               mc.cores = parallelly::availableCores())
    scATOMIC_results <- create_summary_matrix(prediction_list = cell_predictions, 
                                              use_CNVs = F, 
                                              modify_results = T, 
                                              mc.cores = parallelly::availableCores(), 
                                              raw_counts = count_mtx, 
                                              min_prop = 0.5 )
    scATOMIC_object <- AddMetaData(object, scATOMIC_results)

    scATOMIC_plots[[group]] <- plot_my_stuff(scATOMIC_object, "pan_cancer_cluster")

    sc_ATOMIC_annot <- table(scATOMIC_results$scATOMIC_pred)
    print(sc_ATOMIC_annot)

    qs::qsave(scATOMIC_object, str_c("output/scATOMIC/",
                                    group,
                                    ".qs"))
}
```

# SCEVAN and scATOMIC plots {.tabset}
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
scevan_plots <- list()
scATOMIC_plots <- list()
for (group in unique(all_samples_csv$unique)) {
    scevan_object <- qs::qread(str_c("output/SCEVAN/",
                                    group,
                                    ".qs"))
    scevan_plots[[group]] <- plot_my_stuff(scevan_object, "class")

    scATOMIC_object <- qs::qread(str_c("output/scATOMIC/",
                                    group,
                                    ".qs"))
    scATOMIC_plots[[group]] <- plot_my_stuff(scATOMIC_object, "pan_cancer_cluster")
}

```

## Patient primary
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
scevan_plots$patient_prim
scATOMIC_plots$patient_prim
```

## Patient mets
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
scevan_plots$patient_mets
scATOMIC_plots$patient_mets
```


# Split cancer vs the stroma - here
label potential tumor cell and then split the seurat object into cancer cells and
normal cells. The silhouette score was used to cluster the normal cells and 0.1
resolution was used to cluster the cancer cells (to reduce the excessive) 
clustering. 
It might be a worthwile to annotate or re run SCEVAN in the cancer cells to filter
out any normal cells that might have been group as cancer cells.

```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
cancer_celltypes <- list(patient_prim = c( "MSC",
                                           "Chondrocytes",
                                           "Tissue_stem_cells",
                                           "Neurons",
                                           "Osteoblasts",
                                           "Erythroblast",
                                           "Astrocyte",
                                           "BM",
                                           "Fibroblasts",
                                           "iPS_cells"),
                        patient_mets = c("MSC",
                                         "Chondrocytes",
                                         "Tissue_stem_cells",
                                         "Osteoblasts",
                                         "Smooth_muscle_cells",
                                         "Erythroblast",
                                         "Fibroblasts",
                                         "Astrocyte",
                                         "BM",
                                         "iPS_cells"),
                        xeno_prim_human = c(),
                        xeno_mets_human = c(),
                        xeno_prim_mouse = c(),
                        xeno_mets_mouse = c(),
                        normal_bone = c(),
                        mm_prim = c("Fibroblasts",
                                    "Stem cells",
                                    "Stromal cells",
                                    "Cardiomyocytes"),
                        mm_mets = c("Fibroblasts",
                                    "Stem cells",
                                    "Stromal cells",
                                    "Cardiomyocytes"))

harmony_params <-
    list(patient_prim = list(group_by = c("sample_name", "method", "data_source"), 
                             theta = c(7, 7, 7),
                             clustree_cancer_res = 0.1,
                             clustree_normal_res = ),
        patient_mets = list(group_by = c("sample_name", "method", "data_source"), 
                            theta = c(7, 7, 7),
                             clustree_cancer_res = 0.1,
                             clustree_normal_res = 0.2),
        xeno_prim_human = list(group_by = c("sample_name", "method", "data_source"),
                               theta = c(7, 7, 7),
                               clustree_cancer_res = ,
                               clustree_normal_res = ),
        xeno_mets_human = list(group_by = c("sample_name", "method", "data_source"),
                               theta = c(7, 7, 7),
                               clustree_cancer_res = ,
                               clustree_normal_res = ),
        xeno_prim_mouse = list(group_by = c("sample_name", "method", "data_source"),
                                theta = c(7, 7, 7),
                                clustree_cancer_res = ,
                                clustree_normal_res = ),
        xeno_mets_mouse = list(group_by = c("sample_name", "method", "data_source"),
                               theta = c(7, 7, 7),
                               clustree_cancer_res = ,
                               clustree_normal_res = ),
        mm_prim = list(group_by = c("sample_name", "model"),
                       theta = c(12, 12),
                       clustree_cancer_res = 0.2,
                       clustree_normal_res = 0.1),
        mm_mets = list(group_by = c("sample_name", "model"),
                       theta = c(7, 7),
                       clustree_cancer_res = ,
                       clustree_normal_res = ),
        normal_bone = list(group_by = c("sample_name"),
                           theta = c(7),
                           clustree_cancer_res = ,
                           clustree_normal_res =))


#parallel::mclapply(unique(all_samples_csv$unique), function(group) 
for (group in c("patient_prim", "patient_mets", "mm_prim", "mm_mets")) {
    object <- 
        qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                        group,
                        ".qs"))
    #plot_my_stuff(object, what = c("cell_group", "new_annot_clust", "sample_name"))
    Idents(object) <-
        object$new_annot_clust
    object$cancer_normal <-
        if_else(object$new_annot_clust %in% cancer_celltypes[[group]],
                "cancer_cells",
                object$new_annot_clust)
    object$cell_group <-
        if_else(object$new_annot_clust %in% cancer_celltypes[[group]],
                "cancer_cells",
                "normal_cells")
    qs::qsave(object, str_c("output/seurat_objects/annotated_sobjs/",
                            group,
                            ".qs"))

    for (cell_group_name in c("cancer_cells", "normal_cells")) {
        s_obj <-
            subset(x = object,
                   cell_group == cell_group_name) %>%
            process_seurat() %>%
            RunHarmony(group.by.vars = harmony_params[[group]]$group_by,
                       theta = harmony_params[[group]]$theta)

        # resolution_range <- seq(from = 0, to = 1, by = 0.1)
        # clustree_sobj <- FindClusters(s_obj,
        #                              resolution = resolution_range,
        #                              reduction = "harmony")
        # tree <- clustree::clustree(clustree_sobj,
        #                         prefix = "RNA_snn_res.")
    
        #optimize resolution, silhouette score does not work for large dataset
        min_cell_silhouette <- 65000
        n_cells <- length(Cells(s_obj))
        keep_n_cells <- min(min_cell_silhouette, n_cells)

        set.seed(1111471)
        res_normal <-
            optimize_silhouette(sobject = s_obj[, sample(1:n_cells, keep_n_cells)],
                                test_res = seq(0.05, 0.9, by = 0.05),
                                summary_plot = FALSE,
                                reduction = "harmony") %>%
            arrange(desc(sil_vals), desc(res_vals)) %>%
            filter(sil_vals == max(sil_vals)) %>%
            slice_head(n=1) %>%
            dplyr::pull(res_vals)

        s_obj <-
            s_obj %>%
            process_seurat(reduction = "harmony",
                           resolution = res_normal)
        #plot_my_stuff(s_obj, what = c("seurat_clusters", "new_annot_clust", "sample_name"))

        qs::qsave(s_obj, str_c("output/seurat_objects/tumor_vs_stroma/",  #nolint
                                group, "_",
                                cell_group_name,
                                ".qs"))

        #save the cancer object metadata with the cell barcodes
        date_time <- 
            format(Sys.time(), "%Y%m%d_%H%M%S")
        s_obj$cell_barcodes <- 
            colnames(s_obj)
        readr::write_tsv(x = s_obj@meta.data,
                        file = str_c("output/metadata/",
                                        group,
                                        "_cancer",
                                        date_time,
                                        ".tsv"))
    }
    print(str_c(group, " labelled with cancer_vs_normal cells and subsetted and saved"))
}

#save the xenograft objects
for (group in c("xeno_prim_human", "xeno_prim_mouse", "xeno_mets_human", "xeno_mets_mouse")) {
    object <- 
        qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                        group,
                        ".qs"))
    qs::qsave(object, str_c("output/seurat_objects/tumor_vs_stroma/",
                            group,
                            ".qs"))

    #save the cancer object metadata with the cell barcodes
    date_time <- 
        format(Sys.time(), "%Y%m%d_%H%M%S")
    object$cell_barcodes <- 
        colnames(object)
    readr::write_tsv(x = object@meta.data,
                    file = str_c("output/metadata/",
                                    group,
                                    date_time,
                                    ".tsv"))
}

```

# UMAPS combined and individual {.tabset}
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
#Checkups to make sure the outputs make sense

umaps_group <- 
    tribble(~sobj,            ~title,                  ~combine,
            "patient_prim",    "Patient Primary",      "no",
            "patient_mets",    "Patient Metastatic",   "no",
            "xeno_prim",       "Xenograft Primary",    "yes",
            "xeno_mets",       "Xenograft Metastatic", "yes",
            "mm_prim",         "Mouse Primary",        "no",
            "mm_mets",         "Mouse Metastatic",     "no")

annotated <- list()
merged <- list()
just_tumor <- list()
just_stroma <- list()


for (item in seq_len(nrow(umaps_group))) {
    sobj_name <- umaps_group$sobj[item]
    combine <- umaps_group$combine[item]
    title <- umaps_group$title[item]
    if (combine == "no") {
        object <-
            qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                            sobj_name,
                            ".qs"))
        annotated[[sobj_name]] <- 
            plot_my_stuff(object,
                          what = "new_annot_clust") +
                ggtitle("Annotated cell types by cluster")
        merged[[sobj_name]] <- 
            plot_my_stuff(object,
                          what = "cell_group") +
                ggtitle("Tumor and Stromal cells")
        
        #plot the tumor cells
        tumor <-
            qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                            sobj_name,
                            "_cancer_cells.qs"))
        just_tumor[[sobj_name]] <- 
            plot_my_stuff(tumor,
                          what = "seurat_clusters") +
                ggtitle("Tumor cells reclustering")

        #plot the stromal cells
        stroma <- 
            qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                            sobj_name,
                            "_normal_cells.qs"))
        just_stroma[[sobj_name]] <- 
            plot_my_stuff(stroma,
                          what = "cancer_normal") +
                ggtitle("Stromal cells reclustering")
    } else {
        first_obj <- 
            qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                            sobj_name,
                            "_human.qs"))
        just_tumor[[sobj_name]] <-
            plot_my_stuff(first_obj,
                          what = "seurat_clusters") +
                ggtitle("Tumor cells")

        second_obj <- 
            qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                            sobj_name,
                            "_mouse.qs"))
        just_stroma[[sobj_name]] <- 
            plot_my_stuff(second_obj,
                          what = "seurat_clusters") +
                ggtitle("Stromal cells")
    }
}
```

## UMAPS Patient primary
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
annotated$patient_prim
merged$patient_prim
just_tumor$patient_prim
just_stroma$patient_prim
```

## UMAPS Patient mets
```{r, fig.width = 10, fig.height = 10, fig.align = "center"}
annotated$patient_mets
merged$patient_mets
just_tumor$patient_mets
just_stroma$patient_mets
```

# calculate the celltype percentage and score per each clusters
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}
object_list <- 
    c("patient_prim_cancer_cells",
    "patient_mets_cancer_cells",
    "mm_prim_cancer_cells",
    "mm_mets_cancer_cells",
    "xeno_prim_human",
    "xeno_mets_human",
    "patient_prim_normal_cells",
    "patient_mets_normal_cells",
    "xeno_prim_mouse",
    "xeno_mets_mouse",
    "mm_prim_normal_cells",
    "mm_mets_normal_cells")

# Calculate cell type percentage for each object
all_data_celltypes <- tibble()
for (group in object_list) {
    object <- 
        qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                              group,
                              ".qs"))
    # plot_my_stuff(object, what = c("seurat_clusters", "new_annot_clust", "sample_name")) +
    #     ggtitle(group)
    object$cell_types_string <- "NA"
    object$med_cellscore_string <- "NA"
    celltype_df <-
        object@meta.data %>%
        select(seurat_clusters) %>%
        as_tibble() %>%
        mutate(group = group,
               assigned_celltype = NA,
               cell_types_string = NA,
               med_cellscore_string = NA,
               NCH_assignment = NA,
               NCI_assignment = NA,
               SJ_assignment = NA) %>%
        distinct() %>%
        arrange(seurat_clusters)
    for (i in seq_len(nrow(celltype_df))) {
        temp_obj <-
            subset(x = object,
                   seurat_clusters == celltype_df$seurat_clusters[i])
        cell_types_percent <- 
            table(temp_obj$annotations) %>%
            as.data.frame() %>%
            arrange(desc(Freq), .by_group = TRUE) %>%
            slice_head(n=5) %>%
            mutate(Percentage = Freq / sum(Freq) * 100) %>%
            group_by(Var1) %>%
            mutate(med_cellscore = median(temp_obj$cell_scores[temp_obj$annotations == Var1]) %>% 
                round(2))

        celltype_df$assigned_celltype[i] <- 
            cell_types_percent$Var1[1] %>%
            as.character()

        # Create a string of Var1 and Percentage
        celltype_df$cell_types_string[i] <- 
            paste(cell_types_percent$Var1,
                  cell_types_percent$Percentage %>% round(1),
                  sep = ":",
                  collapse = ",")

        celltype_df$med_cellscore_string[i] <- 
            paste(cell_types_percent$Var1, 
                  cell_types_percent$med_cellscore,
                  sep = ":",
                  collapse = ",")
    }

    all_data_celltypes <-
        celltype_df %>%
        rbind(all_data_celltypes)

    # Append the strings to the main object
    for (clusters in unique(object$seurat_clusters)) {
        object$cell_types_string[object$seurat_clusters == clusters] <- temp_list[[`clusters`]]$cell_types_string
        object$med_cellscore_string[object$seurat_clusters == clusters] <- temp_list[[`clusters`]]$med_cellscore_string
    }
    qs::qsave(object, 
              file = str_c("output/seurat_objects/tumor_vs_stroma/",
                                       group,
                                       ".qs"))
}

```


# Differential expression analysis for tumor cells {.tabset}
```{r, fig.width = 10, fig.height = 10, fig.align = "center", eval = FALSE}

theme_set(theme_classic(base_size = 20) +
            theme(axis.title.y = element_text(margin = margin(0, 20, 0, 0),
                                              size = 10,
                                              color = "black",
                                              face = "bold"),
                  axis.title.x = element_text(hjust = 0.5,
                                              margin = margin(20, 0, 0, 0),
                                              size = 10,
                                              color = "black",
                                              face = "bold"),
                  plot.title = element_text(hjust = 0.5,
                                            size = 10,
                                            face = "bold"),
                  legend.text = element_text(size = 8,
                                             face = "bold")))

#GSEA Miltilevel
cat_tib <- dplyr::tribble(
    ~category, ~subcategory,   ~cat_expl,
    "H",        "NA",          "Hallmark_paths",
    "C2",      "CP:KEGG",      "KEGG",
    "C3",      "TFT:GTRD",     "Transcription_factor_targets",
    "C6",       "NA",          "Oncogenic_signature")

object_list <- dplyr::tribble(~sobj_name,              ~species,
                            "patient_prim_cancer",    "human",
                            "patient_mets_cancer",    "human",
                            "mm_prim_cancer",         "mouse",
                            "mm_mets_cancer",         "mouse",
                            "xeno_prim_human_cancer", "human",
                            "xeno_mets_human_cancer", "human",
                            "patient_prim_normal",    "human",
                            "patient_mets_normal",    "human",
                            "xeno_prim_mouse",        "mouse",
                            "xeno_mets_mouse",        "mouse",
                            "mm_prim_normal",         "mouse",
                            "mm_mets_normal",         "mouse")

panel_plots <- list()

for (group in object_list$sobj_name) {
    object <- qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                              group,
                              ".qs"))
    object <- JoinLayers(object)

    volc_plot <- list()
    gsea_plot <- list()
    gsea_result <- list()

    dimplot <- plot_my_stuff(object, "seurat_clusters")

    degs_result <- run_degs(sobject = object,
                            group_by = "seurat_clusters",
                            prefix = str_c(group))

    for (item in names(degs_result)) {
        logfc_cutoff <- 0.6
        degs_result[[item]]$diffexpressed <- "Not Significant"
        degs_result[[item]]$diffexpressed[degs_result[[item]]$log2FoldChange > logfc_cutoff & degs_result[[item]]$padj < 0.05] <- "Upregulated"
        degs_result[[item]]$diffexpressed[degs_result[[item]]$log2FoldChange < -1 * logfc_cutoff & degs_result[[item]]$padj < 0.05] <- "Downregulated"
#make the volcano plot
        volc_plot[[item]] <- ggplot(data=degs_result[[item]],
                            aes(x=log2FoldChange,
                                y=-log10(pvalue),
                                color = diffexpressed)) + 
            geom_vline(xintercept = c(-1 * logfc_cutoff, logfc_cutoff), col = "gray", linetype = "dashed") + 
            geom_hline(yintercept = c(0.05), col = "gray", linetype = "dashed") +
            geom_point(size = 2) +
            scale_color_manual(values = c(plot_cols[1], "grey", plot_cols[2]),
                               name = "") +
            geom_text_repel(aes(label = gene))
    }
#GSEA analysis for the dotplots
    for (i in seq_len(nrow(cat_tib))){
        category <- cat_tib$category[i]
        subcategory <- cat_tib$subcategory[i]
        cat_expl <- cat_tib$cat_expl[i]
        if (subcategory == "NA") {
            gsea_result <- run_gsea(degs_result = degs_result,
                                    category = category,
                                    species = object$organism[1])
        } else {
            gsea_result <- run_gsea(degs_result = degs_result,
                                    category = category,
                                    subcategory = subcategory,
                                    species = object$organism[1])
        }
        for (item in names(gsea_result)) {
            rows <- gsea_result[[item]] %>% 
                nrow()
            if (rows >= 1) {
                top5up_down <- rbind(gsea_result[[item]] %>%
                                        slice_head(n = 7),
                                    gsea_result[[item]] %>%
                                        slice_tail(n = 7)) %>%
                                dplyr::select(pathway, NES, size, padj) %>%
                                arrange(desc(NES)) %>%
                                mutate(pathway = as.factor(pathway) %>%
                                            str_replace_all("_", " ") %>%
                                            str_wrap(65) %>%
                                            fct_reorder(NES),
                                       sample = item,
                                       order = seq_len(n()),
                                       justify_y = if_else(NES > 0, 1, 0),
                                       y_pos = if_else(NES > 0, -0.1, 0.1))
                gsea_plot[[cat_expl]][[item]] <- 
                    local({cat_expl = cat_expl
                          two_way_dotplot(top5up_down, x_col = "NES") +
                    ggtitle(str_c(cat_expl, " for ", item))})
            } else {
                print(str_c("No Pathways up or down in ", item, " for ", cat_expl))
                gsea_plot[[cat_expl]][[item]] <- 
                local({cat_expl = cat_expl
                      ggplot(data = NULL,
                            aes(x = as.factor(1),
                            y = as.factor(1))) +
                        geom_text(aes(label = str_c("No pathways for ", cat_expl, " in ", item)),
                                  size = 4)})
            }
        }
    }
#make panel plots
    for (clusters in names(volc_plot)) {
        panel_plots[[group]][[clusters]] <- gridExtra::grid.arrange(dimplot,
                                        volc_plot[[clusters]],
                                        gsea_plot$KEGG[[clusters]],
                                        gsea_plot$Hallmark_paths[[clusters]],
                                        gsea_plot$Oncogenic_signature[[clusters]],
                                        gsea_plot$Transcription_factor_targets[[clusters]],
                                        ncol = 2,
                                        top = clusters)

        ggsave(str_c("output/gsea/", group, "/", clusters, ".png"),
                width = 12,
                height = 18,
                plot = panel_plots[[group]][[clusters]])

        # print(dimplot)
        # print(gsea_plot$KEGG[[clusters]])
        # print(gsea_plot$Hallmark_paths[[clusters]])
        # print(volc_plot[[clusters]])
        # print(gsea_plot$Oncogenic_signature[[clusters]])
        # print(gsea_plot$Transcription_factor_targets[[clusters]])
        # r1 <- dimplot + 
        #       volc_plot[[clusters]] +
        #       gsea_plot$KEGG[[clusters]]
        # r2 <- gsea_plot$Hallmark[[clusters]] +
        #       gsea_plot$Oncogenic[[clusters]] +
        #       gsea_plot$TF_targets[[clusters]]
        # plots <- r1 / r2
    }
}

```

## Patient primary
```{r, fig.width = 14, fig.height = 20, fig.align = "center", eval = FALSE}
# for (item in names(panel_plots$patient_prim)) {
#     print(panel_plots$patient_prim[[item]])
# }
panel_plots$patient_prim$patient_prim_cancer_Cluster_0
panel_plots$patient_prim$patient_prim_cancer_Cluster_1
panel_plots$patient_prim$patient_prim_cancer_Cluster_2
panel_plots$patient_prim$patient_prim_cancer_Cluster_3
panel_plots$patient_prim$patient_prim_cancer_Cluster_4
panel_plots$patient_prim$patient_prim_cancer_Cluster_5
panel_plots$patient_prim$patient_prim_cancer_Cluster_6

```

## patient mets
```{r, fig.width = 14, fig.height = 20, fig.align = "center", eval = FALSE}
# for (item in names(panel_plots$patient_mets)) {
#     print(panel_plots$patient_mets[[item]])
# }
panel_plots$patient_mets$patient_mets_cancer_Cluster_0
panel_plots$patient_mets$patient_mets_cancer_Cluster_1
panel_plots$patient_mets$patient_mets_cancer_Cluster_2
panel_plots$patient_mets$patient_mets_cancer_Cluster_3
panel_plots$patient_mets$patient_mets_cancer_Cluster_4
panel_plots$patient_mets$patient_mets_cancer_Cluster_5
panel_plots$patient_mets$patient_mets_cancer_Cluster_6
panel_plots$patient_mets$patient_mets_cancer_Cluster_7
#panel_plots$patient_mets$patient_mets_cancer_Cluster_8
```


```{r, eval = FALSE}
for (group in unique(all_samples_csv$unique)) {
    object <- qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                              group,
                              "_cancer",
                              ".qs"))
    annot_sobj <- annotate(sobject = object,
                           species = object$organism[1],
                           aggr_ref = TRUE)
    DimPlot(annot_sobj, group.by = c("seurat_clusters", "annotations"))

    cluster_celltypes <-
        table(annot_sobj$seurat_clusters, annot_sobj$annotations) %>% 
        as.data.frame() %>%
        group_by(Var1) %>%
        arrange(desc(Freq), .by_group = TRUE) %>%
        slice_head(n=1)
    annot_sobj$new_annot <- annot_sobj$seurat_clusters
    for (item in seq_len(nrow(cluster_celltypes))) {
        seurat_clust <- str_c("^", cluster_celltypes$Var1[item], "$") %>%
            as.character()
        celltype <- cluster_celltypes$Var2[item] %>%
            as.character()
        annot_sobj$new_annot <- str_replace_all(string = annot_sobj$new_annot,
                                              pattern = seurat_clust,
                                              replacement = celltype)
    }
    DimPlot(annot_sobj, group.by = c("seurat_clusters", "new_annot", "annotations", "sample_name"), label = T)
    FeaturePlot(annot_sobj, features = c("MKI67", "SATB2"))
}

cells_iwant <- table(annot_sobj$annotations) %>% as.data.frame() %>% arrange(desc(Freq)) %>% filter(Freq > 500)
Idents(annot_sobj) <- annot_sobj$annotations
filt_annot_sobj <- subset(annot_sobj, idents = cells_iwant$Var1)
DimPlot(filt_annot_sobj, group.by = c("seurat_clusters", "new_annot", "annotations", "sample_name"), label = T)
```


# Stromal analysis
```{r, eval = FALSE}
human_lung <- qs::qread("input/downloads/human_lung.qs")  #no mtgenes
human_bone <- qs::qread("output/seurat_objects/annotated_sobjs/normal_bone.qs")  #has mt_percent
mouse_lung <- qs::qread("input/downloads/mouse_lung.qs")  #has mt. percent

DimPlot(human_lung, group.by = "free_annotation")


data1 <- read.csv("input/downloads/FilteredCounts10x.csv", row.names = 1)   #no mt. genes

sobj <- CreateSeuratObject(data1)

# Cutoff and cleaning
try_cutoff <- tribble(~feature,     ~min_val, ~max_val,
                      "nCount_RNA", 0,        30000,
                      "percent.mt", 0,        15)

features <- c("nFeature_RNA", "nCount_RNA", "percent.mt")    #nolint

# visualize the possible cutoff and adjust accordingly
feature_hist(sobject = sobj,
             features = features,                         # nolint
             cutoff_table = try_cutoff)

sobj <- sobj %>%
        subset(nCount_RNA < 30000) %>%
        process_seurat()

DimPlot(sobj)

mord <- celldex::MouseRNAseqData()
moim <- celldex::ImmGenData()
celldex_ref <-
    SingleR::SingleR(test = as.SingleCellExperiment(sobj),
                     ref = list(mord,
                                moim),
                     labels = list(mord$label.main,
                                   moim$label.main),
                     aggr.ref = TRUE)



moim$label.main <-
    stringr::str_replace_all(moim$label.main,
                            c("B cells, pro" = "B cells",
                                "DC" = "Dendritic cells"))
ref <- list(mord,
            moim)
labels <- list(mord[[label_type]],
                moim[[label_type]])


sobj_ann <- annotate(sobject = sobj,
                 species = "mouse",
                 aggr_ref = TRUE)



hpca <- celldex::HumanPrimaryCellAtlasData()

celldex_ref <-
    SingleR::SingleR(test = as.SingleCellExperiment(tumor_sobj_harmony),
                     ref = hpca,
                     labels = hpca$label.main,
                     aggr.ref = TRUE)

tumor_sobj_harmony$cell_dex <- celldex_ref$labels

#need mouse and human bones data too see the link in matt chat
stromal_normal_table <- tribble(~stromal,              ~normal,
                                "patient_prim_normal", "human_bone",
                                "patient_mets_normal", "human_lung",
                                "mm_prim_normal",      "mouse_bone",
                                "mm_mets_normal",      "mouse_lung",
                                "xeno_prim_mouse",     "mouse_bone",
                                "xeno_mets_mouse",     "mouse_lung")


#looks like there is no mitochondrial (MT-) genes in the human_lung cells
#mouse_lung has mt genes
#So need to remove the mitochondrial reads from the tumor associated too
for (item in rownames(human_lung)) {
  if (stringr::str_detect(item, "^MT-") == TRUE) {
      print(item)
  }
}

for (item in rownames(mouse_lung)) {
  if (stringr::str_detect(item, "^mt-") == TRUE) {
      print(item)
  }
}

for (item in rownames(human_lung)) {
  if (stringr::str_detect(item, "^MT[SL][[:digit:]]") == TRUE) {
      print(item)
  }
}

#Tumor associated lung cells
tumor_associated <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_normal.qs")

#gives the rownames with the MT- genes
mt_genes_rows <- grep("^MT-", rownames(tumor_associated))

nonmt_genes_rows <- grep("MT-", rownames(tumor_associated), invert = TRUE)

tumor_associated <- tumor_associated[nonmt_genes_rows, ]

for (item in rownames(tumor_associated)) {
  if (stringr::str_detect(item, "MT-") == TRUE) {
      print(item)
  }
}

#insert a column for the each seurat object for DEGs
human_lung@meta.data$type <- "normal"
tumor_associated@meta.data$type <- "tumor_associated"

#combine the seurat objects for DEGS by pseudobluk
sobj_comb <- merge(x = normal_lungs,
                   y = tumor_associated,
                   add.cell.id = c("normal", "tumor_associated"),
                   project = "sobj_comb")


#set the idents for the subsetting
Idents(sobj_comb) <- sobj_comb$new

#make a table of cell types you want from the tumor_associated
cellinfo <- table(tumor_associated$new) %>%
            as.data.frame() %>%
            filter(Freq > 10)

cellinfo$Var1 %>% as.character()
celltypes <- c("Alveolar Epithelial", "Bronchial Vessel",
                "CD4_plus Memory_Effector T",
                "Dendritic cells", "Macrophage",
                 "Plasma", "Vascular Smooth Muscle")

#subset the object with the cells you are interested in
Idents(sobj_comb) <- sobj_comb$new

subset_sobj_comb <- subset(sobj_comb,
                    idents = celltypes) %>%
            process_seurat(resolution = 0.1)

#visualize in dimplot
DimPlot(subset_sobj_comb, group.by = c("type", "new"))

harmony_sobj_comb <- harmony::RunHarmony(subset_sobj_comb,
                                group.by.vars = c("sample_name", "type"))

harmony_sobj_comb <- harmony_sobj_comb %>%
    process_seurat(reduction = "harmony",
                   resolution = 0.1)

DimPlot(harmony_sobj_comb, group.by = c("new", "sample_name", "type")) + coord_fixed()

combined <- DimPlot(harmony_sobj_comb,
                    group.by = "new",
                    repel = T,
                    label = T,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                #coord_fixed() +
                ggtitle("Combined with Celltypes") +
                theme(legend.text = element_text(size = 7))

Idents(harmony_sobj_comb) <- harmony_sobj_comb$type

split <- DimPlot(harmony_sobj_comb,
                    group.by = "type",
                    #split.by = "type",
                    label = TRUE,
                    cols = c(plot_cols, sample(rainbow(1000))),
                    shuffle = TRUE) +
            #NoLegend() +
            #coord_fixed() +
            ggtitle("Split by Type") +
            theme(legend.text = element_text(size = 10))
                    # coord_fixed() +
                    # ggtitle("UMAP for Normal and Tumor Associated Lung") +
                    # theme(plot.title = element_text(hjust = 0.5,
                    #                                 size = 20))

plots <- list(combined, split)
plot <- patchwork::wrap_plots(plots) + 
        patchwork::plot_annotation(title = str_c("UMAP for Normal and Tumor-Assocaited Lung"),
                                    theme = theme(plot.title = element_text(hjust = 0.5,
                                                                            size = 20,
                                                                            face = "bold")))

ggsave(str_c("output/plots/umaps/normal_stromal.png"),
            width = 13,
            height = 5,
            plot = plot)

calc_logfc <- function(sobj,
                       group_var,
                       group_1,
                       group_2,
                       epsilon = 1,
                       assay = "SCT") {
    all_obs_exp <-
        AverageExpression(sobj,
                          group.by = group_var,
                          assays = assay)[[1]] %>%
        as.data.frame()

    log_fc <-
        tibble(log_fc = log2((all_obs_exp[[group_1]] + epsilon) /
                             (all_obs_exp[[group_2]] + epsilon)),
               gene = rownames(all_obs_exp))

    return(log_fc)
}

watch this video for deseq in celltype level..
https://www.youtube.com/watch?v=04gB2owLKus&t=636s

Idents(harmony_sobj_comb) <- harmony_sobj_comb$new

degs_results <- list()

# for (celltypes in unique(harmony_sobj_comb$new)) {
#     df <- subset(x = harmony_sobj_comb,
#                 idents = celltypes)
#     Idents(df) <- df$type
#     temp <- FindMarkers(object = df,
#                         ident.1 = "tumor_associated",
#                         ident.2 = "normal",
#                         logfc.threshold = 0) %>%
#     arrange(desc(avg_log2FC)) %>%
#     rownames_to_column(var = "gene") %>%
#     dplyr::pull(avg_log2FC, name = gene)
#     celltypes <- gsub(" ", "", celltypes)
#     celltypes <- gsub("/", "_", celltypes)
#     celltypes <- gsub("+", "", celltypes)
#     degs_results[[celltypes]] <- temp
# }


for (celltypes in unique(harmony_sobj_comb$new)) {
    Idents(harmony_sobj_comb) <- harmony_sobj_comb$new
    df <- subset(x = harmony_sobj_comb,
                idents = celltypes)
    Idents(df) <- df$type
    degs_result <-
       calc_logfc(df,
                  group_var = "type",
                  group_1 = "tumor_associated",
                  group_2 = "normal",
                  epsilon = 1,
                  assay = "RNA") %>%
        arrange(desc(log_fc)) %>%
        #rownames_to_column(var = "gene") %>%
        dplyr::pull(log_fc, name = gene)
    celltypes <- gsub(" ", "", celltypes)
    celltypes <- gsub("/", "_", celltypes)
    celltypes <- gsub("+", "", celltypes)
    degs_results[[celltypes]] <- degs_result
}

gsea_ref <- msigdbr::msigdbr(species = "Homo sapiens",
                             category = "C2",
                             subcategory = "CP:KEGG") %>%
    split(x = .$gene_symbol, f = .$gs_name)


gsea_outputs <- list()

for (item in names(degs_results)) {
    gsea_output <- fgsea::fgseaMultilevel(gsea_ref,
                                        degs_results[[item]],
                                        minSize = 10,
                                        maxSize = 500,
                                        nPerm = 1000)
    gsea_outputs[[item]] <- gsea_output
}

for (item in names(gsea_outputs)) {
    top5up_down <- rbind(gsea_outputs[[item]] %>%
                            filter(NES > 0) %>%
                            slice_head(n = 5),
                         gsea_outputs[[item]] %>%
                            filter(NES < 0) %>%
                            slice_tail(n = 5)) %>%
                    dplyr::select(pathway,
                                    NES,
                                    size,
                                    padj) %>%
                    arrange(desc(NES)) %>%
                    mutate(pathway = as.factor(pathway) %>%
                            str_replace_all("_", " ") %>%
                            str_wrap(80) %>%
                            fct_reorder(NES),
                       sample = item,
                       order = 1:n(),
                       justify_y = if_else(NES > 0, 1, 0),
                       y_pos = if_else(NES > 0, -0.1, 0.1))
        plot_name <- two_way_plot(top5up_down, x_col = "NES")
        ggsave(str_c("output/plots/patient/gsea/gsea_",
                   item,
                   "_barplots.png"),
            width = 4,
            height = 3,
            plot = plot_name)

}

Idents(harmony_sobj_comb) <- harmony_sobj_comb$type

normal <- subset(harmony_sobj_comb, idents = "normal") %>% 
    FeaturePlot(features = abc)

subset(harmony_sobj_comb, idents = "tumor_associated") %>% 
    FeaturePlot(features = abc)

abc <- gsea_outputs$Macrophage$leadingEdge[1] %>% unlist()
adherens <- gsea_outputs$Macrophage$leadingEdge[3] %>% unlist()

sub_by_cell_type <-
    harmony_sobj_comb %>%
    subset(new == "Macrophage")

averageexp <-
    sub_by_cell_type %>%
    AverageExpression(features = adherens,
    group.by = c("sample_name"))

annot <-
    sub_by_cell_type@meta.data %>%
    select(type, new, sample_name) %>%
    distinct() %>%
    as_tibble() %>%
    mutate(label = sample_name) %>%
    select(-new, -sample_name) %>%
    column_to_rownames("label")

heatmap <- pheatmap::pheatmap(as.matrix(averageexp[[1]]),
                            annotation_col = annot,
                            cluster_cols = FALSE,
                            scale = "row",
                            color = viridis::viridis(n=256, alpha=1, begin=0, end=1, option = "viridis"),
                            fontsize = 8)

ggsave("output/plots/patient/heatmaps/macrophage_adh_heatmap.png",
            width = 10,
            height = 5,
            plot = heatmap)


sub_by_cell_type <-
    harmony_sobj_comb %>%
    subset(new == "Vascular Smooth Muscle" |
            new == "Plasma" |
            new == "Alveolar Epithelial")

averageexp <-
    sub_by_cell_type %>%
    AverageExpression(features = abc,
    group.by = c("new", "sample_name"))

annot <-
    sub_by_cell_type@meta.data %>%
    select(type, new, sample_name) %>%
    distinct() %>%
    as_tibble() %>%
    mutate(label = paste(new, sample_name, sep = "_")) %>%
    select(-new, -sample_name) %>%
    column_to_rownames("label")

pheatmap::pheatmap(as.matrix(averageexp[[1]]),
                   annotation_col = annot,
                   cluster_cols = FALSE)

```


# Regulons analysis
```{r, eval = FALSE}

library(SCENIC)
### 5. Loading Data
# 5.1 Loading data from seurat object
sobject <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_cancer.qs")


#If needed to subset to subset_cell_number cells for quicker run
Run_GRA <- function(sobject,
                    idents,
                    org,      #organism "mgi" for mouse, "hgnc" for human
                    subset = "no",          #yes or no
                    subset_cell_number = NA) {
    #if you want to quickly run a small subset of cells, set subset = "yes" and provide the subset_cell_number for number of cells
    if (subset == "yes") {
        sobject <- subset(x = sobject,
                                        cells = sample(Cells(sobject),
                                                min(subset_cell_number, length(Cells(sobject)))))
    } else {
        sobject <- sobject
    }
    sobject <- JoinLayers(sobject)
    exprMat <- SeuratObject::GetAssayData(sobject, assay = 'RNA', slot= 'counts') %>% 
        as.matrix()
    Idents(sobject) <- idents
    if (idents == "seurat_clusters") {
        cellInfo <- data.frame(CellType=Idents(sobject)) %>%
            dplyr::arrange(CellType)
    } else {
        cellInfo <- data.frame(CellType=Idents(sobject))
    }
    saveRDS(cellInfo, file="input/downloads/SCENIC/cellInfo.Rds")
    cols <- c(plot_cols, sample(rainbow(1000)))
    CellType <- cols[1:length(unique(cellInfo$CellType))]
    names(CellType) <- unique(cellInfo$CellType)
    colVars <- list()
    colVars$CellType <- CellType
    saveRDS(colVars, file="input/downloads/SCENIC/colVars.Rds")

    #Running SCENIC begins
    scenicOptions <- SCENIC::initializeScenic(org = org,
                                              dbDir = "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/SCENIC",
                                              dbs = SCENIC::defaultDbNames[[org]],
                                              datasetTitle = "SCENIC tutorial",
                                              nCores = parallelly::availableCores())

    scenicOptions@inputDatasetInfo$cellInfo <- "input/downloads/SCENIC/cellInfo.Rds"
    scenicOptions@inputDatasetInfo$colVars <- "input/downloads/SCENIC/colVars.Rds"

    ##### III: Co-expression network
    ### 1. Gene filter/selection
    genesKept <- SCENIC::geneFiltering(exprMat,
                                       scenicOptions=scenicOptions,
                                       minCountsPerGene=3*.01*ncol(exprMat),
                                       minSamples=ncol(exprMat)*.01)
    
    # filter the expression matrix to contain only these genes from geneskept.
    exprMat_filtered <- exprMat[genesKept, ]

    ### 2. Correlation: positive means TF could upregulate the target gene and viceversa
    SCENIC::runCorrelation(exprMat_filtered, scenicOptions)

    ### 3. Run GENIE3 to infer potential transcription factor targets
    # Optional: add log (if it is not logged/normalized already)
    exprMat_filtered <- log2(exprMat_filtered+1)

    # Run GENIE3 and find potential TF targets
    SCENIC::runGenie3(exprMat_filtered, scenicOptions)

    ###### IV: Build the gene regulatory network & Identify cell states:
    ### Build the gene regulatory network: 
    # 1. Get co-expression modules
    scenicOptions <- SCENIC::runSCENIC_1_coexNetwork2modules(scenicOptions)

    # 2. Get regulons (with RcisTarget: TF motif analysis)
    scenicOptions <- SCENIC::runSCENIC_2_createRegulons(scenicOptions,
                                                coexMethod=c("top5perTarget"))

    ### Identify cell states: 
    # 3. Score GRN (regulons) in the cells (with AUCell) 
    exprMat_log <- log2(exprMat+1)

    scenicOptions <- SCENIC::runSCENIC_3_scoreCells(scenicOptions, exprMat_log)

    # 4.2 Binarize the network activity (regulon on/off)
    scenicOptions@settings$devType = "png"
    scenicOptions <- SCENIC::runSCENIC_4_aucell_binarize(scenicOptions,
                                                         exprMat = exprMat_log)

    return(list(scenicOptions= scenicOptions,
                cellInfo = cellInfo,
                colVars = colVars,
                exprMat_log = exprMat_log))
}

library(SCENIC)
data(list="motifAnnotations_hgnc", package="RcisTarget")
motifAnnotations_hgnc <- motifAnnotations

data(list="motifAnnotations_mgi", package="RcisTarget")
motifAnnotations_mgi <- motifAnnotations

# 4.1 Run SCENIC
GRA_output <- Run_GRA(sobject = sobject,
                        idents = "seurat_clusters",
                        org = "hgnc",      
                        subset = "yes",          
                        subset_cell_number = 100)

exprMat_log <- GRA_output$exprMat_log
colVars <- GRA_output$colVars
cellInfo <- GRA_output$cellInfo
scenicOptions <- GRA_output$scenicOptions

# 4.3 Cluster cells according to the GRN activity (Optional)
# 4.3.1 set number of PCs
nPcs <- c(5) # For demo dataset, # nPcs <- c(5,15,50)

# 4.3.2 Calculates the t-SNE based on the regulon activity
scenicOptions@settings$seed <- 123    #same seed for all of them
fileNames <- SCENIC::tsneAUC(scenicOptions, aucType="AUC", nPcs= nPcs, perpl=c(5,15,50))
fileNames

### 4. combine SCENIC analysis with other analysis tools
#Regulators for known cell types or clusters
## 4.1 ComplexHeatmap to show average regulon activity by cell clusters
#scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")

library(ComplexHeatmap)
regulonAUC <- SCENIC::loadInt(scenicOptions, "aucell_regulonAUC")
regulonAUC <- regulonAUC[SCENIC::onlyNonDuplicatedExtended(rownames(regulonAUC)),]
regulonActivity_byCellType <- sapply(split(rownames(cellInfo), 
                cellInfo$CellType),
                function(cells) rowMeans(AUCell::getAUC(regulonAUC)[ , cells, drop=FALSE]))
regulonActivity_byCellType_Scaled <- t(scale(t(regulonActivity_byCellType), 
                                             center = T, scale=T))


png(filename = "output/Regulon_analysis/patient_mets_tumor/500cells_pprim_allRegulons.png",
    width = 2000,
    height = 4000,
    res = 300)
ComplexHeatmap::Heatmap(regulonActivity_byCellType_Scaled,
                       name="Regulon activity",
                       column_names_gp = grid::gpar(fontsize = 8),
                       row_names_gp = grid::gpar(fontsize = 8),
                       cluster_columns = FALSE,
                       show_row_dend = FALSE)
dev.off()

x <- pheatmap::pheatmap(regulonActivity_byCellType_Scaled,
                       name="Regulon activity",
                       scale="row",
                       cluster_cols = FALSE,
                       show_row_dend = FALSE)

ggsave("output/Regulon_analysis/patient_mets_tumor/500cells_pmets_allRegulons.png",
            width = 6,
            height = 10,
            plot = x)


# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Scaled)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>0),]
print(topRegulators)

library(SCENIC)

## 4.2 Binarized data
minPerc <- .4 # percentage of cells in a cluster with the regulon is active
binaryRegulonActivity <- loadInt(scenicOptions, "aucell_binary_nonDupl")
cellInfo_binarizedCells <- cellInfo[which(
  rownames(cellInfo)%in% colnames(binaryRegulonActivity)),, drop=FALSE]
regulonActivity_byCellType_Binarized <- sapply(
  split(rownames(cellInfo_binarizedCells), cellInfo_binarizedCells$CellType), 
        function(cells) rowMeans(binaryRegulonActivity[,cells, drop=FALSE]))
binaryActPerc_subset <- regulonActivity_byCellType_Binarized[which(
  rowSums(regulonActivity_byCellType_Binarized>minPerc)>0),]

ComplexHeatmap::Heatmap(binaryActPerc_subset, name="Regulon activity", 
                        col = c("white","pink","red"))

png(filename = "output/Regulon_analysis/patient_mets_tumor/500cells_pprim_topregulons.png",
    width = 4000,
    height = 1000,
    res = 300)

ComplexHeatmap::Heatmap(binaryActPerc_subset,
                       name="Regulon activity",
                       column_names_gp = grid::gpar(fontsize = 8),
                       row_names_gp = grid::gpar(fontsize = 8),
                       cluster_columns = FALSE,
                       show_row_dend = FALSE,
                       col = c("white","pink","red"))
dev.off()


# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Binarized)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>minPerc),]
print(topRegulators)

## 4.3 Cell-type specific regulators based on Regulon Specificity Score (RSS)
regulonAUC <- loadInt(scenicOptions, "aucell_regulonAUC")
rss <- calcRSS(AUC=AUCell::getAUC(regulonAUC), cellAnnotation=cellInfo[colnames(
  regulonAUC), "CellType"])

rss_for_Plot <- plotRSS(rss)

ggsave("output/Regulon_analysis/patient_mets_tumor/rssplot.png",
            #width = 6,
            #height = 10,
            plot = rss_for_Plot$plot)

rss_for_Plot$plot

plotly::ggplotly(p = rss_for_Plot$plot,
                 width = 3000,
                 height = 30000)










seuratobject <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_prim_tumor.qs")

seuratobject <-subset(x = seuratobject,
                     cells = sample(Cells(seuratobject),
                        min(100, length(Cells(seuratobject)))))

DimPlot(seuratobject, group.by = "seurat_clusters")

exprMat <- GetAssayData(seuratobject, assay='RNA', slot='counts') %>% 
    as.matrix(exprMat)

# cell information
Idents(seuratobject) <- seuratobject$seurat_clusters
cellInfo <- data.frame(CellType=Idents(seuratobject))
cbind(table(cellInfo$CellType))

saveRDS(cellInfo, file="input/downloads/SCENIC/cellInfo.Rds")

#color assign for celltypes for plots
colVars <- list(CellType = c("0" = "forestgreen",
                             "1" = "darkorange",
                             "2" = "red3",
                             "3" = "skyblue",
                             "4" = "magenta4",
                             "5" = "darkblue",
                             "6" = "hotpink"))

colVars$CellType <- colVars$CellType[intersect(names(colVars$CellType), cellInfo$CellType)]

saveRDS(colVars, file="input/downloads/SCENIC/colVars.Rds")

plot.new(); legend(0,1, fill=colVars$CellType, legend=names(colVars$CellType))

#set the organism
library(SCENIC)
org <- "hgnc"
dbDir <- "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/SCENIC"
myDatasetTitle <- "SCENIC tutorial"
data(defaultDbNames)
dbs <- defaultDbNames[[org]]

scenicoptions <- SCENIC::initializeScenic(org = org,
                                        dbDir = dbDir,
                                        dbs = dbs,
                                        datasetTitle = myDatasetTitle,
                                        nCores = 10)

motifAnnotations_hgnc <- motifAnnotations

scenicOptions <- SCENIC::initializeScenic(org = org,
                                        dbDir = dbDir,
                                        dbs = dbs,
                                        datasetTitle = myDatasetTitle,
                                        nCores = 10)

scenicOptions@inputDatasetInfo$cellInfo <- #cellInfo
    "input/downloads/SCENIC/cellInfo.Rds"

scenicOptions@inputDatasetInfo$colVars <- #colVars
    "input/downloads/SCENIC/colVars.Rds"

##### III: Co-expression network
### 1. Gene filter/selection
# (Adjust minimum values according to your dataset)
genesKept <- geneFiltering(exprMat, scenicOptions=scenicOptions,
                           minCountsPerGene=3*.01*ncol(exprMat),
                           minSamples=ncol(exprMat)*.01)

# check interesting genes
interestingGenes <- c("ISG15", "PTEN", "IL16", "FOXM1")
# any missing?
interestingGenes[which(!interestingGenes %in% genesKept)]

# filter the expression matrix to contain only these 770 genes. 
# This matrix is now ready for the co-expression analysis.
exprMat_filtered <- exprMat[genesKept, ]
dim(exprMat_filtered)

### 2. Correlation: positive means TF could upregulate the target gene and viceversa
runCorrelation(exprMat_filtered, scenicOptions)

### 3. Run GENIE3 to infer potential transcription factor targets
# Optional: add log (if it is not logged/normalized already)
exprMat_filtered <- log2(exprMat_filtered+1)

# Run GENIE3 and find potential TF targets
runGenie3(exprMat_filtered, scenicOptions)

###### IV: Build the gene regulatory network & Identify cell states:
### Build the gene regulatory network: 
# 1. Get co-expression modules
scenicOptions <- runSCENIC_1_coexNetwork2modules(scenicOptions)

# 2. Get regulons (with RcisTarget: TF motif analysis)
scenicOptions <- runSCENIC_2_createRegulons(scenicOptions,
                                            coexMethod=c("top5perTarget"))

### Identify cell states: 
# 3. Score GRN (regulons) in the cells (with AUCell) 
exprMat_log <- log2(exprMat+1)

scenicOptions <- runSCENIC_3_scoreCells(scenicOptions, exprMat_log)

###### Save the analysis
saveRDS(scenicOptions, 
        file="input/downloads/SCENIC/scenicOptions.Rds")


library(SCENIC)
scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")

# 4. Optional steps:
# 4.1 Look the results in shinyAPP
# aucellApp <- SCENIC::plotTsne_AUCellApp(scenicOptions, exprMat_log)
# savedSelections <- shiny::runApp(aucellApp)

# 4.2 Binarize the network activity (regulon on/off)
scenicOptions@settings$devType = "png"
scenicOptions <- SCENIC::runSCENIC_4_aucell_binarize(scenicOptions,
                                                     exprMat = exprMat_log)
                                                     #skipBoxplot = TRUE,
                                                     #skipHeatmaps = TRUE, 
                                                     #skipTsne = TRUE)

# 4.3 Cluster cells according to the GRN activity (Optional)
# 4.3.1 set number of PCs
nPcs <- c(5) # For demo dataset, # nPcs <- c(5,15,50)

# 4.3.2 Calculates the t-SNE based on the regulon activity
scenicOptions@settings$seed <- 123    #same seed for all of them
fileNames <- SCENIC::tsneAUC(scenicOptions, aucType="AUC", nPcs= nPcs, perpl=c(5,15,50))
fileNames

library(SCENIC)
par(mfrow=c(2,3))
plotTsne_compareSettings("int/tSNE_AUC_05pcs_05perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_AUC_05pcs_15perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_AUC_05pcs_50perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

# 4.3.3 Calculates the t-SNE using only "high-confidence" regulons
fileNames <- SCENIC::tsneAUC(scenicOptions, aucType="AUC", nPcs= nPcs, perpl=c(5,15,50),
                     onlyHighConf=TRUE, filePrefix="int/tSNE_oHC")
fileNames

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_05perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_15perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_50perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

# 4.3.4 Save defalt t-SNE
scenicOptions@settings$defaultTsne$aucType <- "AUC"
scenicOptions@settings$defaultTsne$dims <- 5
scenicOptions@settings$defaultTsne$perpl <- 15
saveRDS(scenicOptions,
        file="input/downloads/SCENIC/scenicOptions.Rds")

print(tsneFileName(scenicOptions))

### 1. Identify Cell states and their regulators
## 1.1 Projection the AUC and TF expression onto t-SNEs
# load data from int fold
SCENIC::loadInt(scenicOptions)
aucell_regulonAUC <- SCENIC::loadInt(scenicOptions, "aucell_regulonAUC")

SCENIC::tsneFileName(scenicOptions)
par(mfrow=c(2,3))
SCENIC::plotTsne_compareSettings(SCENIC::tsneFileName(scenicOptions), scenicOptions, 
                         showLegend=TRUE, varName="CellType", cex=.5)

# Show TF expression:
tSNE_scenic <- readRDS(SCENIC::tsneFileName(scenicOptions))

AUCell::AUCell_plotTSNE(tSNE_scenic$Y, exprMat,
  aucell_regulonAUC[SCENIC::onlyNonDuplicatedExtended(
    rownames(aucell_regulonAUC))[c("KLF6", "TBX21", "JUND", "CEBPD", "EOMES")],], 
  plots="Expression")

# Save AUC as PDF (Export):
dev.off()


#scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")


## 1.2 Density plot to detect most likely stable states (high density area)
library(KernSmooth)
library(RColorBrewer)
dens2d <- bkde2D(tSNE_scenic$Y, 1)$fhat
image(dens2d, col = brewer.pal(9, "YlOrBr"), axes=FALSE)
contour(dens2d, add = TRUE, nlevels= 5, drawlabels=FALSE)

### 2. Regulon targets
## Output file: Step2_regulonTargetsInfo

# subset regulonTargetsInfo before exporting it as HTML
regulonTargetsInfo <- SCENIC::loadInt(scenicOptions, "regulonTargetsInfo")
tableSubset <- regulonTargetsInfo[TF=="KLF6" & highConfAnnot==TRUE]
SCENIC::viewMotifs(tableSubset, options=list(pageLength=5))

# Targets for intereted TFs
regulons <- SCENIC::loadInt(scenicOptions, "regulons")
regulons[c("KLF6", "TBX21", "JUND", "CEBPD", "EOMES")]

# Only regulons with 10 genes or more are scored with AUCell
regulons <- SCENIC::loadInt(scenicOptions, "aucell_regulons")
head(cbind(SCENIC::onlyNonDuplicatedExtended(names(regulons))))

### 3. Regulon motifs
# The full list of TF motifs: Step2_MotifEnrichment

# showing motifs for interested TF
motifEnrichment_selfMotifs_wGenes <- SCENIC::loadInt(scenicOptions, 
                                    "motifEnrichment_selfMotifs_wGenes")
tableSubset <- motifEnrichment_selfMotifs_wGenes[highlightedTFs=="KLF6"]
SCENIC::viewMotifs(tableSubset)

### 4. combine SCENIC analysis with other analysis tools
#Regulators for known cell types or clusters
## 4.1 ComplexHeatmap to show average regulon activity by cell clusters
#scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")

library(ComplexHeatmap)
regulonAUC <- SCENIC::loadInt(scenicOptions, "aucell_regulonAUC")
regulonAUC <- regulonAUC[SCENIC::onlyNonDuplicatedExtended(rownames(regulonAUC)),]
regulonActivity_byCellType <- sapply(split(rownames(cellInfo), 
                cellInfo$CellType),
                function(cells) rowMeans(AUCell::getAUC(regulonAUC)[ , cells, drop = FALSE]))
regulonActivity_byCellType_Scaled <- t(scale(t(regulonActivity_byCellType), 
                                             center = T, scale=T))

ComplexHeatmap::Heatmap(
  regulonActivity_byCellType_Scaled, name="Regulon activity")

# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Scaled)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>0),]
print(topRegulators)

## 4.2 Binarized data
minPerc <- .4 # percentage of cells in a cluster with the regulon is active
binaryRegulonActivity <- loadInt(scenicOptions, "aucell_binary_nonDupl")
cellInfo_binarizedCells <- cellInfo[which(
  rownames(cellInfo)%in% colnames(binaryRegulonActivity)),, drop=FALSE]
regulonActivity_byCellType_Binarized <- sapply(
  split(rownames(cellInfo_binarizedCells), cellInfo_binarizedCells$CellType), 
        function(cells) rowMeans(binaryRegulonActivity[,cells, drop=FALSE]))
binaryActPerc_subset <- regulonActivity_byCellType_Binarized[which(
  rowSums(regulonActivity_byCellType_Binarized>minPerc)>0),]
ComplexHeatmap::Heatmap(binaryActPerc_subset, name="Regulon activity", 
                        col = c("white","pink","red"))

# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Binarized)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>minPerc),]
print(topRegulators)

## 4.3 Cell-type specific regulators based on Regulon Specificity Score (RSS)
regulonAUC <- loadInt(scenicOptions, "aucell_regulonAUC")
rss <- calcRSS(AUC=AUCell::getAUC(regulonAUC), cellAnnotation=cellInfo[colnames(
  regulonAUC), "CellType"])
rss_for_Plot <- plotRSS(rss)

plotly::ggplotly(rss_for_Plot$plot)











library(SCENIC)
scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")

# 4. Optional steps:
# 4.1 Look the results in shinyAPP
# aucellApp <- SCENIC::plotTsne_AUCellApp(scenicOptions, exprMat_log)
# savedSelections <- shiny::runApp(aucellApp)

# 4.2 Binarize the network activity (regulon on/off)
scenicOptions@settings$devType = "png"
scenicOptions <- SCENIC::runSCENIC_4_aucell_binarize(scenicOptions,
                                                     exprMat = exprMat_log)
                                                     #skipBoxplot = TRUE,
                                                     #skipHeatmaps = TRUE, 
                                                     #skipTsne = TRUE)

# 4.3 Cluster cells according to the GRN activity (Optional)
# 4.3.1 set number of PCs
nPcs <- c(5) # For demo dataset, # nPcs <- c(5,15,50)

# 4.3.2 Calculates the t-SNE based on the regulon activity
#scenicOptions@settings$seed <- 123    #same seed for all of them
fileNames <- SCENIC::tsneAUC(scenicOptions, aucType="AUC", nPcs= nPcs, perpl=c(5,15,50))
fileNames

library(SCENIC)
par(mfrow=c(2,3))
plotTsne_compareSettings("int/tSNE_AUC_05pcs_05perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_AUC_05pcs_15perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_AUC_05pcs_50perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

# 4.3.3 Calculates the t-SNE using only "high-confidence" regulons
fileNames <- SCENIC::tsneAUC(scenicOptions, aucType="AUC", nPcs= nPcs, perpl=c(5,15,50),
                     onlyHighConf=TRUE, filePrefix="int/tSNE_oHC")
fileNames

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_05perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_15perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_50perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

# 4.3.4 Save defalt t-SNE
scenicOptions@settings$defaultTsne$aucType <- "AUC"
scenicOptions@settings$defaultTsne$dims <- 5
scenicOptions@settings$defaultTsne$perpl <- 15
saveRDS(scenicOptions, 
        file="input/downloads/SCENIC/scenicOptions.Rds")

print(tsneFileName(scenicOptions))

### 1. Identify Cell states and their regulators
## 1.1 Projection the AUC and TF expression onto t-SNEs
# load data from int fold
SCENIC::loadInt(scenicOptions)
aucell_regulonAUC <- SCENIC::loadInt(scenicOptions, "aucell_regulonAUC")

SCENIC::tsneFileName(scenicOptions)
par(mfrow=c(2,3))
SCENIC::plotTsne_compareSettings(SCENIC::tsneFileName(scenicOptions), scenicOptions, 
                         showLegend=TRUE, varName="CellType", cex=.5)

# Show TF expression:
tSNE_scenic <- readRDS(SCENIC::tsneFileName(scenicOptions))
AUCell::AUCell_plotTSNE(tSNE_scenic$Y, exprMat,
  aucell_regulonAUC[SCENIC::onlyNonDuplicatedExtended(
    rownames(aucell_regulonAUC))[c("JUN", "FOS")],], 
  plots="Expression")

# Save AUC as PDF (Export):
dev.off()


#scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")


## 1.2 Density plot to detect most likely stable states (high density area)
library(KernSmooth)
library(RColorBrewer)
dens2d <- bkde2D(tSNE_scenic$Y, 1)$fhat
image(dens2d, col = brewer.pal(9, "YlOrBr"), axes=FALSE)
contour(dens2d, add = TRUE, nlevels= 5, drawlabels=FALSE)

### 2. Regulon targets
## Output file: Step2_regulonTargetsInfo

# subset regulonTargetsInfo before exporting it as HTML
regulonTargetsInfo <- SCENIC::loadInt(scenicOptions, "regulonTargetsInfo")
tableSubset <- regulonTargetsInfo[TF=="KLF6" & highConfAnnot==TRUE]
SCENIC::viewMotifs(tableSubset, options=list(pageLength=5))

# Targets for intereted TFs
regulons <- SCENIC::loadInt(scenicOptions, "regulons")
regulons[c("JUN", "FOS")]

# Only regulons with 10 genes or more are scored with AUCell
regulons <- SCENIC::loadInt(scenicOptions, "aucell_regulons")
head(cbind(SCENIC::onlyNonDuplicatedExtended(names(regulons))))

### 3. Regulon motifs
# The full list of TF motifs: Step2_MotifEnrichment

# showing motifs for interested TF
motifEnrichment_selfMotifs_wGenes <- SCENIC::loadInt(scenicOptions, 
                                    "motifEnrichment_selfMotifs_wGenes")
tableSubset <- motifEnrichment_selfMotifs_wGenes[highlightedTFs=="KLF6"]
SCENIC::viewMotifs(tableSubset)

### 4. combine SCENIC analysis with other analysis tools
#Regulators for known cell types or clusters
## 4.1 ComplexHeatmap to show average regulon activity by cell clusters
#scenicOptions <- readRDS("output/Regulon_analysis/patient_mets_tumor/scenicOptions.Rds")

library(ComplexHeatmap)
regulonAUC <- SCENIC::loadInt(scenicOptions, "aucell_regulonAUC")
regulonAUC <- regulonAUC[SCENIC::onlyNonDuplicatedExtended(rownames(regulonAUC)),]
regulonActivity_byCellType <- sapply(split(rownames(cellInfo), 
                                           cellInfo$CellType),
                function(cells) {
                    data <- AUCell::getAUC(regulonAUC)
                    data2 <- data[, cells]
                    rowMeans(AUCell::getAUC(regulonAUC)[, cells], drop=FALSE)
                })
regulonActivity_byCellType_Scaled <- t(scale(t(regulonActivity_byCellType), 
                                             center = T, scale=T))

ComplexHeatmap::Heatmap(
  regulonActivity_byCellType_Scaled, name="Regulon activity")

# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Scaled)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>0),]
print(topRegulators)

## 4.2 Binarized data
minPerc <- .4 # percentage of cells in a cluster with the regulon is active
binaryRegulonActivity <- loadInt(scenicOptions, "aucell_binary_nonDupl")
cellInfo_binarizedCells <- cellInfo[which(
  rownames(cellInfo)%in% colnames(binaryRegulonActivity)),, drop=FALSE]
regulonActivity_byCellType_Binarized <- sapply(
  split(rownames(cellInfo_binarizedCells), cellInfo_binarizedCells$CellType), 
        function(cells) rowMeans(binaryRegulonActivity[,cells, drop=FALSE]))
binaryActPerc_subset <- regulonActivity_byCellType_Binarized[which(
  rowSums(regulonActivity_byCellType_Binarized>minPerc)>0),]
ComplexHeatmap::Heatmap(binaryActPerc_subset, name="Regulon activity", 
                        col = c("white","pink","red"))

# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Binarized)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>minPerc),]
print(topRegulators)

## 4.3 Cell-type specific regulators based on Regulon Specificity Score (RSS)
regulonAUC <- loadInt(scenicOptions, "aucell_regulonAUC")
rss <- calcRSS(AUC=AUCell::getAUC(regulonAUC), cellAnnotation=cellInfo[colnames(
  regulonAUC), "CellType"])
rss_for_Plot <- plotRSS(rss)

plotly::ggplotly(rss_for_Plot$plot)





```


```{python, eval = FALSE}
import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import scvelo as scv #just using for dataset

import celloracle as co
from celloracle.applications import Pseudotime_calculator
from celloracle.applications import Gradient_calculator
from celloracle.applications import Oracle_development_module

adata = scv.datasets.pancreas()
InstallData("pbmc3k")
data("pbmc3k.final")
pbmc3k.final

library(scater)
library(Seurat)
library(cowplot)
sobj <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_tumor.qs")

pbmc_sce <- srt_to_adata(sobj)


sceasy::convertFormat(ad, from="anndata", to="seurat", outFile='file.rds')

pbmc_sce <- Convert(from = pbmc, to = "sce")


library(Seurat)
library(SeuratDisk)

# step 1: Slim down a Seurat object. So you get raw counts, lognorm counts

seu = DietSeurat(
  sobj,
  counts = TRUE, # so, raw counts save to adata.raw.X 
  data = TRUE, # so, log1p counts save to adata.X
  scale.data = FALSE, # set to false, or else will save to adata.X
  features = rownames(sobj), # export all genes, not just top highly variable genes
  assays = "RNA",
  dimreducs = c("pca","umap"),
  graphs = c("RNA_nn", "RNA_snn"), # to RNA_nn -> distances, RNA_snn -> connectivities
  misc = TRUE
)

# step 2: factor to character, or else your factor will be number in adata 
i <- sapply(seu@meta.data, is.factor)
seu@meta.data[i] <- lapply(seu@meta.data[i], as.character)

# step 3: convert 
SaveH5Seurat(seu, filename = "srt.h5seurat", overwrite = TRUE)

Convert("srt.h5seurat", "srt.h5ad", assay="RNA", overwrite = TRUE)

adata = sc.read_h5ad("srt.h5ad")


library(reticulate)
library(anndata)
library(sceasy)

library(Seurat)
library(SeuratData)

```




```{r, eval = FALSE}

seuratobject <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_tumor.qs")
DimPlot(seuratobject)

sobj <- subset(x = seuratobject,
                     cells = sample(Cells(seuratobject),
                        min(700, length(Cells(seuratobject)))))
DimPlot(sobj)

library(BITFAM)


Run_BITFAM <- function(sobj,
                       species = "",
                       idents = "",
                       plot = "",
                       scATAC_obj = NA,) {
    SeuratObject::Idents(sobj) <- idents
    raw_mtx <- sobj@assays$RNA@counts
    mtx <- BITFAM_preprocess(raw_data = raw_mtx)
    res <- BITFAM(data = mtx,
             species = "human",
             scATAC_obj = scATAC_obj,
             ncores = parallelly::availableCores())
    Z <- BITFAM_activities(res)
    Z_tsne <- as.data.frame(Rtsne(Z)$Y)
    colnames(Z_tsne) <- c("tSNE_1", "tSNE_2")
    Z_tsne$Cell_type <- Idents(sobj)
    if (plot == "TRUE") {
        ggplot(Z_tsne, aes(tSNE_1, tSNE_2, color = Cell_type)) + geom_point(size=0.8)
    } else if (plot == "FALSE") {
        tsne_plot <- ggplot(Z_tsne, aes(tSNE_1, tSNE_2, color = Cell_type)) + 
            geom_point(size=0.8)
        print("type tsne_plot in the R terminal to visualize the plot")
    }

    cell_type_df <- data.frame()
    for (item in unique(Idents(sobj))) {
        cell_type_df[[item]] <- ifelse(Idents(sobj) == "1", 1, 0)
    }


    cell_type_df <- data.frame(C1 = ifelse(sobj$seurat_clusters == "1", 1, 0),
                                C2 = ifelse(sobj$seurat_clusters == "2", 1, 0),
                                C3 = ifelse(sobj$seurat_clusters == "3", 1, 0),
                                C4 = ifelse(sobj$seurat_clusters == "4", 1, 0))

}


for (item in unique(Idents(sobj))) {
    print(item)
}




raw_mtx <- sobj@assays$RNA@counts

mtx <- BITFAM_preprocess(raw_data = raw_mtx)

res <- BITFAM(data = mtx,
             species = "human",
             scATAC_obj = NA,
             ncores = parallelly::availableCores())

#qs::qsave(res, "res.qs")

Z <- BITFAM_activities(res)
write.table(Z, file = "BITFAM_out.csv", sep = ",")
Z_tsne <- as.data.frame(Rtsne(Z)$Y)
colnames(Z_tsne) <- c("tSNE_1", "tSNE_2")


Z_tsne$Cell_type <- sobj$seurat_clusters
ggplot(Z_tsne, aes(tSNE_1, tSNE_2, color = Cell_type)) + geom_point(size=0.8)


cell_type_df <- data.frame(C1 = ifelse(sobj$seurat_clusters == "1", 1, 0),
                           C2 = ifelse(sobj$seurat_clusters == "2", 1, 0),
                           C3 = ifelse(sobj$seurat_clusters == "3", 1, 0),
                           C4 = ifelse(sobj$seurat_clusters == "4", 1, 0))

library(randomForest)




Z <- as.data.frame(Z)
Z_C1 <- cbind(Z, cell_type_df$C1) 
colnames(Z_C1)[157] <- "C1"
Z_C1$C1 <- factor(Z_C1$C1)
fit_rf <- randomForest(C1~., data = Z_C1)  ## build the RF model 
C1_tf_top10 <- importance(fit_rf)[order(importance(fit_rf)[, 1], decreasing = T), ][1:10]

```