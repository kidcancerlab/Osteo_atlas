---
title: "Osteosarcoma"
output: github_document
---

```{r setup, include=FALSE}
library(rrrSingleCellUtils)
library(Seurat)
library(ggrepel)
library(tidyverse)
library(stringr)
library(harmony)
library(cowplot)
library(clustree)
library(data.table)
set.seed(444)
```

## Download data from publications online
```{r}
#download from GSE152048
detail_subset <- read_tsv("sample_details.txt", show_col_types = FALSE) %>%
    filter(data_source == "GSE152048")

# Download, file, and extract the files from GEO
for (i in 1:nrow(detail_subset)) {                                     #nolint
    folder <- "input/downloads/"
    sample_name <- detail_subset$sample_name[i]
    site_link <- detail_subset$site_link[i]
    entire_path <- str_c(site_link, sample_name, ".matrix.tar.gz")
    tar_file <- str_c(folder, sample_name, ".tar.gz")
    system(paste0("wget ", entire_path, " -O ", tar_file))
    untar(tar_file, exdir = folder)
    file.remove(tar_file)
}


#download from GSE162454
detail_subset <- read_tsv("sample_details.txt", show_col_types = FALSE) %>%
    filter(data_source == "GSE162454")

for (i in 1:nrow(detail_subset)) {                                  #nolint
    folder <- "input/downloads/"
    tar_file <- str_c(folder, "GSE162454.tar.gz ")
    site_link <- detail_subset$site_link[i]
    sample_name <- detail_subset$sample_name[i]
    download.file(site_link, destfile = tar_file, method = "auto")
    untar(tar_file, exdir = folder)
    file.remove(tar_file)
    bfile <- str_c(detail_subset$pre[detail_subset$sample_name == sample_name], sample_name, "_barcodes.tsv.gz") #nolint
    ffile <- str_c(detail_subset$pre[detail_subset$sample_name == sample_name], sample_name, "_features.tsv.gz") #nolint
    mfile <- str_c(detail_subset$pre[detail_subset$sample_name == sample_name], sample_name, "_matrix.mtx.gz") #nolint
    samp_dir <- str_c(folder, sample_name)
    dir.create(samp_dir)
    file.rename(str_c(folder, "/", bfile),
      str_c(samp_dir, "/", "barcodes.tsv.gz"))
    file.rename(str_c(folder, "/", ffile),
      str_c(samp_dir, "/", "features.tsv.gz"))
    file.rename(str_c(folder, "/", mfile),
      str_c(samp_dir, "/", "matrix.mtx.gz"))
  }



#download from GSE169396
detail_subset <- read_tsv("sample_details.txt", show_col_types = FALSE) %>%
    filter(data_source == "GSE169396")

for (i in 1:nrow(detail_subset)) {                                  #nolint
    folder <- "input/downloads/"
    tar_file <- str_c(folder, "GSE169396.tar.gz ")
    site_link <- detail_subset$site_link[i]
    sample_name <- detail_subset$sample_name[i]
    download.file(site_link, destfile = tar_file, method = "auto")
    untar(tar_file, exdir = folder)
    file.remove(tar_file)
    bfile <- str_c(detail_subset$pre[detail_subset$sample_name == sample_name], sample_name, "_barcodes.tsv.gz") #nolint
    ffile <- str_c(detail_subset$pre[detail_subset$sample_name == sample_name], sample_name, "_features.tsv.gz") #nolint
    mfile <- str_c(detail_subset$pre[detail_subset$sample_name == sample_name], sample_name, "_matrix.mtx.gz") #nolint
    samp_dir <- str_c(folder, sample_name)
    dir.create(samp_dir)
    file.rename(str_c(folder, "/", bfile),
      str_c(samp_dir, "/", "barcodes.tsv.gz"))
    file.rename(str_c(folder, "/", ffile),
      str_c(samp_dir, "/", "features.tsv.gz"))
    file.rename(str_c(folder, "/", mfile),
      str_c(samp_dir, "/", "matrix.mtx.gz"))
  }




```

## reading dataset from our reservoir and download
```{r}
set.seed(75454)
sample_details <- read_tsv("sample_details.txt", show_col_types = FALSE)

sample_details$sp_pattern <-
    str_replace(sample_details$sp_pattern, "nothing", "")

#Seurat objects and save individual qs object
obj <- parallel::mclapply(seq_len(nrow(sample_details)), function(i) {
    sample_name <- sample_details$sample_name[i]
    sample_path <- sample_details$sample_path[i]
    species <- sample_details$species[i]
    tumor_type <- sample_details$tumor_type[i]
    data_source <- sample_details$data_source[i]
    sp_pattern <- sample_details$sp_pattern[i]
    organism <- sample_details$organism[i]
    download_path <- "input/downloads/"
    ours_path <- "/gpfs0/home2/gdrobertslab/lab/Counts/"

    if (data_source == "ours") {
        path_10x <- paste0(path_10x = ours_path,
                           sample_path,
                           "/filtered_feature_bc_matrix/")
    } else {
        path_10x <- paste0(path_10x = download_path, sample_name, "/")
    }
        sobj <- tenx_load_qc(path_10x = path_10x,
                             species_pattern = sp_pattern,
                             violin_plot = FALSE) %>%
            process_seurat()
        sobj$sample_name <- sample_details$sample_name[i]
        sobj$tumor_type <- sample_details$tumor_type[i]
        sobj$data_type <- sample_details$data_type[i]
        sobj$model <- sample_details$model[i]
        sobj$organism <- sample_details$organism[i]
        sobj$location <- sample_details$location[i]
        qs::qsave(sobj, str_c("output/seurat_objects/single_sobj", "/",
                              species, "/",
                              tumor_type, "/",
                              sample_name,
                              organism, ".qs"))
    return(0)
}, mc.cores = parallelly::availableCores())


# # individual QC numbers
# obj <- qs::qread("output/seurat_objects/single_sobj/patient/metastatic/SC073human.qs") #nolint

# # Cutoff and cleaning
# try_cutoff <- tribble(~feature,     ~min_val, ~max_val,
#                       "nCount_RNA", 0,        30000,
#                       "percent.mt", 0,        15)

# #features <- c("nFeature_RNA", "nCount_RNA", "percent.mt")    #nolint
# features <- "nCount_RNA"

# # visualize the possible cutoff and adjust accordingly
# feature_hist(sobject = obj,
#              features = features,                         # nolint
#              cutoff_table = try_cutoff)

#quality control and downsampling and saving the merged sobj
what <- parallel::mclapply(unique(sample_details$unique), function(item) {
    tmp_df <- subset(sample_details, subset = (unique == item))
    temp_list <- list()
    for (i in seq_len(nrow(tmp_df))) {
        species <- tmp_df$species[i]
        tumor_type <- tmp_df$tumor_type[i]
        sample_name <- tmp_df$sample_name[i]
        group_obj <- tmp_df$unique[i]
        organism <- tmp_df$organism[i]
        sobj <- qs::qread(str_c("output/seurat_objects/single_sobj/",
                                species, "/",
                                tumor_type, "/",
                                sample_name,
                                organism, ".qs"))
        # sobj <- auto_subset(sobject = sobj,
        #                     sd_down = 2,
        #                     sd_up = 3,
        #                     make_plots = FALSE,
        #                     features = c("nCount_RNA", "percent.mt"))
        sobj <- subset(sobj, 
                       nCount_RNA > 500 &
                       nCount_RNA < tmp_df$ncount_max[i] &
                       percent.mt < tmp_df$mt_percent[i])
        Hmeta_data <- sobj@meta.data %>%
            as.data.table
        counts <- Hmeta_data[, .N, by = "sample_name"]
        if (counts$N >= 100) {
            set.seed(1237)
            temp_list[[sample_name]] <- sobj
            temp_list[[sample_name]] <-
                    subset(x = temp_list[[sample_name]],
                    cells = sample(Cells(temp_list[[sample_name]]),
                            min(5000, length(Cells(temp_list[[sample_name]])))))
        } else {
            print(str_c(sample_name, " has less than 300 cells, hence discarded"))
        }
    }
    merged_sobj <- merge(x = temp_list[[1]],
                                y = temp_list[2:length(temp_list)],
                                add.cell.id = names(temp_list)) %>%
                    process_seurat()
    qs::qsave(merged_sobj, str_c("output/seurat_objects/comb_sobjs/",
                                    item,
                                    ".qs"))
    run_harmony <- RunHarmony(object = merged_sobj,
                              group.by.vars = c("sample_name", "model"),
                              theta = c(3, 3))
    run_harmony <- process_seurat(sobject = run_harmony,
                                  reduction = "harmony")
    res_score <- optimize_silhouette(sobject = run_harmony,
                         test_res = seq(0.1, 0.9, by = 0.1),
                         summary_plot = FALSE) %>%
        filter(sil_vals == max(sil_vals)) %>%
        slice_head(n=1) %>%
        dplyr::select(res_vals)
    run_harmony <- FindClusters(run_harmony,
                   resolution = res_score)
    qs::qsave(run_harmony, str_c("output/seurat_objects/harmony_sobjs/",
                                    item,
                                    ".qs"))
    return(item)
}, mc.cores = parallelly::availableCores())


#Count cells per sample and group
refs <- tribble(~sobj,            ~ref,
               "patient_prim",    "human",
               "normal_bone",     "human",
               "patient_mets",    "human_lung",
               "xeno_prim_human", "human",
               "xeno_mets_human", "human",
               "xeno_prim_mouse", "mouse",
               "xeno_mets_mouse", "mouse",
               "mm_prim",         "mouse",
               "mm_mets",         "mouse_lung")


#count the number of cells per sample per group
library(data.table)
counts <- list()

for (i in seq_len(nrow(refs))) {
    sobj <- refs$sobj[i]
    ref <- refs$ref[i]
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              sobj,
                              ".qs"))
    #DimPlot(object)
    #extract meta data
    Hmeta_data <- object@meta.data %>%
        as.data.table
    counts[[sobj]] <- Hmeta_data[, .N, by = "sample_name"] %>% 
        arrange(desc(N))
}

```



## Cell type annotaton function
```{r}
#loading the normal lungblood ref downloaded
human_lung <- qs::qread("input/downloads/normal_lung.qs")

human_lung$free_annotation <-
    str_replace_all(human_lung$free_annotation, c("/" = "_",
                                                  "\\+" = "_plus"))

human_lung$free_annotation <-
    stringr::str_replace_all(human_lung$free_annotation,
                              c("Alveolar Epithelial Type 1" = "Alveolar Epithelial",  #nolint
                                "Alveolar Epithelial Type 2" = "Alveolar Epithelial",  #nolint
                                "Basophil_Mast 1" = "Basophil_Mast",
                                "Basophil_Mast 2" = "Basophil_Mast",
                                "Bronchial Vessel 1" = "Bronchial Vessel",
                                "Bronchial Vessel 2" = "Bronchial Vessel",
                                "IGSF21_plus Dendritic" = "Dendritic cells",
                                "Myeloid Dendritic Type 1" = "Myeloid Dendritic",   #nolint
                                "Myeloid Dendritic Type 2" = "Myeloid Dendritic",   #nolint
                                "Natural Killer" = "NK cells",
                                "Natural Killer T" = "NKT",
                                "NK cells T" = "NKT",
                                "CD4_plus Memory/Effector T" = "CD4+ T cells",
                                "CD4_plus Naive T" = "CD4+ T cells",
                                "CD8_plus Memory_Effector T" = "CD8+ T cells",
                                "CD8_plus Naive T" = "CD8+ T cells",
                                "Proliferating NK_T" = "NKT",
                                "TREM2_plus Dendritic" = "Dendritic cells",
                                "Proliferating Macrophage" = "Macrophage",
                                "Nonclassical Monocyte" = "Monocytes",
                                "Classical Monocyte" = "Monocytes"))

#camilles paper mouse lung
mouse_lung <- qs::qread("input/downloads/mouse_lung.qs")

mouse_lung$CellType <-
            str_replace_all(mouse_lung$CellType, c("/" = "_",
                                                   "\\+" = "_plus",
                                                   "-" = "_"))

mouse_lung$CellType <-
    stringr::str_replace_all(mouse_lung$CellType,
                            c("Col14a1_plus fibroblast" = "Fibroblasts",
                              "Col13a1_plus fibroblast" = "Fibroblasts",
                              "AT1" = "AT",
                              "AT2 1" = "AT",
                              "AT2 2" = "AT",
                              "B cell 1" = "B cells",
                              "B cell 2" = "B cells",
                              "Cap_a" = "Cap",
                              "CD4 T cell 1" = "CD4",
                              "CD4 T cell 2" = "CD4",
                              "CD8 T cell 1" = "CD8",
                              "CD8 T cell 2" = "CD8",
                              "DC1" = "Dendritic cells",
                              "DC2" = "Dendritic cells",
                              "gd T cell" = "Tgd",
                              "Neut 1" = "Neutrophils",
                              "Neut 2" = "Neutrophils",
                              "NK cell" = "NK cells",
                              "Pericyte 1" = "Pericytes",
                              "Pericyte 2" = "Pericytes",
                              "Mast Ba2" = "Mast_Basophils",
                              "Mono" = "Monocytes"))

#function with mouse and human lung
annotate <- function(sobject,
                     species = "",
                     ref,
                     labels,
                     aggr_ref = FALSE,
                     label_type = "label.main",
                     ...) {
    if (species == "human") {
        hpca <- celldex::HumanPrimaryCellAtlasData()
        huim <- celldex::MonacoImmuneData()
        hpca$label.main <-
            stringr::str_replace_all(hpca$label.main,
                                     c("T_cells" = "T cells",
                                       "B_cell" = "B cells",
                                       "NK_cell" = "NK cells",
                                       "Monocyte" = "Monocytes",
                                       "DC" = "Dendritic cells"))
        ref <- list(hpca,
                    huim)
        labels <- list(hpca[[label_type]],
                      huim[[label_type]])
    } else if (species == "mouse") {
        mord <- celldex::MouseRNAseqData()
        moim <- celldex::ImmGenData()
        moim$label.main <-
            stringr::str_replace_all(moim$label.main,
                                    c("B cells, pro" = "B cells",
                                      "DC" = "Dendritic cells"))
        ref <- list(mord,
                    moim)
        labels <- list(mord[[label_type]],
                       moim[[label_type]])
    } else if (species == "human_lung") {
        hpca <- celldex::HumanPrimaryCellAtlasData()
        hpca$label.main <-
            stringr::str_replace_all(hpca$label.main,
                                     c("T_cells" = "T cells",
                                       "B_cell" = "B cells",
                                       "NK_cell" = "NK cells",
                                       "Monocyte" = "Monocytes",
                                       "DC" = "Dendritic cells"))
        huim <- celldex::MonacoImmuneData()
        ref3 <- GetAssayData(human_lung)
        ref <- list(hpca,
                    huim,
                    ref3)
        labels <- list(hpca[[label_type]],
                       huim[[label_type]],
                       human_lung$free_annotation)
    } else if (species == "mouse_lung") {
        mord <- celldex::MouseRNAseqData()
        moim <- celldex::ImmGenData()
        ref3 <- GetAssayData(mouse_lung)
        moim$label.main <-
            stringr::str_replace_all(moim$label.main,
                                    c("B cells, pro" = "B cells",
                                      "DC" = "Dendritic cells"))
        ref <- list(mord,
                    moim,
                    ref3)
        labels <- list(mord[[label_type]],
                       moim[[label_type]],
                       mouse_lung$CellType)
    }
    annotation <-
        SingleR::SingleR(test = Seurat::as.SingleCellExperiment(sobject),
                         ref = ref,
                         labels = labels,
                         aggr.ref = aggr_ref,
                         ...)
    sobject$annotations <- annotation$labels
    sobject$cell_scores <-
        apply(X = annotation$scores,
              MARGIN = 1,
              function(x) max(x, na.rm = TRUE))
    return(sobject)
}

```


## Annotate all the datasets
```{r}
#make table for what ref to use
refs <- tribble(~sobj,            ~ref,
               "patient_prim",    "human",
               "normal_bone",     "human",
               "patient_mets",    "human_lung",
               "xeno_prim_human", "human",
               "xeno_mets_human", "human",
               "xeno_prim_mouse", "mouse",
               "xeno_mets_mouse", "mouse",
               "mm_prim",         "mouse",
               "mm_mets",         "mouse_lung")



library(data.table)
counts <- list()

for (i in seq_len(nrow(refs))) {
    sobj <- refs$sobj[i]
    ref <- refs$ref[i]
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              sobj,
                              ".qs"))
    #DimPlot(object)
    #extract meta data
    Hmeta_data <- object@meta.data %>%
        as.data.table
    counts[[sobj]] <- Hmeta_data[, .N, by = "sample_name"]
}
#count number of cells per sample/seurat obj, to see if everything looks right



#annotate using the function parallelly
what <- parallel::mclapply(seq_len(nrow(refs)), function(i) {
    sobj <- refs$sobj[i]
    ref <- refs$ref[i]
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              sobj,
                              ".qs"))
    ann_sobj <- annotate(sobject = object,
                         species = ref,
                         aggr_ref = TRUE)
    cluster_celltypes <-
        table(ann_sobj$seurat_clusters, ann_sobj$annotations) %>% 
        as.data.frame() %>%
        group_by(Var1) %>%
        arrange(desc(Freq), .by_group = TRUE) %>%
        slice_head(n=1)
    ann_sobj$new <- ann_sobj$seurat_clusters
    for (item in seq_len(nrow(cluster_celltypes))) {
        seurat_clust <- str_c("^", cluster_celltypes$Var1[item], "$") %>%
            as.character()
        celltype <- cluster_celltypes$Var2[item] %>%
            as.character()
        ann_sobj$new <- str_replace_all(string = ann_sobj$new,
                                        pattern = seurat_clust,
                                        replacement = celltype)
    }
    # wanted_cells <- table(ann_sobj$annotations) %>%
    #     as.data.frame() %>%
    #     filter(Freq > 30)
    # Idents(ann_sobj) <- ann_sobj$annotations
    # filtered_ann_sobj <- subset(x = ann_sobj,
    #                             idents = wanted_cells$Var1)
    qs::qsave(ann_sobj, str_c("output/seurat_objects/harmony_sobjs/",
                                       sobj,
                                       ".qs"))
    print(str_c(ref, " ", "annotated", " ", sobj))
}, mc.cores = parallelly::availableCores())




```

## Cancer cells vs normal cells using SCEVAN
```{r}

ensamble_table <- tribble(~sobj,           ~species,
                        "patient_prim",    "human",
                        "patient_mets",    "human",
                        "mm_prim",         "mouse",
                        "mm_mets",         "mouse")

library(devtools)
install_github("miccec/yaGST", force = T)
install_github("AntonioDeFalco/SCEVAN")
library(SCEVAN)
library("yaGST")

tumor_ensamble <- parallel::mclapply(seq_len(nrow(ensamble_table)), function(item) {
    sobj <- ensamble_table$sobj[item]
    species <- ensamble_table$species[item]
    object <- qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                              sobj,
                              ".qs"))
    count_mtx <- object@assays$RNA@counts
    results <- SCEVAN::pipelineCNA(count_mtx,
                                   organism = species)
    object <- Seurat::AddMetaData(object, metadata = results)
    qs::qsave(object, str_c("output/seurat_objects/annotated_sobjs/",
                              sobj,
                              ".qs"))
}, mc.cores = parallelly::availableCores())

```


## Split cancer vs the stroma - here
label potential tumor cell and then split the object, run harmony and save

```{r}
refs <- tribble(~sobj,            ~split,   ~has_multiomics,
               "patient_prim",    "yes",    "no",
               "normal_bone",     "no",     "no",
               "patient_mets",    "yes",    "yes",
               "xeno_prim_human", "no",     "yes",
               "xeno_mets_human", "no",     "no",
               "xeno_prim_mouse", "no",     "yes",
               "xeno_mets_mouse", "no",     "no",
               "mm_prim",         "yes",    "no",
               "mm_mets",         "yes",    "no")

sobj <- qs::qread("output/seurat_objects/harmony_sobjs/mm_prim.qs")
DimPlot(sobj, group.by = c("seurat_clusters", "new"))

cancer_celltypes <- list(patient_prim = c( "MSC",
                                           "Chondrocytes"),
                        normal_bone = c(),
                        patient_mets = c("Myofibroblast",
                                         "MSC"),
                        xeno_prim_human = c(),
                        xeno_mets_human = c(),
                        xeno_prim_mouse = c(),
                        xeno_mets_mouse = c(),
                        mm_prim = c("Fibroblasts"),
                        mm_mets = c("Fibroblasts"))

tumor_vs_stroma <- parallel::mclapply(seq_len(nrow(refs)), function(item) {
    sobj <- refs$sobj[item]
    split <- refs$split[item]
    multiomics <- refs$has_multiomics[item]
    object <- qs::qread(str_c("output/seurat_objects/harmony_sobjs/",
                              sobj,
                              ".qs"))
    Idents(object) <- object$new
    for (cell in cancer_celltypes[[sobj]]) {
        object$new <- str_replace_all(string = object$new,
                                              pattern = cell,
                                              replacement = "cancer_cells")}
    qs::qsave(object, str_c("output/seurat_objects/annotated_sobjs/",
                            sobj,
                            ".qs"))
    object <- qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                              sobj,
                              ".qs"))
    if (split == "yes") {
        normal_cells <- table(object$new) %>%
            as.data.frame() %>%
            filter(Var1 != "cancer_cells")
        Idents(object) <- object$new
        normal_obj <- subset(x = object,
                             idents = normal_cells$Var1) %>%
            process_seurat()
        if (multiomics == "yes") {
            normal_obj <- RunHarmony(object = normal_obj,
                                     group.by.vars = c("sample_name", "model", "data_type"),  #nolint
                                     theta = c(3, 3, 3))
        } else {
            normal_obj <- RunHarmony(object = normal_obj,
                                     group.by.vars = c("sample_name", "model"),
                                     theta = c(3, 3))
        }
        res_normal <- optimize_silhouette(sobject = normal_obj,
                                         test_res = seq(0.1, 0.9, by = 0.1),
                                         summary_plot = FALSE) %>%
            filter(sil_vals == max(sil_vals)) %>%
            slice_head(n=1) %>%
            dplyr::select(res_vals)
        normal_obj <- normal_obj %>%
            process_seurat(reduction = "harmony",
                           resolution = res_normal)
        qs::qsave(normal_obj, str_c("output/seurat_objects/tumor_vs_stroma/",   #nolint
                                    sobj,
                                    "_normal",
                                    ".qs"))
        
        Idents(object) <- object$new
        cancer_obj <- subset(x = object,
                             idents = "cancer_cells") %>%
            process_seurat()
        if (multiomics == "yes") {
            cancer_obj <- RunHarmony(object = cancer_obj,
                                     group.by.vars = c("sample_name", "model", "data_type"),  #nolint
                                     theta = c(3, 3, 3))
        } else {
            cancer_obj <- RunHarmony(object = cancer_obj,
                                     group.by.vars = c("sample_name", "model"),
                                     theta = c(3, 3))
        }
        # res_cancer <- optimize_silhouette(sobject = cancer_obj,
        #                                  test_res = seq(0.1, 0.9, by = 0.1),
        #                                  summary_plot = FALSE) %>%
        #     filter(sil_vals == max(sil_vals)) %>%
        #     slice_head(n=1) %>%
        #     dplyr::select(res_vals)
        cancer_obj <- cancer_obj %>%
            process_seurat(reduction = "harmony",
                           resolution = 0.05)
        qs::qsave(cancer_obj, str_c("output/seurat_objects/tumor_vs_stroma/",  #nolint
                                    sobj,
                                    "_tumor",
                                    ".qs"))
    } else {
        qs::qsave(object, str_c("output/seurat_objects/tumor_vs_stroma/",
                                sobj,
                                ".qs"))
    }
    print(str_c(sobj, " labelled with cancer cells and subsetted"))
}, mc.cores = parallelly::availableCores())

```

## Umap

```{r}
#Checkups to make sure the outputs make sense

umaps_group <- 
    tribble(~sobj,            ~title,                ~combine,
            "patient_prim",    "Patient Primary",    "alone",
            "patient_mets",    "Patient Metastatic",    "alone",
            "xeno_prim",       "Xenograft Primary",    "comb_prim",
            "xeno_mets",       "Xenograft Metastatic",    "comb_mets",
            "mm_prim",         "Mouse Primary",          "alone",
            "mm_mets",         "Mouse Metastatic",    "alone")


for (item in seq_len(nrow(umaps_group))) {
    sobj_name <- umaps_group$sobj[item]
    combine <- umaps_group$combine[item]
    title <- umaps_group$title[item]
    if (combine == "alone") {
        sobject <- qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                            sobj_name,
                            ".qs"))
        x <- DimPlot(sobject,
                    group.by = "new",
                    repel = T,
                    label = T,
                    shuffle= T,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                coord_fixed() +
                ggtitle("Tumor and Stromal cells") +
                theme(legend.text = element_text(size = 7))


        tumor <- qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                            sobj_name,
                            "_tumor.qs"))
        y <- DimPlot(tumor,
                    group.by = "seurat_clusters",
                    repel = T,
                    label = T,
                    shuffle= T,
                    #label.size = 4,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                #coord_fixed() +
                ggtitle("Tumor cells reclustering") +
                theme(legend.text = element_text(size = 7))


        stroma <- qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                            sobj_name,
                            "_normal.qs"))
        z <- DimPlot(stroma,
                    group.by = "new",
                    repel = T,
                    label = T,
                    shuffle= T,
                    label.size = 4,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                coord_fixed() +
                ggtitle("Stromal cells reclustering") +
                theme(legend.text = element_text(size = 7))


        plots <- list(x, y, z)
        plot <- patchwork::wrap_plots(plots) + 
                patchwork::plot_annotation(title = str_c("UMAP for ", title),
                                           theme = theme(plot.title = element_text(hjust = 0.5,
                                                                                   size = 20,
                                                                                   face = "bold")))
        ggsave(str_c("output/plots/umaps/", sobj_name, "_umap.png"),
            width = 15,
            height = 5,
            plot = plot)
    } else {
        first_obj <- qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                                    sobj_name,
                                    "_human.qs"))
        x <- DimPlot(first_obj,
                    group.by = "seurat_clusters",
                    repel = T,
                    label = T,
                    shuffle= T,
                    label.size = 4,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                coord_fixed() +
                ggtitle("Tumor cells") +
                theme(legend.text = element_text(size = 7))

        second_obj <- qs::qread(str_c("output/seurat_objects/annotated_sobjs/",
                                    sobj_name,
                                    "_mouse.qs"))
        y <- DimPlot(second_obj,
                    group.by = "new",
                    repel = T,
                    label = T,
                    shuffle= T,
                    label.size = 4,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                coord_fixed() +
                ggtitle("Stromal cells") +
                theme(legend.text = element_text(size = 7))

        plots <- list(x, y)
        plot <- patchwork::wrap_plots(plots) + 
                patchwork::plot_annotation(title = str_c("UMAP for ", title),
                                           theme = theme(plot.title = element_text(hjust = 0.5,
                                                                                   size = 20,
                                                                                   face = "bold")))
        ggsave(str_c("output/plots/umaps/", sobj_name, "_umap.png"),
            width = 15,
            height = 5,
            plot = plot)
    }
    print(str_c("Done plotting for ", sobj_name))
}


annotated <- qs::qread("output/seurat_objects/annotated_sobjs/patient_prim.qs")
x <- DimPlot(annotated,
             group.by =  "new",
             repel = T,
             label = T) +
        theme_roberts() +
        ggtitle("Tumor and Stromal cells")


tumor <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_prim_tumor.qs")
y <- DimPlot(tumor,
             group.by = "seurat_clusters",
             repel = T,
             label = T) +
        theme_roberts() +
        ggtitle("Tumor cells reclustering")

stroma <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_prim_normal.qs")
z <- DimPlot(stroma,
             group.by = "new",
             repel = T,
             label = T) +
        theme_roberts() +
        ggtitle("Stromal cells reclustering")


plots <- list(x, y, z)

plot <- 
    patchwork::wrap_plots(plots) + 
    patchwork::plot_annotation(title = "xyz",
                        theme = theme(plot.title = element_text(hjust = 0.5)))




```

## DEGs and GSEA plot functions

```{r}

run_degs <- function(sobject,
                     group_by = "",
                     prefix = "") {
    if (group_by == "seurat_clusters") {
        sobject$pseudobulk_col <- stringr::str_c(sobject$sample_name,
                                 "-",
                                 sobject$seurat_clusters)
    } else if (group_by == "annotations") {
        sobject$annotations <-
            stringr::str_replace_all(sobject$annotations, " ", "")
        sobject$pseudobulk_col <- stringr::str_c(sobject$sample_name,
                                 "-",
                                 sobject$annotations)
    }
    pseudobulk <- Seurat::AggregateExpression(object = sobject,
                                      group.by = "pseudobulk_col",
                                      slot = "counts")[[1]]
    deseq_coldata <- data.frame(pseudobulk_group = colnames(pseudobulk))
    rownames(deseq_coldata) <- deseq_coldata$pseudobulk_group
    deseq_coldata <- tidyr::separate(data = deseq_coldata,
                          col = "pseudobulk_group",
                          into = c("sample_name", "group"),
                          sep = "-")
    deseq_coldata$type <- "single-read"
    deseq_coldata <- deseq_coldata[, -1]
    if (group_by == "seurat_clusters") {
        deseq_group <- levels(factor(sobject$seurat_clusters))
        names(deseq_group) <- paste0(prefix, "_Cluster_", deseq_group) #nolint
    } else if (group_by == "annotations") {
        deseq_group <- levels(factor(sobject$annotations))
        names(deseq_group) <- paste0(prefix, "_Celltype_", deseq_group) #nolint
    }
    degs_output <- list()
    for (group in names(deseq_group)) {
        interested_group <- deseq_group[group]
        other_group <- deseq_coldata
        other_group$group[other_group$group == interested_group] <- "target"  #nolint
        other_group$group[other_group$group != "target"] <- "other"         #nolint
        degs_output[[group]] <-
            DESeq2::DESeqDataSetFromMatrix(countData = pseudobulk,
                                           colData = other_group,
                                           design = ~ group) %>%
            DESeq2::DESeq() %>%
            DESeq2::results() %>%
            as.data.frame() %>%
            dplyr::arrange(desc(log2FoldChange)) %>%
            tibble::rownames_to_column("gene") %>%
            na.omit()
    }
    return(degs_output)
}


run_gsea <- function(degs_result,
                     category = "",
                     subcategory = "",
                     species = "") {
    gsea_ref <- msigdbr::msigdbr(species = species,
                                 category = category,
                                 subcategory = subcategory) %>%
        split(x = .$gene_symbol, f = .$gs_name)

    gsea_output <- list()
    for (item in names(degs_result)) {
        gsea_input <- as.vector(degs_result[[item]]$log2FoldChange)
        names(gsea_input) <- degs_result[[item]]$gene

        output <- fgsea::fgseaMultilevel(gsea_ref,
                                         gsea_input,
                                         minSize = 10,
                                         maxSize = 500,
                                         nPermSimple = 10000)
        gsea_output[[item]] <- output %>%
            dplyr::arrange(desc(NES)) %>%
            filter(padj < 0.05) %>%
            na.omit()
    }
    return(gsea_output)
}

#maybe write a tsv of the output

```

## Plots

```{r}

#two way dotplot
two_way_dotplot <- function(data, x_col = "z_score") {
    lab4plot <-
        tibble(y = c(-2.5, 2.5),
               x = c(0.2, 0.2),
               label = c("Downregulated", "Upregulated"))

    plot_name <-
        ggplot() +
        geom_point(data = data,
                 aes(x = -1 * order,
                     y = get(x_col),
                     color = -log10(padj),
                     size = size),
                 stat = "identity",
                 alpha = 0.8) +
        coord_flip() +
        # geom_hline(yintercept = 0,
        #             color = "black",
        #             linewidth = 0.5) +
        geom_text(data = data,                #text for pathways names
                    aes(x = -1 * order,
                        y = get(x_col) + (y_pos *5),
                        hjust = justify_y,
                        label = pathway),
                        size = 2,
                        fontface = "bold") +
        geom_text(data = lab4plot,    #text for upregulated/downregulated
                  aes(x = x,
                      y = y,
                      label = label),
                  fontface = "bold",
                  size = 2.5) +
        scale_fill_manual(values = plot_cols,
                          name = paste0(x_col, " > 0")) +
        theme(strip.background = element_rect(color = "white",
                                              fill = "white"),
              #legend.position = "none",
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              axis.line.x = element_line(color = "black"),
              axis.line.y = element_blank(),
              axis.title.x = element_text(size = 7),
              axis.ticks.y = element_blank(),
              plot.title = element_text(size = 7, face = "bold"),    #title of the plot
              axis.text.y = element_blank(),
              axis.text.x = element_text(size = 7),
              legend.title = element_text(size = 7,
                                          face = "bold")) +
        labs(title = data$sample[1],
             y = "NES",
             x = "") +
        theme(plot.title = element_text(hjust = 0.5)) +
        ylim(-6, 6) +
        scale_color_gradient(low = "pink", high = "darkred")

    return(plot_name)
}


two_way_plot <- function(data, x_col = "z_score") {
    lab4plot <-
        tibble(y = c(-3, 3),
               x = c(0.2, 0.2),
               label = c("Downregulated", "Upregulated"))

    plot_name <-
        ggplot() +
        geom_bar(data = data,
                 aes(x = -1 * order,
                     y = get(x_col),
                     fill = get(x_col) > 0),
                 stat = "identity",
                 alpha = 0.8) +
        coord_flip() +
        geom_hline(yintercept = 0,
                    color = "black",
                    linewidth = 0.5) +
        geom_text(data = data,                #text for pathways names
                    aes(x = -1 * order,
                        y = y_pos,
                        hjust = justify_y,
                        label = pathway),
                        size = 2,
                        fontface = "bold") +
        geom_text(data = lab4plot,    #text for upregulated/downregulated
                  aes(x = x,
                      y = y,
                      label = label),
                  fontface = "bold",
                  size = 2.5) +
        scale_fill_manual(values = plot_cols,
                          name = paste0(x_col, " > 0")) +
        theme(strip.background = element_rect(color = "white",
                                              fill = "white"),
              #legend.position = "none",
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              axis.line.x = element_line(color = "black"),
              axis.line.y = element_blank(),
              axis.title.x = element_text(size = 7),
              axis.ticks.y = element_blank(),
              plot.title = element_text(size = 7, face = "bold"),    #title of the plot
              axis.text.y = element_blank(),
              axis.text.x = element_text(size = 7),
              legend.title = element_text(size = 7,
                                          face = "bold")) +
        labs(title = data$sample[1],
             y = "NES",
             x = "") +
        theme(plot.title = element_text(hjust = 0.5)) +
        ylim(-6, 6) 

    return(plot_name)
}

tumor_list <- dplyr::tribble(~sobj_name,           ~species,
                    "patient_prim_tumor",    "human",
                    "patient_mets_tumor",    "human",
                    "mm_prim_tumor",         "mouse",
                    "mm_mets_tumor",         "mouse",
                    "xeno_prim_human",       "human",
                    "xeno_mets__human",      "human")

theme_set(theme_classic(base_size = 20) +
            theme(axis.title.y = element_text(margin = margin(0, 20, 0, 0),
                                              size = 10,
                                              color = "black",
                                              face = "bold"),
                  axis.title.x = element_text(hjust = 0.5,
                                              margin = margin(20, 0, 0, 0),
                                              size = 10,
                                              color = "black",
                                              face = "bold"),
                  plot.title = element_text(hjust = 0.5,
                                            size = 10,
                                            face = "bold"),
                  legend.text = element_text(size = 8,
                                             face = "bold")))

#GSEA Miltilevel
cat_tib <- dplyr::tribble(
    ~category, ~subcategory,   ~cat_expl,
    "H",        "NA",          "Hallmark_paths",
    "C2",      "CP:KEGG",      "KEGG",
    "C3",      "TFT:GTRD",     "Transcription_factor_targets",
    "C6",       "NA",          "Oncogenic_signature")

gsea <- parallel::mclapply(seq_len(nrow(tumor_list)), function(item) {
    sobj_name <- tumor_list$sobj_name[item]
    species <- tumor_list$species[item]
    sobj <- qs::qread(str_c("output/seurat_objects/tumor_vs_stroma/",
                            sobj_name,
                            ".qs"))
    volc_plot <- list()
    gsea_plot <- list()
    panel_plot <- list()
    gsea_result <- list()
    gsea_input <- list()
    degs <- list()

    dimplot <- DimPlot(sobj,
                       group.by = "seurat_clusters",
                       label = T,
                       cols = c(plot_cols, sample(rainbow(1000))),
                       shuffle = T)

#DEGS analysis
    degs_result <- run_degs(sobject = sobj,
                            group_by = "seurat_clusters",
                            prefix = sobj_name)

    for (item in names(degs_result)) {
#label the genes as up and down regulated
        logfc_cutoff <- 0.6
        degs_result[[item]]$diffexpressed <- "Not Significant"
        degs_result[[item]]$diffexpressed[degs_result[[item]]$log2FoldChange > logfc_cutoff & degs_result[[item]]$padj < 0.05] <- "Upregulated"
        degs_result[[item]]$diffexpressed[degs_result[[item]]$log2FoldChange < -1 * logfc_cutoff & degs_result[[item]]$padj < 0.05] <- "Downregulated"

#make the volcano plot
        volc_plot[[item]] <- ggplot(data=degs_result[[item]],
                            aes(x=log2FoldChange,
                                y=-log10(pvalue),
                                color = diffexpressed)) + 
            geom_vline(xintercept = c(-1 * logfc_cutoff, logfc_cutoff), col = "gray", linetype = "dashed") + 
            geom_hline(yintercept = c(0.05), col = "gray", linetype = "dashed") +
            geom_point(size = 2) +
            scale_color_manual(values = c(plot_cols[1], "grey", plot_cols[2]),
                               name = "") +
            geom_text_repel(aes(label = gene)) #+
            #ggtitle(item)
    }

#GSEA analysis for the matt's two way bar plots
    for (i in seq_len(nrow(cat_tib))){
        category <- cat_tib$category[i]
        subcategory <- cat_tib$subcategory[i]
        cat_expl <- cat_tib$cat_expl[i]
        if (subcategory == "NA") {
            gsea_result <- run_gsea(degs_result = degs_result,
                                    category = category,
                                    species = species)
        } else {
            gsea_result <- run_gsea(degs_result = degs_result,
                                    category = category,
                                    subcategory = subcategory,
                                    species = species)
        }
        for (item in names(gsea_result)) {
            rows <- gsea_result[[item]] %>% 
                nrow()
            if (rows >= 1) {
                top5up_down <- rbind(gsea_result[[item]] %>%
                                        #filter(NES > 0) %>%
                                        slice_head(n = 7),
                                    gsea_result[[item]] %>%
                                        #filter(NES < 0) %>%
                                        slice_tail(n = 7)) %>%
                                dplyr::select(pathway,
                                                NES,
                                                size,
                                                padj) %>%
                                arrange(desc(NES)) %>%
                                mutate(pathway = as.factor(pathway) %>%
                                            str_replace_all("_", " ") %>%
                                            str_wrap(65) %>%
                                            fct_reorder(NES),
                                       sample = item,
                                       order = seq_len(n()),
                                       justify_y = if_else(NES > 0, 1, 0),
                                       y_pos = if_else(NES > 0, -0.1, 0.1))
                gsea_plot[[cat_expl]][[item]] <- two_way_dotplot(top5up_down, x_col = "NES")
            } else {
                print(str_c("No Pathways up or down in ", item, " for ", cat_expl))
            }
        }
    }

#make panel plots
    for (clusters in names(volc_plot)) {
        plots <- gridExtra::grid.arrange(dimplot,
                    gsea_plot$KEGG[[clusters]],
                    gsea_plot$Hallmark_paths[[clusters]],
                    volc_plot[[clusters]],
                    gsea_plot$Oncogenic_signature[[clusters]],
                    gsea_plot$Transcription_factor_targets[[clusters]],
                    nrow = 2,
                    top = clusters)

#save the plots
        ggsave(str_c("output/gsea/tumor/",
                    sobj_name,
                    "/",
                    clusters,
                    ".png"),
                #width = 15,
                #height = 10,
                plot = plots)
    }
}, mc.cores = parallelly::availableCores())


```


## Stromal analysis
```{r}
human_lung <- qs::qread("input/downloads/human_lung.qs")  #no mtgenes
human_bone <- qs::qread("output/seurat_objects/annotated_sobjs/normal_bone.qs")  #has mt_percent
mouse_lung <- qs::qread("input/downloads/mouse_lung.qs")  #has mt. percent

DimPlot(human_lung, group.by = "free_annotation")


data1 <- read.csv("input/downloads/FilteredCounts10x.csv", row.names = 1)   #no mt. genes

sobj <- CreateSeuratObject(data1)

# Cutoff and cleaning
try_cutoff <- tribble(~feature,     ~min_val, ~max_val,
                      "nCount_RNA", 0,        30000,
                      "percent.mt", 0,        15)

features <- c("nFeature_RNA", "nCount_RNA", "percent.mt")    #nolint

# visualize the possible cutoff and adjust accordingly
feature_hist(sobject = sobj,
             features = features,                         # nolint
             cutoff_table = try_cutoff)

sobj <- sobj %>%
        subset(nCount_RNA < 30000) %>%
        process_seurat()

DimPlot(sobj)

mord <- celldex::MouseRNAseqData()
moim <- celldex::ImmGenData()
celldex_ref <-
    SingleR::SingleR(test = as.SingleCellExperiment(sobj),
                     ref = list(mord,
                                moim),
                     labels = list(mord$label.main,
                                   moim$label.main),
                     aggr.ref = TRUE)



moim$label.main <-
    stringr::str_replace_all(moim$label.main,
                            c("B cells, pro" = "B cells",
                                "DC" = "Dendritic cells"))
ref <- list(mord,
            moim)
labels <- list(mord[[label_type]],
                moim[[label_type]])


sobj_ann <- annotate(sobject = sobj,
                 species = "mouse",
                 aggr_ref = TRUE)



hpca <- celldex::HumanPrimaryCellAtlasData()

celldex_ref <-
    SingleR::SingleR(test = as.SingleCellExperiment(tumor_sobj_harmony),
                     ref = hpca,
                     labels = hpca$label.main,
                     aggr.ref = TRUE)

tumor_sobj_harmony$cell_dex <- celldex_ref$labels

#need mouse and human bones data too see the link in matt chat
stromal_normal_table <- tribble(~stromal,              ~normal,
                                "patient_prim_normal", "human_bone",
                                "patient_mets_normal", "human_lung",
                                "mm_prim_normal",      "mouse_bone",
                                "mm_mets_normal",      "mouse_lung",
                                "xeno_prim_mouse",     "mouse_bone",
                                "xeno_mets_mouse",     "mouse_lung")


#looks like there is no mitochondrial (MT-) genes in the human_lung cells
#mouse_lung has mt genes
#So need to remove the mitochondrial reads from the tumor associated too
for (item in rownames(human_lung)) {
  if (stringr::str_detect(item, "^MT-") == TRUE) {
      print(item)
  }
}

for (item in rownames(mouse_lung)) {
  if (stringr::str_detect(item, "^mt-") == TRUE) {
      print(item)
  }
}

for (item in rownames(human_lung)) {
  if (stringr::str_detect(item, "^MT[SL][[:digit:]]") == TRUE) {
      print(item)
  }
}

#Tumor associated lung cells
tumor_associated <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_normal.qs")

#gives the rownames with the MT- genes
mt_genes_rows <- grep("^MT-", rownames(tumor_associated))

nonmt_genes_rows <- grep("MT-", rownames(tumor_associated), invert = TRUE)

tumor_associated <- tumor_associated[nonmt_genes_rows, ]

for (item in rownames(tumor_associated)) {
  if (stringr::str_detect(item, "MT-") == TRUE) {
      print(item)
  }
}

#insert a column for the each seurat object for DEGs
human_lung@meta.data$type <- "normal"
tumor_associated@meta.data$type <- "tumor_associated"

#combine the seurat objects for DEGS by pseudobluk
sobj_comb <- merge(x = normal_lungs,
                   y = tumor_associated,
                   add.cell.id = c("normal", "tumor_associated"),
                   project = "sobj_comb")


#set the idents for the subsetting
Idents(sobj_comb) <- sobj_comb$new

#make a table of cell types you want from the tumor_associated
cellinfo <- table(tumor_associated$new) %>%
            as.data.frame() %>%
            filter(Freq > 10)

cellinfo$Var1 %>% as.character()
celltypes <- c("Alveolar Epithelial", "Bronchial Vessel",
                "CD4_plus Memory_Effector T",
                "Dendritic cells", "Macrophage",
                 "Plasma", "Vascular Smooth Muscle")

#subset the object with the cells you are interested in
Idents(sobj_comb) <- sobj_comb$new

subset_sobj_comb <- subset(sobj_comb,
                    idents = celltypes) %>%
            process_seurat(resolution = 0.1)

#visualize in dimplot
DimPlot(subset_sobj_comb, group.by = c("type", "new"))

harmony_sobj_comb <- harmony::RunHarmony(subset_sobj_comb,
                                group.by.vars = c("sample_name", "type"))

harmony_sobj_comb <- harmony_sobj_comb %>%
    process_seurat(reduction = "harmony",
                   resolution = 0.1)

DimPlot(harmony_sobj_comb, group.by = c("new", "sample_name", "type")) + coord_fixed()

combined <- DimPlot(harmony_sobj_comb,
                    group.by = "new",
                    repel = T,
                    label = T,
                    cols = c(plot_cols, sample(rainbow(1000)))) +
                NoLegend() +
                #coord_fixed() +
                ggtitle("Combined with Celltypes") +
                theme(legend.text = element_text(size = 7))

Idents(harmony_sobj_comb) <- harmony_sobj_comb$type

split <- DimPlot(harmony_sobj_comb,
                    group.by = "type",
                    #split.by = "type",
                    label = TRUE,
                    cols = c(plot_cols, sample(rainbow(1000))),
                    shuffle = TRUE) +
            #NoLegend() +
            #coord_fixed() +
            ggtitle("Split by Type") +
            theme(legend.text = element_text(size = 10))
                    # coord_fixed() +
                    # ggtitle("UMAP for Normal and Tumor Associated Lung") +
                    # theme(plot.title = element_text(hjust = 0.5,
                    #                                 size = 20))

plots <- list(combined, split)
plot <- patchwork::wrap_plots(plots) + 
        patchwork::plot_annotation(title = str_c("UMAP for Normal and Tumor-Assocaited Lung"),
                                    theme = theme(plot.title = element_text(hjust = 0.5,
                                                                            size = 20,
                                                                            face = "bold")))

ggsave(str_c("output/plots/umaps/normal_stromal.png"),
            width = 13,
            height = 5,
            plot = plot)

calc_logfc <- function(sobj,
                       group_var,
                       group_1,
                       group_2,
                       epsilon = 1,
                       assay = "SCT") {
    all_obs_exp <-
        AverageExpression(sobj,
                          group.by = group_var,
                          assays = assay)[[1]] %>%
        as.data.frame()

    log_fc <-
        tibble(log_fc = log2((all_obs_exp[[group_1]] + epsilon) /
                             (all_obs_exp[[group_2]] + epsilon)),
               gene = rownames(all_obs_exp))

    return(log_fc)
}

watch this video for deseq in celltype level..
https://www.youtube.com/watch?v=04gB2owLKus&t=636s

Idents(harmony_sobj_comb) <- harmony_sobj_comb$new

degs_results <- list()

# for (celltypes in unique(harmony_sobj_comb$new)) {
#     df <- subset(x = harmony_sobj_comb,
#                 idents = celltypes)
#     Idents(df) <- df$type
#     temp <- FindMarkers(object = df,
#                         ident.1 = "tumor_associated",
#                         ident.2 = "normal",
#                         logfc.threshold = 0) %>%
#     arrange(desc(avg_log2FC)) %>%
#     rownames_to_column(var = "gene") %>%
#     dplyr::pull(avg_log2FC, name = gene)
#     celltypes <- gsub(" ", "", celltypes)
#     celltypes <- gsub("/", "_", celltypes)
#     celltypes <- gsub("+", "", celltypes)
#     degs_results[[celltypes]] <- temp
# }


for (celltypes in unique(harmony_sobj_comb$new)) {
    Idents(harmony_sobj_comb) <- harmony_sobj_comb$new
    df <- subset(x = harmony_sobj_comb,
                idents = celltypes)
    Idents(df) <- df$type
    degs_result <-
       calc_logfc(df,
                  group_var = "type",
                  group_1 = "tumor_associated",
                  group_2 = "normal",
                  epsilon = 1,
                  assay = "RNA") %>%
        arrange(desc(log_fc)) %>%
        #rownames_to_column(var = "gene") %>%
        dplyr::pull(log_fc, name = gene)
    celltypes <- gsub(" ", "", celltypes)
    celltypes <- gsub("/", "_", celltypes)
    celltypes <- gsub("+", "", celltypes)
    degs_results[[celltypes]] <- degs_result
}

gsea_ref <- msigdbr::msigdbr(species = "Homo sapiens",
                             category = "C2",
                             subcategory = "CP:KEGG") %>%
    split(x = .$gene_symbol, f = .$gs_name)


gsea_outputs <- list()

for (item in names(degs_results)) {
    gsea_output <- fgsea::fgseaMultilevel(gsea_ref,
                                        degs_results[[item]],
                                        minSize = 10,
                                        maxSize = 500,
                                        nPerm = 1000)
    gsea_outputs[[item]] <- gsea_output
}

for (item in names(gsea_outputs)) {
    top5up_down <- rbind(gsea_outputs[[item]] %>%
                            filter(NES > 0) %>%
                            slice_head(n = 5),
                         gsea_outputs[[item]] %>%
                            filter(NES < 0) %>%
                            slice_tail(n = 5)) %>%
                    dplyr::select(pathway,
                                    NES,
                                    size,
                                    padj) %>%
                    arrange(desc(NES)) %>%
                    mutate(pathway = as.factor(pathway) %>%
                            str_replace_all("_", " ") %>%
                            str_wrap(80) %>%
                            fct_reorder(NES),
                       sample = item,
                       order = 1:n(),
                       justify_y = if_else(NES > 0, 1, 0),
                       y_pos = if_else(NES > 0, -0.1, 0.1))
        plot_name <- two_way_plot(top5up_down, x_col = "NES")
        ggsave(str_c("output/plots/patient/gsea/gsea_",
                   item,
                   "_barplots.png"),
            width = 4,
            height = 3,
            plot = plot_name)

}

Idents(harmony_sobj_comb) <- harmony_sobj_comb$type

normal <- subset(harmony_sobj_comb, idents = "normal") %>% 
    FeaturePlot(features = abc)

subset(harmony_sobj_comb, idents = "tumor_associated") %>% 
    FeaturePlot(features = abc)

abc <- gsea_outputs$Macrophage$leadingEdge[1] %>% unlist()
adherens <- gsea_outputs$Macrophage$leadingEdge[3] %>% unlist()

sub_by_cell_type <-
    harmony_sobj_comb %>%
    subset(new == "Macrophage")

averageexp <-
    sub_by_cell_type %>%
    AverageExpression(features = adherens,
    group.by = c("sample_name"))

annot <-
    sub_by_cell_type@meta.data %>%
    select(type, new, sample_name) %>%
    distinct() %>%
    as_tibble() %>%
    mutate(label = sample_name) %>%
    select(-new, -sample_name) %>%
    column_to_rownames("label")

heatmap <- pheatmap::pheatmap(as.matrix(averageexp[[1]]),
                            annotation_col = annot,
                            cluster_cols = FALSE,
                            scale = "row",
                            color = viridis::viridis(n=256, alpha=1, begin=0, end=1, option = "viridis"),
                            fontsize = 8)

ggsave("output/plots/patient/heatmaps/macrophage_adh_heatmap.png",
            width = 10,
            height = 5,
            plot = heatmap)


sub_by_cell_type <-
    harmony_sobj_comb %>%
    subset(new == "Vascular Smooth Muscle" |
            new == "Plasma" |
            new == "Alveolar Epithelial")

averageexp <-
    sub_by_cell_type %>%
    AverageExpression(features = abc,
    group.by = c("new", "sample_name"))

annot <-
    sub_by_cell_type@meta.data %>%
    select(type, new, sample_name) %>%
    distinct() %>%
    as_tibble() %>%
    mutate(label = paste(new, sample_name, sep = "_")) %>%
    select(-new, -sample_name) %>%
    column_to_rownames("label")

pheatmap::pheatmap(as.matrix(averageexp[[1]]),
                   annotation_col = annot,
                   cluster_cols = FALSE)

```






## Create metadata for anands
```{r}
all_samples_csv <- read_csv("allsample_details.csv")

# sample_name <- all_sample$sample_name

# startswith_OS <- sample_name %in% grep("SJOS", sample_name)

dir_list <- list.files(path = "/gpfs0/home2/gdrobertslab/lab/ExternalData/Patel_lab",
                      full.names = FALSE)

subset_file <- filter(all_samples_csv, sample_name %in% dir_list)

# subset_file$sample_name |> unique()
# stuff <- !dir_list %in% (subset_file$sample_name |> unique())
# list_want <- dir_list[stuff]
#write.csv(subset_file, "subset_file.csv")

for (item in seq_len(nrow(subset_file))) {
    sample_name <- subset_file$sample_name[i]
    species <- subset_file$species[i]
    tumor_type <- subset_file$tumor_type[i]
    data_source <- subset_file$data_source[i]
    sp_pattern <- subset_file$sp_pattern[i]
    organism <- subset_file$organism[i]
    object <- Read10X_h5(filename = str_c("/gpfs0/home2/gdrobertslab/lab/ExternalData/Patel_lab/",
                                          sample_name,
                                          "/filtered_feature_bc_matrix.h5"))
    sobj <- CreateSeuratObject(counts = object)

    sobj[["percent.mt"]] <- PercentageFeatureSet(sobj, pattern = "^MT-")
    sobj$unique <- subset_file$unique[item]
    sobj$sample_name <- subset_file$sample_name[item]
    sobj$tumor_type <- subset_file$tumor_type[item]
    sobj$data_type <- subset_file$data_type[item]
    sobj$model <- subset_file$model[item]
    sobj$organism <- subset_file$organism[item]
    sobj$location <- subset_file$location[item]

    qs::qsave(x = sobj,
              file = str_c("input/saint_jude/",
                        #    species, "/",
                        #    tumor_type, "/",
                           sample_name,
                           ".qs"))
}


for (item in unique(subset_file$unique)){
    tmp_df <- subset(subset_file, subset = (unique == item))
    temp_list <- list()
    nCount_min <- 500
    for (i in seq_len(nrow(tmp_df))) {
        sample_name <- tmp_df$sample_name[i]
        ncount_max <- tmp_df$ncount_max[i]
        mt_percent <- tmp_df$mt_percent[i]

        sobj <- qs::qread(str_c("input/saint_jude/",
                           sample_name,
                           ".qs"))
        
        Hmeta_data <- sobj@meta.data %>%
                as.data.table
        counts <- Hmeta_data[, .N, by = "sample_name"]

        counts_after <- Hmeta_data %>%
            filter(nCount_RNA > nCount_min &
                   nCount_RNA < tmp_df$ncount_max[i] &
                   percent.mt < tmp_df$mt_percent[i]) %>%
            nrow()

        if (counts_after >= 100) {
            sobj <- subset(sobj,
                           nCount_RNA > nCount_min &
                           nCount_RNA < tmp_df$ncount_max[i] &
                           percent.mt < tmp_df$mt_percent[i])
            temp_list[[sample_name]] <- sobj
        } else {
            print(str_c(sample_name,
                        " has ",
                        counts_after,
                        " cells which is less than 300, hence discarded"))
        }
    }
    merged_sobj <- merge(x = temp_list[[1]],
                            y = temp_list[2:length(temp_list)],
                            add.cell.id = names(temp_list)) %>%
                process_seurat()
    qs::qsave(merged_sobj, str_c("output/seurat_objects/st_jude/",
                                    item,
                                    ".qs"))
}


counts <- list()
for (item in unique(subset_file$unique)){
    sobj <- qs::qread(str_c("output/seurat_objects/st_jude/",
                            item,
                            ".qs"))
    DimPlot(sobj)
    Hmeta_data <- sobj@meta.data %>%
                as.data.table
    counts[[item]] <- Hmeta_data[, .N, by = "sample_name"] %>% 
        arrange(desc(N))
}


# individual QC numbers
obj <- qs::qread("output/seurat_objects/st_jude/patient_mets.qs") #nolint

# Cutoff and cleaning
try_cutoff <- tribble(~feature,     ~min_val, ~max_val,
                      "nCount_RNA", 1000,        30000,
                      "percent.mt", 0,        15)

features <- c("nFeature_RNA", "nCount_RNA", "percent.mt")    #nolint

# visualize the possible cutoff and adjust accordingly
feature_hist(sobject = obj,
             features = features,                         # nolint
             cutoff_table = try_cutoff)



# Run Liger
obj <- qs::qread("output/seurat_objects/st_jude/patient_mets.qs") #nolint

DimPlot(obj, group.by = "sample_name")

# harmony_sobj <- RunHarmony(obj, group.by.vars = "sample_name")
# harmony_sobj <- harmony_sobj %>% process_seurat(reduction = "harmony")
# DimPlot(harmony_sobj, group.by = "sample_name", shuffle = T)

library(rliger)
object <- sobj@assays$RNA@counts

liger_sobj <- createLiger(object)


object <- CreateSeuratObject(object)

object <- object %>%
    NormalizeData() %>%
    FindVariableFeatures() %>% 
    ScaleData(split.by= "orig.ident")

sobj_liger <- optimizeALS(object,
                                  k = 20,
                                  lambda = 5,
                                  split.by = "orig.ident")

```





## Regulons analysis
```{r}
### 5. Loading Data
# 5.1 Loading data from seurat object
seuratobject <- pbmc3k.SeuratData::pbmc3k %>% 
    process_seurat() %>%
    subset(seurat_annotations == c("Naive CD4 T",
                                   "Memory CD4 T",
                                   "NK",
                                   "B",
                                   "CD8 T"))

seuratobject <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_tumor.qs")

#need to downsample to reduce the time 
seuratobject <-subset(x = seuratobject,
                     cells = sample(Cells(seuratobject),
                        min(3000, length(Cells(seuratobject)))))

DimPlot(seuratobject, group.by = "seurat_clusters")

exprMat <- GetAssayData(seuratobject, assay='RNA', slot='counts') %>% 
    as.matrix(exprMat)

# cell information
Idents(seuratobject) <- seuratobject$seurat_clusters
cellInfo <- data.frame(CellType=Idents(seuratobject))
cbind(table(cellInfo$CellType))

saveRDS(cellInfo, file="input/downloads/SCENIC/cellInfo.Rds")

#color assign for celltypes for plots
colVars <- list(CellType = c("0" = "forestgreen",
                             "1" = "darkorange",
                             "2" = "red3",
                             "3" = "skyblue"))

colVars$CellType <- colVars$CellType[intersect(names(colVars$CellType), cellInfo$CellType)]

saveRDS(colVars, file="input/downloads/SCENIC/colVars.Rds")

plot.new(); legend(0,1, fill=colVars$CellType, legend=names(colVars$CellType))

#set the organism
library(SCENIC)
org <- "hgnc"
dbDir <- "/gpfs0/home2/gdrobertslab/lab/Analysis/Yogesh/CellTypeAnnRefs/input/downloads/SCENIC"
myDatasetTitle <- "SCENIC tutorial"
data(defaultDbNames)
dbs <- defaultDbNames[[org]]

scenicoptions <- SCENIC::initializeScenic(org = org,
                                        dbDir = dbDir,
                                        dbs = dbs,
                                        datasetTitle = myDatasetTitle,
                                        nCores = 10)

motifAnnotations_hgnc <- motifAnnotations

scenicOptions <- SCENIC::initializeScenic(org = org,
                                        dbDir = dbDir,
                                        dbs = dbs,
                                        datasetTitle = myDatasetTitle,
                                        nCores = 10)

scenicOptions@inputDatasetInfo$cellInfo <- #cellInfo
    "input/downloads/SCENIC/cellInfo.Rds"

scenicOptions@inputDatasetInfo$colVars <- #colVars
    "input/downloads/SCENIC/colVars.Rds"

##### III: Co-expression network
### 1. Gene filter/selection
# (Adjust minimum values according to your dataset)
genesKept <- geneFiltering(exprMat, scenicOptions=scenicOptions,
                           minCountsPerGene=3*.01*ncol(exprMat),
                           minSamples=ncol(exprMat)*.01)

# check interesting genes
interestingGenes <- c("ISG15", "PTEN", "IL16", "FOXM1")
# any missing?
interestingGenes[which(!interestingGenes %in% genesKept)]

# filter the expression matrix to contain only these 770 genes. 
# This matrix is now ready for the co-expression analysis.
exprMat_filtered <- exprMat[genesKept, ]
dim(exprMat_filtered)

### 2. Correlation: positive means TF could upregulate the target gene and viceversa
runCorrelation(exprMat_filtered, scenicOptions)

### 3. Run GENIE3 to infer potential transcription factor targets
# Optional: add log (if it is not logged/normalized already)
exprMat_filtered <- log2(exprMat_filtered+1)

# Run GENIE3 and find potential TF targets
runGenie3(exprMat_filtered, scenicOptions)

###### IV: Build the gene regulatory network & Identify cell states:
### Build the gene regulatory network: 
# 1. Get co-expression modules
scenicOptions <- runSCENIC_1_coexNetwork2modules(scenicOptions)

# 2. Get regulons (with RcisTarget: TF motif analysis)
scenicOptions <- runSCENIC_2_createRegulons(scenicOptions,
                                            coexMethod=c("top5perTarget"))

### Identify cell states: 
# 3. Score GRN (regulons) in the cells (with AUCell) 
exprMat_log <- log2(exprMat+1)

scenicOptions <- runSCENIC_3_scoreCells(scenicOptions, exprMat_log)

###### Save the analysis
saveRDS(scenicOptions, 
        file="input/downloads/SCENIC/scenicOptions.Rds")




# 4. Optional steps:
# 4.1 Look the results in shinyAPP
aucellApp <- plotTsne_AUCellApp(scenicOptions, exprMat_log)
savedSelections <- shiny::runApp(aucellApp)

# 4.2 Binarize the network activity (regulon on/off)
scenicOptions@settings$devType="png"
scenicOptions <- runSCENIC_4_aucell_binarize(scenicOptions, exprMat_log)

# 4.3 Cluster cells according to the GRN activity (Optional)
# 4.3.1 set number of PCs
nPcs <- c(5) # For demo dataset, # nPcs <- c(5,15,50)

# 4.3.2 Calculates the t-SNE based on the regulon activity
scenicOptions@settings$seed <- 123    #same seed for all of them
fileNames <- tsneAUC(scenicOptions, aucType="AUC", nPcs=nPcs, perpl=c(5,15,50))
fileNames

par(mfrow=c(2,3))
plotTsne_compareSettings("int/tSNE_AUC_05pcs_05perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_AUC_05pcs_15perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_AUC_05pcs_50perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

# 4.3.3 Calculates the t-SNE using only "high-confidence" regulons
fileNames <- tsneAUC(scenicOptions, aucType="AUC", nPcs=nPcs, perpl=c(5,15,50),
                     onlyHighConf=TRUE, filePrefix="int/tSNE_oHC")
fileNames

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_05perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_15perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

plotTsne_compareSettings("int/tSNE_oHC_AUC_05pcs_50perpl.Rds", scenicOptions, 
                         showLegend=FALSE, varName="CellType", cex=.5)

# 4.3.4 Save defalt t-SNE
scenicOptions@settings$defaultTsne$aucType <- "AUC"
scenicOptions@settings$defaultTsne$dims <- 5
scenicOptions@settings$defaultTsne$perpl <- 15
saveRDS(scenicOptions, 
        file="input/downloads/SCENIC/scenicOptions.Rds")

print(tsneFileName(scenicOptions))

### 1. Identify Cell states and their regulators
## 1.1 Projection the AUC and TF expression onto t-SNEs
# load data from int fold
loadInt(scenicOptions)
aucell_regulonAUC <- loadInt(scenicOptions, "aucell_regulonAUC")

tsneFileName(scenicOptions)
par(mfrow=c(2,3))
plotTsne_compareSettings(tsneFileName(scenicOptions), scenicOptions, 
                         showLegend=TRUE, varName="CellType", cex=.5)

# Show TF expression:
tSNE_scenic <- readRDS(tsneFileName(scenicOptions))
AUCell::AUCell_plotTSNE(tSNE_scenic$Y, exprMat, 
  aucell_regulonAUC[onlyNonDuplicatedExtended(
    rownames(aucell_regulonAUC))[c("MRPL20", "MAX", "SDF4", "RFX5", "NFIC")],], 
  plots="Expression")

# Save AUC as PDF (Export):
dev.off()

## 1.2 Density plot to detect most likely stable states (high density area)
library(KernSmooth)
library(RColorBrewer)
dens2d <- bkde2D(tSNE_scenic$Y, 1)$fhat
image(dens2d, col = brewer.pal(9, "YlOrBr"), axes=FALSE)
contour(dens2d, add = TRUE, nlevels= 5, drawlabels=FALSE)

### 2. Regulon targets
## Output file: Step2_regulonTargetsInfo

# subset regulonTargetsInfo before exporting it as HTML
regulonTargetsInfo <- loadInt(scenicOptions, "regulonTargetsInfo")
tableSubset <- regulonTargetsInfo[TF=="Stat6" & highConfAnnot==TRUE]
viewMotifs(tableSubset, options=list(pageLength=5)) 

# Targets for intereted TFs
regulons <- loadInt(scenicOptions, "regulons")
regulons[c("SPI1", "CEBPD", "CEBPB")]

# Only regulons with 10 genes or more are scored with AUCell
regulons <- loadInt(scenicOptions, "aucell_regulons")
head(cbind(onlyNonDuplicatedExtended(names(regulons))))

### 3. Regulon motifs
# The full list of TF motifs: Step2_MotifEnrichment

# showing motifs for interested TF
motifEnrichment_selfMotifs_wGenes <- loadInt(scenicOptions, 
                                    "motifEnrichment_selfMotifs_wGenes")
tableSubset <- motifEnrichment_selfMotifs_wGenes[highlightedTFs=="Sox9"]
viewMotifs(tableSubset) 

### 4. combine SCENIC analysis with other analysis tools
#Regulators for known cell types or clusters
## 4.1 ComplexHeatmap to show average regulon activity by cell clusters
library(ComplexHeatmap)
regulonAUC <- loadInt(scenicOptions, "aucell_regulonAUC")
regulonAUC <- regulonAUC[onlyNonDuplicatedExtended(rownames(regulonAUC)),]
regulonActivity_byCellType <- sapply(split(rownames(cellInfo), 
                cellInfo$CellType),
                function(cells) rowMeans(getAUC(regulonAUC)[,cells]))
regulonActivity_byCellType_Scaled <- t(scale(t(regulonActivity_byCellType), 
                                             center = T, scale=T))

ComplexHeatmap::Heatmap(
  regulonActivity_byCellType_Scaled, name="Regulon activity")

# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Scaled)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>0),]
viewTable(topRegulators)

## 4.2 Binarized data
minPerc <- .4 # percentage of cells in a cluster with the regulon is active
binaryRegulonActivity <- loadInt(scenicOptions, "aucell_binary_nonDupl")
cellInfo_binarizedCells <- cellInfo[which(
  rownames(cellInfo)%in% colnames(binaryRegulonActivity)),, drop=FALSE]
regulonActivity_byCellType_Binarized <- sapply(
  split(rownames(cellInfo_binarizedCells), cellInfo_binarizedCells$CellType), 
        function(cells) rowMeans(binaryRegulonActivity[,cells, drop=FALSE]))
binaryActPerc_subset <- regulonActivity_byCellType_Binarized[which(
  rowSums(regulonActivity_byCellType_Binarized>minPerc)>0),]
ComplexHeatmap::Heatmap(binaryActPerc_subset, name="Regulon activity", 
                        col = c("white","pink","red"))

# topRegulators for each cell type: Relative Activity
topRegulators <- reshape2::melt(regulonActivity_byCellType_Binarized)
colnames(topRegulators) <- c("Regulon", "CellType", "RelativeActivity")
topRegulators <- topRegulators[which(topRegulators$RelativeActivity>minPerc),]
viewTable(topRegulators)

## 4.3 Cell-type specific regulators based on Regulon Specificity Score (RSS)
regulonAUC <- loadInt(scenicOptions, "aucell_regulonAUC")
rss <- calcRSS(AUC=getAUC(regulonAUC), cellAnnotation=cellInfo[colnames(
  regulonAUC), "CellType"])
rss_for_Plot <- plotRSS(rss)

plotly::ggplotly(rss_for_Plot$plot)

plotRSS_oneSet(rss, setName = "interneurons")



```

## Liger
```{r}
library(rliger)

object <- qs::qread("output/seurat_objects/tumor_vs_stroma/patient_mets_tumor.qs")

# counts<- sobj@assays$RNA@counts

# ifnb_liger <- createLiger(object)

marsh_liger <- rliger::seuratToLiger(objects = sobj, combined.seurat = TRUE, use.idents = T,
    use.tsne = T, meta.var = "orig.ident", remove.missing = FALSE)

marsh_liger@cell.data$tumor_type <- sobj@meta.data$tumor_type
marsh_liger@cell.data$data_type <- sobj@meta.data$sobj@meta.data$data_type
marsh_liger@cell.data$sample_name <- sobj@meta.data$sample_name
marsh_liger@cell.data$model <- sobj@meta.data$model
marsh_liger@cell.data$organism <- obj@meta.data$organism
marsh_liger@cell.data$annotations <- sobj@meta.data$annotations

marsh_liger <- normalize(marsh_liger) %>%
    selectGenes() %>%
    scaleNotCenter() %>%
    optimizeALS(k=20) %>%
    quantile_norm() %>%
    louvainCluster(resolution = 0.25) %>%
    runUMAP(distance = 'cosine',
            n_neighbors = 30,
            min_dist = 0.3)

all.plots <- plotByDatasetAndCluster(marsh_liger, axis.labels = c('UMAP 1', 'UMAP 2'), return.plots = T)
all.plots[[1]] + all.plots[[2]]

```